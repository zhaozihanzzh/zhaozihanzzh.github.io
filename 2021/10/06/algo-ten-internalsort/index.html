

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/res/avatar.png">
  <link rel="icon" href="/images/res/avatar.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#90a4ae">
  <meta name="description" content="">
  <meta name="author" content="zhaozihanzzh">
  <meta name="keywords" content="">
  
  <title>十大常见的内部排序算法 - Blogs of mefailedcoder</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://lib.baomitu.com/highlight.js/10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"zhaozihanzzh.github.io","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#cfd8dc","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>mefailedcoder</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/images/res/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="十大常见的内部排序算法">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-10-06 21:18" pubdate>
        2021-10-06 21:18
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      136
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">十大常见的内部排序算法</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2021-11-27 16:16
                
              </p>
            
            <div class="markdown-body">
              <h1 id="十大常见的内部排序算法"><a href="#十大常见的内部排序算法" class="headerlink" title="十大常见的内部排序算法"></a>十大常见的内部排序算法</h1><p>所谓内部 (Internal) 排序，是指在计算机的主存而非外存中进行的排序。<br>所谓稳定 (Stable) 的排序算法，是指排序完后大小相等的元素的相对位置能保持不变。在以某一键值进行排序时（如基数排序），稳定性是十分重要的。<br>所谓原地排序算法 (In-place Sorting Algorithm)，是指除了函数调用所需的栈和固定数目的实例变量之外无序额外内存的排序算法。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="《算法（第 4 版）》P154
">[1]</span></a></sup></p>
<h2 id="Part-1-排序算法介绍"><a href="#Part-1-排序算法介绍" class="headerlink" title="Part 1 排序算法介绍"></a>Part 1 排序算法介绍</h2><p>在这里，我们以从小到大排序为例介绍这些算法，所有的排序都在数组中进行：</p>
<h3 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1. 选择排序"></a>1. 选择排序</h3><p>选择排序 (Selection Sort) 思路是每次选择最小的元素交换到已经排好的部分的末尾。实现起来较为简易。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selection_sort</span><span class="hljs-params">(T* start, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> scale)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; scale - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">int</span> min_index = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; scale; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (start[j] &lt; start[min_index]) &#123;<br>                min_index = j;<br>            &#125;<br>        &#125;<br>        T exchange = start[i];<br>        start[i] = start[min_index];<br>        start[min_index] = exchange;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>选择排序是不稳定的排序算法：1 2 <strong>7</strong> _7_ 3 -&gt; 1 2 3 _7_ <strong>7</strong><br>选择排序的时间复杂度在一般情况下为 O(n<sup>2</sup>)，不存在更好或更差的情况。<br>空间复杂度为 O(1)，是原地排序算法。</p>
<h3 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h3><p>插入排序 (Insertion Sort) 思路类似按高矮排队时新来了一个人的情况，这个人站到队尾后便开始与前面比他高的人不停地交换位置。元素越有序，对插入排序就越有利。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertion_sort</span><span class="hljs-params">(T* start, <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> scale)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; scale; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt; <span class="hljs-number">0</span> &amp;&amp; start[j] &lt; start[j - <span class="hljs-number">1</span>]; --j) &#123;<br>            T temp = start[j];<br>            start[j] = start[j - <span class="hljs-number">1</span>];<br>            start[j - <span class="hljs-number">1</span>] = temp;<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><br>交换元素时不会改变相同元素的相对顺序，故插入排序是稳定的排序算法。<br>插入排序平均时间复杂度为 O(n<sup>2</sup>)，最好情况下（元素全部有序）时间复杂度为 O(n)，这是内层循环条件不满足；最坏情况是完全逆序时，这时需要把每次遍历到的元素交换到最开头。<br>空间复杂度为 O(1)，是原地排序。</p>
<h3 id="3-冒泡排序及其改进"><a href="#3-冒泡排序及其改进" class="headerlink" title="3. 冒泡排序及其改进"></a>3. 冒泡排序及其改进</h3><p>冒泡排序 (Bubble Sort) 的思路是每次将未排序元素中最小或最大的交换到一端，形似因密度不同而不断冒出的气泡。由于每次都挑出最值，因此每挑出一次，下一次的最值就是上次的次最值，排在上次挑出值的后面。要注意挑出的最值位于遍历方向的末尾。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">original_bubble_sort</span><span class="hljs-params">(T *data, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; len - i; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (data[j] &gt; data[j - <span class="hljs-number">1</span>]) &#123;<br>                std::<span class="hljs-built_in">swap</span>(data[j], data[j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>冒泡排序是稳定的排序算法，由于交换的是相邻的元素，不会有相等的元素越过对方。<br>冒泡排序时间复杂度为 O(n<sup>2</sup>)，空间复杂度为 O(1)，属于原地排序。</p>
<p>但这还没完，冒泡排序显然还有优化的空间：</p>
<h4 id="1-有序时停止"><a href="#1-有序时停止" class="headerlink" title="1. 有序时停止"></a>1. 有序时停止</h4><p>在已经有序（即一轮比较后不发生任何交换）的情况下，可以停止排序了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">timelystop_bubble_sort</span><span class="hljs-params">(T *data, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">bool</span> has_exchange = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; len - i; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (data[j] &gt; data[j - <span class="hljs-number">1</span>]) &#123;<br>                std::<span class="hljs-built_in">swap</span>(data[j], data[j - <span class="hljs-number">1</span>]);<br>                has_exchange = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!has_exchange) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>此时，最好情况下（已有序）时间复杂度为 O(n)。</p>
<h4 id="2-确定有序边界"><a href="#2-确定有序边界" class="headerlink" title="2. 确定有序边界"></a>2. 确定有序边界</h4><p>从全部有序的情况出发，进一步地，如果数组只是末尾有序，虽然不能直接退出排序，但可以省掉末尾的部分（开头有序没法省去，因为要从里面挑元素往后移动，即使开头的元素有序了，那也不是它们最终的位置）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">skipsorted_bubble_sort</span><span class="hljs-params">(T *data, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> border = len;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">int</span> last_exchange = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; border; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (data[j] &lt; data[j - <span class="hljs-number">1</span>]) &#123;<br>                std::<span class="hljs-built_in">swap</span>(data[j], data[j - <span class="hljs-number">1</span>]);<br>                last_exchange = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (last_exchange == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        border = last_exchange;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时最好的时间复杂度为 O(n)。</p>
<h4 id="3-鸡尾酒排序"><a href="#3-鸡尾酒排序" class="headerlink" title="3. 鸡尾酒排序"></a>3. 鸡尾酒排序</h4><p>鸡尾酒排序 (Cocktail Sort) 是“来回”的冒泡排序。传统的冒泡排序在升序时，最小元素在数组末尾会一点一点往上冒，而最大元素在起始却一趟就冒过去了。为了更好地平衡，可以在顺序冒一趟后倒序再来。这里我们直接在上面确定有序边界版本的冒泡排序上作修改：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">skipsorted_cocktail_sort</span><span class="hljs-params">(T *data, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> last_exchange = <span class="hljs-number">0</span>, first_exchange = len;<br>    <span class="hljs-keyword">int</span> max_border = len, min_border = <span class="hljs-number">0</span>; <span class="hljs-comment">// 两个都取不到</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = min_border + <span class="hljs-number">1</span>; j &lt; max_border; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (data[j] &lt; data[j - <span class="hljs-number">1</span>]) &#123;<br>                std::<span class="hljs-built_in">swap</span>(data[j], data[j - <span class="hljs-number">1</span>]);<br>                last_exchange = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (last_exchange == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = last_exchange - <span class="hljs-number">1</span>; j &gt; min_border; --j) &#123;<br>            <span class="hljs-keyword">if</span> (data[j] &lt; data[j - <span class="hljs-number">1</span>]) &#123;<br>                std::<span class="hljs-built_in">swap</span>(data[j], data[j - <span class="hljs-number">1</span>]);<br>                first_exchange = j - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (first_exchange == len) <span class="hljs-keyword">break</span>;<br>        max_border = last_exchange;<br>        min_border = first_exchange;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h3 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h3><p>希尔排序 (Shell Sort，以发明者的名字命名) 又称递减增量排序 (Diminishing Increment Sort)，它使用插入排序先使数组中任意间隔 h 的元素有序，然后按照一定的序列减小 h （要求 h 最后要以 1 结尾）并按减小的 h 排序。这里，我们使用 1/2(3<sup>k</sup>-1) 作为希尔排序的递增序列，递增到小于数组长度的最大值，然后每次除以 3，直到等于 1：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shell_sort</span><span class="hljs-params">(T* start, <span class="hljs-keyword">int</span> scale)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> span = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (span &lt; scale / <span class="hljs-number">3</span>) span = <span class="hljs-number">3</span> * span + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (span &gt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = span; i &lt; scale; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt;= span &amp;&amp; start[j] &lt; start[j - span]; j-= span) &#123;<br>                T temp = start[j];<br>                start[j] = start[j - span];<br>                start[j - span] = temp;<br>            &#125;<br>        &#125;<br>        span = span / <span class="hljs-number">3</span>;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><br>希尔排序交换元素时会跨越一部分元素，因此可能改变相等元素的相对位置，是不稳定的排序算法：<strong>3</strong> _3_ 1 -&gt; 1 _3_ <strong>3</strong><br>希尔排序的时间复杂度似乎是无法准确描述的。这里给出的算法在最坏情况下的时间复杂度为 O(1.5)，空间复杂度为 O(1)，是原地排序。</p>
<h3 id="5-归并排序及其改进"><a href="#5-归并排序及其改进" class="headerlink" title="5. 归并排序及其改进"></a>5. 归并排序及其改进</h3><p>归并排序 (Merge Sort) 是通过将已经排序好的两个小的子数组合并成大的数组实现的，传统上，归并排序需要一个辅助数组，在排序通过双指针时判断是把哪个小数组中的元素加入。这里我们用自顶向下的方法，先分割，直到无法再分割，然后通过函数栈的顺序调用来合并。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MergeSorts</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> T* auxiliary;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(T* start, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left_cursor = low,<br>            right_cursor = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 指向第一个没加入的元素</span><br>        <span class="hljs-keyword">if</span> (start[mid] &lt;= start[mid + <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果已经满足有序，直接返回</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = low; i &lt;= high; ++i) &#123;<br>            auxiliary[i] = start[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = low; i &lt;= high; ++i) &#123;  <span class="hljs-comment">// 设计好循环的次数，保证不越界</span><br>            <span class="hljs-keyword">if</span> (left_cursor &gt; mid)<br>                start[i] = auxiliary[right_cursor++];  <span class="hljs-comment">// 左边全加进去了加右边</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right_cursor &gt; high)<br>                start[i] = auxiliary[left_cursor++];  <span class="hljs-comment">// 右边全加进去了加左边</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (auxiliary[left_cursor] &gt; auxiliary[right_cursor])<br>                start[i] = auxiliary[right_cursor++]; <span class="hljs-comment">// 否则就比左右大小决定</span><br>            <span class="hljs-keyword">else</span><br>                start[i] = auxiliary[left_cursor++];  <span class="hljs-comment">// 注意排序稳定性（元素相等时）</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 注意 low 和 high 能不能取到：这里都能取到</span><br>    <span class="hljs-comment">// 如果 low 和 high 相等，直接返回，保证 merge 函数 low 和 high 差至少为 2；</span><br>    <span class="hljs-comment">// 差 1 的时候 mid 与 low 相等，mid + 1 与</span><br>    <span class="hljs-comment">// high 相等，不重叠</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort_TD</span><span class="hljs-params">(T* start, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (high &lt;= low)<br>            <span class="hljs-keyword">return</span>;                        <span class="hljs-comment">// Only one in selection.</span><br>        <span class="hljs-keyword">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// Ensure mid &lt;= high</span><br>        <span class="hljs-built_in">merge_sort_TD</span>(start, low, mid);<br>        <span class="hljs-built_in">merge_sort_TD</span>(start, mid + <span class="hljs-number">1</span>, high);<br>        <span class="hljs-built_in">merge</span>(start, low, mid, high);<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort_TopDown</span><span class="hljs-params">(T* start, <span class="hljs-keyword">int</span> scale)</span> </span>&#123;<br>        auxiliary = <span class="hljs-keyword">new</span> T[scale];<br>        <span class="hljs-built_in">merge_sort_TD</span>(start, <span class="hljs-number">0</span>, scale - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">delete</span>[] auxiliary;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; T* MergeSorts&lt;T&gt;::auxiliary;<br></code></pre></td></tr></table></figure>
<p>类似地，还有自底向上的归并排序，从最小单元开始逐步增大小数组的长度来合并：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort_UpBottom</span><span class="hljs-params">(T* start, <span class="hljs-keyword">int</span> scale)</span> </span>&#123;<br>    auxiliary = <span class="hljs-keyword">new</span> T[scale];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> sub_length = <span class="hljs-number">1</span>; sub_length &lt; scale; sub_length *= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> left_cursor = <span class="hljs-number">0</span>; left_cursor &lt; scale - sub_length; left_cursor+= <span class="hljs-number">2</span> * sub_length) &#123;<br>            <span class="hljs-built_in">merge</span>(start, left_cursor, left_cursor + sub_length - <span class="hljs-number">1</span>, std::<span class="hljs-built_in">mi</span>(left_cursor + <span class="hljs-number">2</span> * sub_length - <span class="hljs-number">1</span>, (scale - <span class="hljs-number">1</span>)));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] auxiliary;<br>&#125;<br></code></pre></td></tr></table></figure><br>这样看，归并排序是稳定的排序算法，归并时子数组的相对位置不改变，相等的元素也可以按照先后顺序并入最后的答案中。<br>如果采用树形结构描述归并排序的递归流程，由于每“层”中各次操作加起来（例如调用前 1/4，上 1/4，下 1/4，末 1/4）都得比较整个数组一遍，而有大约 log<sub>2</sub>n 层（递归深度），故一般的时间复杂度为 O(nlogn)。考虑到针对有序子数组的优化，最好的情况下比较是 O(n) 的。<br>需要额外数组，空间复杂度为 O(n)。<br>但归并排序也有优化空间，可以通过在每层遍历时交换输入原数据的数组和辅助数组来减少归并时的数组复制：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// std::swap 会交换指针指向的对象，需要自己的交换函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap_ptr</span><span class="hljs-params">(T *&amp; a, T *&amp; b)</span> </span>&#123;<br>    T *temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(T* start, T* auxiliary, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left_cursor = low,<br>        right_cursor = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 指向第一个没加入的元素</span><br>    <span class="hljs-comment">//if (start[mid] &lt;= start[mid + 1])</span><br>    <span class="hljs-comment">//    return;  //  不能使用这样的优化，因为在 auxiliary 和 start 交换优化时这两个数组根本不相等，没法把 auxiliary 写回</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = low; i &lt;= high; ++i) &#123;  <span class="hljs-comment">// 设计好循环的次数，保证不越界</span><br>        <span class="hljs-keyword">if</span> (left_cursor &gt; mid)<br>            start[i] = auxiliary[right_cursor++];  <span class="hljs-comment">// 左边全加进去了加右边</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right_cursor &gt; high)<br>            start[i] = auxiliary[left_cursor++];  <span class="hljs-comment">// 右边全加进去了加左边</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (auxiliary[left_cursor] &gt; auxiliary[right_cursor])<br>            start[i] = auxiliary[right_cursor++];<br>        <span class="hljs-keyword">else</span><br>            start[i] = auxiliary[left_cursor++];  <span class="hljs-comment">// 否则就比左右大小决定</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort_TD</span><span class="hljs-params">(T* start, T* auxiliary, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (high &lt;= low)<br>        <span class="hljs-keyword">return</span>;                        <span class="hljs-comment">// Only one in selection.</span><br>    <span class="hljs-keyword">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// Ensure mid &lt;= high</span><br>    <span class="hljs-built_in">merge_sort_TD</span>(auxiliary, start, low, mid);<br>    <span class="hljs-built_in">merge_sort_TD</span>(auxiliary, start, mid + <span class="hljs-number">1</span>, high);<br>    <span class="hljs-built_in">merge</span>(start, auxiliary, low, mid, high);<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort_TopDown</span><span class="hljs-params">(T* start, <span class="hljs-keyword">int</span> scale)</span> </span>&#123;<br>    T *auxiliary = <span class="hljs-keyword">new</span> T[scale];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; scale; ++i) &#123;<br>        auxiliary[i] = start[i];<br>    &#125;<br>    <span class="hljs-built_in">merge_sort_TD</span>(start, auxiliary, <span class="hljs-number">0</span>, scale - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">delete</span>[] auxiliary;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h3 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h3><p>快速排序 (Quick Sort) 被誉为是“20世纪对科学和工程领域的发展产生最大影响力的十大算法”<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.sciencenet.cn/blog-83029-468247.html
">[2]</span></a></sup>，在快速排序中对给定的范围需要选定一个切分元素（“轴”元素 pivot），接下来保证比它大的元素在切分元素后面，比它小的在前面，不断缩小范围，直到完成排序。这就好像给 N 个班混在一起的考试卷分开一样，先大体上分成几小堆，再继续分（先忽略那个 move_pivot_to_first 函数）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">part</span><span class="hljs-params">(T* start, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-built_in">move_pivot_to_first</span>(start, left, right);<br>    <span class="hljs-keyword">int</span> l_cursor = left, r_cursor = right + <span class="hljs-number">1</span>;<br>    T partition = start[left];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">while</span> (start[++l_cursor] &lt; partition) <span class="hljs-keyword">if</span> (l_cursor == right) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">while</span> (start[--r_cursor] &gt; partition) ;<span class="hljs-comment">/*if (r_cursor == left) break;*/</span><br>        <span class="hljs-keyword">if</span> (l_cursor &gt;= r_cursor) <span class="hljs-keyword">break</span>;<br>        std::<span class="hljs-built_in">swap</span>(start[l_cursor], start[r_cursor]);<br>    &#125;<br>    std::<span class="hljs-built_in">swap</span>(start[left], start[r_cursor]);<br>    <span class="hljs-keyword">return</span> r_cursor;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(T* start, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> <span class="hljs-comment">/* 闭区间 */</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (right &lt;= left) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> partition = <span class="hljs-built_in">part</span>(start, left, right);<br>    <span class="hljs-built_in">quick_sort</span>(start, left, partition - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quick_sort</span>(start, partition + <span class="hljs-number">1</span>, right);<br>&#125;<br></code></pre></td></tr></table></figure><br>每次进行切分的步骤是：规定切分元素是某段数组的首个元素，略过数组首个元素，向右移动左指针，直到它不小于切分元素大小或达到右边界，这时左指针以左全是小于切分元素的值；向左移动右指针，直到它不大于切分元素（不用检查是不是到了左边界，左边最前面就是切分元素，最坏情况会停在切分元素上），这时它右边的值全部大于切分元素；检查左右指针相对位置，如果有重叠，说明已经完成切分，此时把首个元素和右指针指向元素进行交换即可（为什么交换右指针指向元素？因为首个元素在左侧，交换后必须保证它小于等于切分元素，而此时左指针已经移出小于切分元素值的区域了，可能指向的是第一个大于切分元素值的元素）；如果不重叠，直接交换左右指针指向的元素，再继续进行这一步骤。<br>完成切分之后，返回切分元素的位置（右指针），这样就把数组切成两小段，再继续切分。<br>由此可见，如果选择的切分元素大小处在待排序元素的中位数附近，那么两个子数组长度接近，可以使得递归的深度更小（接近 log N），每层合计需要遍历所有元素，则其时间复杂度为 O(nlog n)。然而，如果每次切分所选择的都是最大或者最小的元素——如这个数组本来就是有序的，那么递归的深度为 N，此时整个排序过程成为 O(N<sup>2</sup>) 的时间复杂度，这显然是我们不希望的。因此，一味地选取数组首个元素作为切分元素是不合适的，在这里我们采用三取样切分，取首个元素下一位，中间，末尾三个值的中位数与数组首个元素交换以减少最坏情况的发生（这里参考了 gcc 11.1.0 的 <code>std::__move_median_to_first</code> 函数）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">move_pivot_to_first</span><span class="hljs-params">(T *array, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> middle = (right - left) / <span class="hljs-number">2</span> + left; <span class="hljs-comment">// 防 int 溢出</span><br>    <span class="hljs-keyword">if</span> (array[left + <span class="hljs-number">1</span>] &lt; array[right]) &#123;<br>        <span class="hljs-keyword">if</span> (array[right] &lt; array[middle])  &#123;<br>            std::<span class="hljs-built_in">swap</span>(array[left], array[right]);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (array[middle] &lt; array[left + <span class="hljs-number">1</span>]) &#123;<br>            std::<span class="hljs-built_in">swap</span>(array[left], array[left + <span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        std::<span class="hljs-built_in">swap</span>(array[left], array[middle]);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (array[left + <span class="hljs-number">1</span>] &lt; array[middle]) &#123;<br>        std::<span class="hljs-built_in">swap</span>(array[left + <span class="hljs-number">1</span>], array[left]);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (array[middle] &lt; array[right]) &#123;<br>        std::<span class="hljs-built_in">swap</span>(array[right], array[left]);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    std::<span class="hljs-built_in">swap</span>(array[middle], array[left]);<br>&#125;<br></code></pre></td></tr></table></figure><br>可以看出，快速排序对于随机性强的数据更有优势，而对于已经部分有序的数据，则不能利用这种有序性。快速排序是原地排序算法，但我们的实现版本需要递归，当每次切分元素都较为均匀时，递归深度接近 log<sub>2</sub>N，此时空间复杂度为 O(log N)（由于栈是先入后出的，此时递归二叉树的另一半还没有长出来，另一半生长出来时左边已经释放了，而我们只考虑同一时间占用的最大内存）；当每次切分元素都是两端的元素时，空间复杂度达到了 O(n)。此外，快速排序是不稳定的排序算法，如果左右指针指向的元素大小相同，并且他们被分别切到了左右两边，那么这对元素仍然会被交换位置。</p>
<h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h3><p>堆排序 (Heap Sort) 的一种实现方法是为元素创建最大堆，每次取出堆顶最大元素并移动到数组的最后，从而得到有序数组。在建堆过程中，由上而下进行有序化，保证节点大于其儿子节点的过程成为下沉 (sink)；由下而上进行有序化，保证节点小于其父亲的过程称为上浮 (swim)。在输入数组中构造堆时，可以自顶向下推进，依次把末尾的新节点上浮，也可以自底向上，依次把新节点下沉。自底向上建堆时，可以把后一半的节点（叶子节点）省掉，且插入大量底部节点时树高较小，插入少量顶部节点时树高较大，更加合理，但判断与哪个儿子交换时会略微复杂。我们采用自底向上建堆的方法建立最大堆。之后，我们将堆顶的元素与最后一个元素交换，这时最后一个元素是最大元素，我们把它排除在堆外，即令堆的大小减 1，再从堆顶进行下沉操作，得到新的最大堆，再取堆顶与倒数第二个元素交换，这样一直进行下去：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* Make sure that the pointer start points at the top of the heap, </span><br><span class="hljs-comment">otherwise we can&#x27;t access the children by 2 * start_position + 1/ + 2 */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sink</span><span class="hljs-params">(T *start, <span class="hljs-keyword">int</span> start_position,  <span class="hljs-keyword">int</span> scale)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span> &gt;= scale) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * start_position + <span class="hljs-number">2</span> &gt;= scale) &#123; <span class="hljs-comment">/* only left child */</span><br>            <span class="hljs-keyword">if</span> (start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span>] &gt; start[start_position]) &#123;<br>                T temp = start[start_position];<br>                start[start_position] = start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span>];<br>                start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span>] = temp;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span>] &gt; start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">2</span>]) &#123; <span class="hljs-comment">/* left child bigger than right*/</span>          <br>            <span class="hljs-keyword">if</span> (start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span>] &gt; start[start_position]) &#123; <span class="hljs-comment">/* left bigger than father */</span><br>                T temp = start[start_position];<br>                start[start_position] = start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span>];<br>                start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span>] = temp;<br>                start_position = <span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">/* right child bigger than left */</span><br>        <span class="hljs-keyword">if</span> (start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">2</span>] &gt; start[start_position] <span class="hljs-comment">/* right child bigger than father*/</span>) &#123;<br>            T temp = start[start_position];<br>            start[start_position] = start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">2</span>];<br>            start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">2</span>] = temp;<br>            start_position = <span class="hljs-number">2</span> * start_position + <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">(T *start, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-comment">// firstly build heap</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> sink_start = length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; sink_start &gt;= <span class="hljs-number">0</span>; --sink_start) &#123;<br>        <span class="hljs-built_in">sink</span>(start, sink_start, length);<br>    &#125;<br>    <span class="hljs-comment">// secondly swap the top elem with the last and sink the top again</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; ++i) &#123;<br>        T top = *start;<br>        *start = *(start + length - i);<br>        *(start + length - i) = top;<br><br>        <span class="hljs-built_in">sink</span>(start, <span class="hljs-number">0</span>, length - i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>建堆时我们自底向上地建堆，假设这个堆有 N = 2<sup>k</sup>-1 个元素，建立自底向上第 i 层时共有 $\frac{N+1}{2^i}$ 个元素，每个元素下沉时最多比较 2(i-1) 次，总比较次数 $\sum_{i-1}^{\log_{2}(N+1)}{\frac{N+1}{2^i}\cdot{}{2(i-1)}}$ ，经错位相减求和可知，建堆需要 O(n) 时间复杂度；每次删除最大元素后的调整是 log n 级别的，全部删除元素需要 O(nlog n) 时间复杂度，故整个堆排序的时间复杂度为 O(nlog n)。但是，堆排序比较大小的数据（儿子节点、父亲节点）在内存中常常不连续，而快速排序访问连续的数据的比重更大，根据局部性原理，快速排序对 cache 等利用效率更高，要更快一些。<br>堆排序是原地排序，空间复杂度为 O(1)。堆排序也不是稳定的排序算法：9 _4_ <strong>4</strong> -&gt; <strong>4</strong> _4_  9<br>R.W. Floyd 提出<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="《算法（第 4 版）》P208
">[3]</span></a></sup>，由于建堆后数组末尾的元素均是较小的元素，它们在交换到堆顶后大概率还会下沉到很靠近堆底的部分，在每次取出最大元素后可以先另外暂存占用的数组末尾的那个元素，然后从堆顶开始，把较大的儿子节点覆盖到堆顶，再把大儿子的大儿子节点覆盖大儿子，一直到堆底，这时再把暂存的元素放到停下来的位置，从这里开始做上浮操作，这样能避免传统方法（从堆顶下沉）中不必要的比较大小（不用把堆顶和左右节点比较了），虽然看起来额外增加了一段路程，但总体上是减少了比较次数的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swim</span><span class="hljs-params">(T *start, <span class="hljs-keyword">int</span> node_pos)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (node_pos) &#123;<br>        <span class="hljs-keyword">if</span> (start[(node_pos - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>] &lt; start[node_pos]) &#123;<br>            T temp = start[node_pos];<br>            start[node_pos] = start[(node_pos - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>];<br>            node_pos = (node_pos - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            start[node_pos] = temp;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heap_sort_floyd</span><span class="hljs-params">(T *start, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> sink_start = length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; sink_start &gt;= <span class="hljs-number">0</span>; --sink_start) &#123;<br>        <span class="hljs-built_in">sink</span>(start, sink_start, length);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; ++i) &#123;<br>        T end = *(start + length - i);<br>        *(start + length - i) = *start;<br>        <span class="hljs-keyword">int</span> new_pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &gt;= length - i) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">2</span> &gt;= length - i) &#123; <span class="hljs-comment">// only left child</span><br>                <span class="hljs-comment">//if (start[new_pos * 2 + 1] &gt; start[new_pos]) &#123;</span><br>                    start[new_pos] = start[new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>                    new_pos = new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//&#125;</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (start[new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &gt; start[new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>]) &#123;<br>                start[new_pos] = start[new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>                new_pos = new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                start[new_pos] = start[new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>];<br>                new_pos = new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        start[new_pos] = end;<br>        <span class="hljs-built_in">swim</span>(start, new_pos);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h3 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8. 计数排序"></a>8. 计数排序</h3><p>计数排序（Counting Sort）可以通过用元素值直接访问数组来统计比某个元素小的元素的个数，从而得出元素排序后的数组下标来实现排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">counting_sort</span><span class="hljs-params">(T *start, <span class="hljs-keyword">int</span> elem_num, <span class="hljs-keyword">int</span> array_size)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> *times = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[array_size];<br>    <span class="hljs-built_in">memset</span>(times, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) * array_size);<br>    <span class="hljs-keyword">int</span> *offset = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[elem_num];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elem_num; ++i) &#123;<br>        ++times[start[i]];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; array_size; ++i) &#123;<br>        times[i] += times[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = elem_num - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        offset[i] = --times[start[i]];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elem_num; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (offset[i] != i) &#123;<br>            T temp = start[i];<br>            start[i] = start[offset[i]];<br>            start[offset[i]] = temp;<br>            std::<span class="hljs-built_in">swap</span>(offset[i], offset[offset[i]]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] times;<br>    <span class="hljs-keyword">delete</span>[] offset;<br>&#125;<br></code></pre></td></tr></table></figure><br>此排序算法要求待排序元素的键值必须能作为数组下标，且要求我们知道待排序元素的取值范围。我们申请一个与取值范围相同的数组并赋初值为 0，之后通过元素的键值直接访问该数组，将对应值加 1，直到遍历全部元素。之后，从前到后地，把取值范围数组中（从第二个元素开始）每个位置上的元素与前一个位置上的元素相加并赋值给这个位置，这样这个位置下标的值就是从小到大访问到这个元素时，总共已经有了多少元素。遍历完后，可以新建一个临时数组以保存排序结果，从后往前遍历源数组，把源数组元素值作为下标访问取值范围数组，得到的值就是其在临时数组中的下标，之后再把刚刚用源数组元素值访问范围数组得到的值 - 1 后写回。通过倒序遍历、减一写回，我们实现了排序的稳定性。但是不同版本计数排序实现不同，代码中的版本是不开辅助数组的版本，仍然保证了排序的稳定性。<br>计数排序正是一种不基于比较的排序算法。以上代码排序 int 时的时间复杂度为 O(n+k)，空间复杂度为 O(k)，其中 k 为数字的范围。当 n+k &lt; nlog n 时，计数排序可以实现对快速排序等基于比较的排序算法的超越。然而如果数据过于稀疏，n+k 甚至会远大于 nlog n。</p>
<h3 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9. 桶排序"></a>9. 桶排序</h3><p>我曾经突发奇想，能不能直接利用自然数作为数组下标来访问数组的方式实现排序呢？于是我写下了类似的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Due to the lack of memory, we only allow [0, 2147483646] here.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pigeonhole_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *start, <span class="hljs-keyword">int</span> elem_num, <span class="hljs-keyword">int</span> max_value)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> *array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[max_value + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">memset</span>(array, <span class="hljs-number">-1</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) * (max_value + <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elem_num; ++i) &#123;<br>        ++array[start[i]];<br>    &#125;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; max_value + <span class="hljs-number">1</span>; ++j) &#123;<br>        <span class="hljs-keyword">while</span> (~array[j]) &#123;<br>            start[i++] = j;<br>            --array[j];<br>            <span class="hljs-keyword">if</span> (i == elem_num) &#123;<br>                j = max_value;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] array;<br>&#125;<br></code></pre></td></tr></table></figure><br>虽然开一个 2147483647 长度的整型数组需要大概 8GB 的内存（而且大多数情况下不会有 2147483647 个重复的元素，也就用不到 int 来存放相同元素的个数），但这种朴素的排序算法（鸽巢排序，Pigeonhole Sort）其实正是桶排序 (Bucket Sort) 的雏形。桶排序先用某些键值将元素装进不同的桶里以缩小问题规模，然后常常通过其他排序方式继续对同一个桶中的元素进行排序，最后将桶中的元素依次拿出按顺序放在一起。比如说要对某些日期排序时，先按月份排好，再在每个月份中按日期进行排序。下面的代码通过将 [0, 1) 之间的数据分成 10 个“桶”，然后对每个桶中的链表进行插入排序实现桶排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// [0, 1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bucket_sort_0to1</span><span class="hljs-params">(<span class="hljs-keyword">double</span>* src, <span class="hljs-keyword">size_t</span> len)</span> </span>&#123;<br>    Node** list = <span class="hljs-keyword">new</span> Node*[<span class="hljs-number">10</span>];<br>    <span class="hljs-built_in">memset</span>(list, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Node*) * <span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        Node** ptr = &amp;list[(<span class="hljs-keyword">int</span>)(src[i] * <span class="hljs-number">10</span>)];<br>        <span class="hljs-keyword">while</span> (*ptr) &#123;<br>            <span class="hljs-keyword">if</span> ((*ptr)-&gt;val &lt;= src[i])<br>                ptr = &amp;(*ptr)-&gt;next;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        *ptr = <span class="hljs-keyword">new</span> Node&#123;src[i], *ptr&#125;;<br>    &#125;<br>    <span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i != len) &#123;<br>        Node* ptr = list[j++];<br>        <span class="hljs-keyword">while</span> (ptr) &#123;<br>            src[i] = ptr-&gt;val;<br>            ptr = ptr-&gt;next;<br>            ++i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        <span class="hljs-keyword">delete</span> list[i];<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] list;<br>&#125;<br></code></pre></td></tr></table></figure><br>在这段代码中，当元素均匀分布在 [0, 1) 中时，将元素分为 k 桶需要 O(n) 时间复杂度，而对每一桶元素使用插入排序时间复杂度为 $O(\frac{n^2}{k^2})$，因此总时间复杂度为 $O(n+\frac{n^2}{k})$。当 k 接近于 n 时（接近鸽巢排序），此时总时间复杂度接近 O(n)。然而，最坏情况下，所有元素集中在同一个桶，此时桶排序退化为插入排序，时间复杂度为 O(n<sup>2</sup>)。此外，如果桶的个数 k 远多于 n 时，此时桶排序效率也不够理想。<br>桶排序空间复杂度为 O(n+k)，是稳定的排序算法。</p>
<h3 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10. 基数排序"></a>10. 基数排序</h3><p>当我们比较整数时，常常是由高到低按位比较的，能否依照此思想设计一种排序算法呢？基数排序（Radix Sort）正是一种对各元素从低位到高位先放入个数等于进制数的桶中，再将各桶中的元素按顺序取出，直到整个数组中的元素均有序的排序算法。可以看出，该算法的实现依赖于桶排序的稳定性：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">radix_sort_linkedlist</span><span class="hljs-params">(T *src, <span class="hljs-keyword">int</span> base, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span>Node * next; T elem;&#125;;<br>    Node **list = <span class="hljs-keyword">new</span> Node*[base];<br>    T *sorted = <span class="hljs-keyword">new</span> T[len];<br>    <span class="hljs-built_in">memset</span>(list, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Node*) * base);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        sorted[i] = src[i];<br>    &#125;<br>    <span class="hljs-keyword">int</span> i = base, k = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len ; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (!list[sorted[j] % i / k]) &#123;<br>                list[sorted[j] % i / k] = <span class="hljs-keyword">new</span> Node&#123;<span class="hljs-literal">nullptr</span>, sorted[j]&#125;;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list[sorted[j] % i / k]-&gt;elem &gt; sorted[j]) &#123;<br>                list[sorted[j] % i / k] = <span class="hljs-keyword">new</span> Node&#123;list[sorted[j] % i / k], sorted[j]&#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Node *now = list[sorted[j] % i / k];<br>                <span class="hljs-keyword">while</span> (now-&gt;next &amp;&amp; now-&gt;next-&gt;elem &lt; sorted[j]) now = now-&gt;next;<br>                now-&gt;next = <span class="hljs-keyword">new</span> Node&#123;now-&gt;next, sorted[j]&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> sorted_elem_num = <span class="hljs-number">0</span>, curr_base = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (sorted_elem_num &lt; len) &#123;<br>            Node *curr_node = list[curr_base++];<br>            <span class="hljs-keyword">while</span> (curr_node) &#123;<br>                sorted[sorted_elem_num++] = curr_node-&gt;elem;<br>                curr_node = curr_node-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; base; ++j) &#123;<br>            Node *curr_del = list[j];<br>            <span class="hljs-keyword">while</span> (curr_del) &#123;<br>                Node *temp = curr_del-&gt;next;<br>                <span class="hljs-keyword">delete</span> curr_del;<br>                curr_del = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">memset</span>(list, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Node*) * base);<br>        <span class="hljs-keyword">if</span> (curr_base == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>        i = i * base;<br>        k = k * base;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        src[i] = sorted[i];<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] list;<br>    <span class="hljs-keyword">delete</span>[] sorted;<br>&#125;<br></code></pre></td></tr></table></figure><br>在这里，我们对每一位进行桶排序时，实际上可以利用计数排序的思想直接计算出每个元素在拼接出新数组的位置，从而摆脱有形的“桶”：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">radix_sort</span><span class="hljs-params">(T *src, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">long</span> base)</span> </span>&#123;<br>    T * <span class="hljs-keyword">const</span> initial_src = src;<br>    T *copy = <span class="hljs-keyword">new</span> T[len];<br>    <span class="hljs-keyword">long</span> curr_base = base, last_base = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> *count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[base];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-built_in">memset</span>(count, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) * base);<br>        <span class="hljs-keyword">bool</span> has_nonzero_group = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (src[i] / last_base) has_nonzero_group = <span class="hljs-literal">true</span>;<br>            ++count[src[i] % curr_base / last_base];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!has_nonzero_group) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; base; ++i) &#123;<br>            count[i] += count[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            copy[--count[src[i] % curr_base / last_base]] = src[i];<br>        &#125;<br>        T *temp = src;<br>        src = copy;<br>        copy = temp;<br>        last_base = curr_base;<br>        curr_base *= base;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (initial_src != src) &#123;<br>        T *temp = copy;<br>        copy = src;<br>        src = temp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            src[i] = copy[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] copy;<br>    <span class="hljs-keyword">delete</span>[] count;<br>&#125;<br></code></pre></td></tr></table></figure><br>这里我们每次的模 <code>curr_base</code> 都会与进制数 <code>base</code> 相乘，相当于元素中进行比较的位每次都会左移，实现从低位到高位的比较，同时除以 <code>last_base</code> 舍弃掉末尾已经比较过的位上的数字，同时使得数在 [0, base) 范围内；用 <code>src</code> 和 <code>copy</code> 两个数组来回交换，省去了部分的元素复制操作。<br>基数排序是稳定的排序算法，由于从桶中“拿出”到 <code>copy</code> 是按顺序的，相同大小元素的相对位置不变。<br>基数排序时间复杂度看起来是 O(d(n+k)) ，其中 n 是元素数目，k 是桶的个数，d 是元素的位数，但是 d 与 n 并不是完全无关的：重复元素越少，d 与 n 就越相关，当所有元素均不重复时，$d\geq\log_kn$，此时时间复杂度达到 O(nlog n)级别；当所有元素均大小相等时，时间复杂度为 O(n+k)。不过，我们可以利用计算机多位数比较的硬件能力，将多位数合成一次比较，减少比较次数（认为 CPU 每次比较是等时的，那不妨一次多比较几位）。<br>基数排序空间复杂度为 O(n+k)。（这里采用了类似计数排序的处理方式）<br>显然上面的代码在元素能转为非负整型值时可以排序，但元素是浮点数呢？查阅互联网后，我了解到，IEEE 754 标准下的浮点数，在不考虑符号位时，具有和整型相似的性质：自低位到高位，各位对结果大小的影响越来越大，且高位有“压倒性”优势，那么我们也可以写出如下的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">radix_sort_double</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *src, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> base = <span class="hljs-number">256</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *src_l = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *)src;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> * <span class="hljs-keyword">const</span> initial_src = src_l;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *copy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>[len];<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>[base];<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> FLIP_MSB = (<span class="hljs-number">1ull</span> &lt;&lt; <span class="hljs-number">63</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (src_l[i] &gt;= FLIP_MSB) src_l[i] = ~src_l[i];<br>        <span class="hljs-keyword">else</span> src_l[i] ^= FLIP_MSB;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> eightbit = <span class="hljs-number">0</span>; eightbit &lt; <span class="hljs-number">8</span>; ++eightbit) &#123;<br>        <span class="hljs-built_in">memset</span>(count, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) * base);<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *bit = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *&gt;(src_l) + eightbit; <span class="hljs-comment">// src_l 和 copy 交换，导致只能使用 src_l 不能用 src</span><br><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            ++count[(<span class="hljs-keyword">unsigned</span>)*(bit + <span class="hljs-number">8</span> * i)];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; base; ++i) &#123;<br>            count[i] += count[i - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> (count[(<span class="hljs-keyword">unsigned</span>)*(bit + <span class="hljs-number">8</span> * i)] == <span class="hljs-number">0</span>) <span class="hljs-built_in">abort</span>();<br>            copy[--count[(<span class="hljs-keyword">unsigned</span>)*(bit + <span class="hljs-number">8</span> * i)]] = src_l[i];<br>        &#125;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *temp = src_l;<br>        src_l = copy;<br>        copy = temp;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (initial_src != src_l) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *temp = copy;<br>        copy = src_l;<br>        src_l = temp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            src_l[i] = copy[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (src_l[i] &gt;= FLIP_MSB)<br>        src_l[i] ^= FLIP_MSB;<br>        <span class="hljs-keyword">else</span> src_l[i] = ~src_l[i];<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] copy;<br>    <span class="hljs-keyword">delete</span>[] count;<br>&#125;<br></code></pre></td></tr></table></figure><br>这里我们先把负数取反，因为去掉符号位后绝对值大的负数取反后绝对值小，这样稍后排序时就把小的负数排在大的负数前面；同时对整数只对最高位取反，这样负数的符号位（最高为）实际上成了 0，正数的符号位成了 1，这样稍后排序时负数始终在正数前面。之后，我们由低位向高位 一个字节一个字节地排序（x86 采用小端模式，多字节数据，如这里的 double，的低字节在小的地址端，所以指针递增时实际上是由低字节指向高字节，也就是基数排序从低位向高位转移），最后就能得出结果。</p>
<h2 id="Part-2-总结"><a href="#Part-2-总结" class="headerlink" title="Part 2 总结"></a>Part 2 总结</h2><p>排序算法多种多样，且一种排序算法常有许多不同的实现，本文只是粗浅地谈到了其中的几种。可以看出，基于比较的排序算法平均时间复杂度不可能低于 nlog n 级别，这是因为一般地，要想将 n 个元素排序完毕，必须确定这 n 个元素之间的相对大小关系。n 个元素相对大小关系共有 n! 种可能（相等被合并进大于或者小于里），而我们每进行一次比较，就把可能的大小关系数减少一半，而 n! 总共需要这样“折半”的次数，是计算 log(n!) = nlog n 级别的。在基于比较的排序算法里，当给出的数据是“随机”的时，快速排序似乎是最快的，但它不是稳定的。如果想要稳定的话，可以考虑归并排序。而当数据总体上是有序时，插入排序则常常是最快的。需要实现优先队列时，可能选择的是堆排序。<br>实际上，C++ STL (g++ 11.1.0, Linux x86_64) 上 std::sort 使用的是“内省式排序” (Introspective Sort)，在元素个数大于 16 时先进行快速排序（三取样切分），快速排序时发现递归深度超过 2log n 时启动堆排序，最后使用插入排序收尾。而 Java JDK 1.8 排序整型数组时，长度小于等于 47 时采用插入排序，长度大于 47 小于等于 286 ，或是长度大于 286 且相同元素或乱序组过多时根据数据相等的情况，决定是采用双轴快速排序 (Dual Pivot Quicksort) 还是单轴快速排序，长度大于 286 且有序情况好的整型数组采用归并排序<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://cloud.tencent.com/developer/article/1690708?from=article.detail.1394343
">[4]</span></a></sup>；排序 char、byte 时，数组足够大时将启用计数排序<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.csdn.net/qq_45557225/article/details/105956950
">[5]</span></a></sup>。此外，Python 还使用了 TimSort，这一排序算法被认为在现实数据（有一定的有序片段）的排序中性能超过快速排序。就算是对于我们已经简单介绍过的这些算法，也仍然有许多值得尝试的思路，如使用迭代而非递归实现快速排序。不幸的是，笔者水平有限，也没有如此的精力。我们必须结尾了。</p>
<h2 id="Part-3-性能测试（娱乐）"><a href="#Part-3-性能测试（娱乐）" class="headerlink" title="Part 3 性能测试（娱乐）"></a>Part 3 性能测试（娱乐）</h2><p>下面的代码在 Intel Core i5-10400 的笔记本上编译运行，Linux 内核版本 5.15.2-arch1-1，glibc 版本 2.33-5，g++ 版本 11.1.0：（g++ 开启 O2 优化）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::random_device rd;<br>    <span class="hljs-function">std::default_random_engine <span class="hljs-title">eng</span><span class="hljs-params">(rd())</span></span>;<br>    std::uniform_real_distribution&lt;&gt; <span class="hljs-built_in">distr</span>(下界, 上界);<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> LENGTH = 数组长度;<br>    <span class="hljs-keyword">double</span> test_input_double[LENGTH], test_src[LENGTH], standard_answer[LENGTH];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>); ++i) &#123;<br>        standard_answer[i] = test_input_double[i] = <span class="hljs-built_in">distr</span>(eng);<br>    &#125;<br>    <span class="hljs-keyword">clock_t</span> start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">sort</span>(standard_answer, standard_answer + <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(standard_answer) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br>    cout &lt;&lt; <span class="hljs-string">&quot;std::sort &quot;</span> &lt;&lt;(<span class="hljs-keyword">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">qsort</span>(test_src, LENGTH, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>), double_cmp);<br>    cout &lt;&lt; <span class="hljs-string">&quot;qsort &quot;</span> &lt;&lt;(<span class="hljs-keyword">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) &#123;cout&lt;&lt;<span class="hljs-string">&quot;qsort dead!&quot;</span>&lt;&lt;endl;<span class="hljs-built_in">abort</span>();&#125;<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">selection_sort</span>(test_src, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br>    cout &lt;&lt; <span class="hljs-string">&quot;Selection Sort &quot;</span> &lt;&lt;(<span class="hljs-keyword">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">insertion_sort</span>(test_src, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br>    cout &lt;&lt; <span class="hljs-string">&quot;Insertion Sort &quot;</span> &lt;&lt;(<span class="hljs-keyword">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">skipsorted_cocktail_sort</span>(test_src, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br>    cout &lt;&lt; <span class="hljs-string">&quot;Cocktail Sort(Skip Sorted) &quot;</span> &lt;&lt;(<span class="hljs-keyword">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">shell_sort</span>(test_src, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br>    cout &lt;&lt; <span class="hljs-string">&quot;Shell Sort &quot;</span> &lt;&lt;(<span class="hljs-keyword">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">merge_sort_TopDown</span>(test_src, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br>    cout &lt;&lt; <span class="hljs-string">&quot;Merge Sort(Top Down) &quot;</span> &lt;&lt;(<span class="hljs-keyword">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">quick_sort</span>(test_src, <span class="hljs-number">0</span>,  <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>) - <span class="hljs-number">1</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Quick Sort &quot;</span> &lt;&lt;(<span class="hljs-keyword">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">heap_sort_floyd</span>(test_src, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br>    cout &lt;&lt; <span class="hljs-string">&quot;Heap Sort (Floyd) &quot;</span> &lt;&lt;(<span class="hljs-keyword">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">radix_sort_double</span>(test_src, <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>)));<br>    cout &lt;&lt; <span class="hljs-string">&quot;Radix Sort &quot;</span> &lt;&lt;(<span class="hljs-keyword">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) <span class="hljs-built_in">abort</span>();<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><br>改变数组的长度，下界，上界，每次运行 3 次取平均时间，对随机序列浮点数排序：<br>当上下界为 <code>(-1000, 1000)</code> 时：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数组长度</th>
<th>100</th>
<th>1000</th>
</tr>
</thead>
<tbody>
<tr>
<td>std::sort</td>
<td>7.66667E-06</td>
<td>0.000111667</td>
</tr>
<tr>
<td>qsort</td>
<td>1.33333E-05</td>
<td>0.000197</td>
</tr>
<tr>
<td>选择排序</td>
<td>1.36667E-05</td>
<td>0.001195667</td>
</tr>
<tr>
<td>插入排序</td>
<td>1.03333E-05</td>
<td>0.000722333</td>
</tr>
<tr>
<td>跳过有序部分的鸡尾酒排序</td>
<td>0.000024</td>
<td>0.001728667</td>
</tr>
<tr>
<td>希尔排序</td>
<td>0.000007</td>
<td>9.73333E-05</td>
</tr>
<tr>
<td>自顶向下归并排序</td>
<td>1.03333E-05</td>
<td>0.000105667</td>
</tr>
<tr>
<td>快速排序</td>
<td>0.000008</td>
<td>9.93333E-05</td>
</tr>
<tr>
<td>Floyd 优化堆排序</td>
<td>0.000009</td>
<td>0.000113333</td>
</tr>
<tr>
<td>基数排序</td>
<td>1.33333E-05</td>
<td>0.000046</td>
</tr>
</tbody>
</table>
</div>
<p>当上下界为 <code>(-1000000, 1000000)</code> 时：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数组长度</th>
<th>100</th>
<th>1000</th>
</tr>
</thead>
<tbody>
<tr>
<td>std::sort</td>
<td>1.30E-05</td>
<td>0.000147333</td>
</tr>
<tr>
<td>qsort</td>
<td>2.20E-05</td>
<td>0.000278</td>
</tr>
<tr>
<td>选择排序</td>
<td>2.30E-05</td>
<td>0.001250333</td>
</tr>
<tr>
<td>插入排序</td>
<td>1.63E-05</td>
<td>0.001108</td>
</tr>
<tr>
<td>跳过有序部分的鸡尾酒排序</td>
<td>3.83E-05</td>
<td>0.002401667</td>
</tr>
<tr>
<td>希尔排序</td>
<td>1.07E-05</td>
<td>0.000148667</td>
</tr>
<tr>
<td>自顶向下归并排序</td>
<td>1.67E-05</td>
<td>0.000158</td>
</tr>
<tr>
<td>快速排序</td>
<td>1.37E-05</td>
<td>0.000148</td>
</tr>
<tr>
<td>Floyd 优化堆排序</td>
<td>1.37E-05</td>
<td>0.000170333</td>
</tr>
<tr>
<td>基数排序</td>
<td>2.33E-05</td>
<td>6.53333E-05</td>
</tr>
</tbody>
</table>
</div>
<p>总的来说，数据范围小时，排序似乎更快，以下几组都在 <code>(-1000, 1000)</code> 中测出（这几组由于长度比较长，没有重复实验）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数组长度</th>
<th>10000</th>
<th>100000</th>
<th>1000000</th>
</tr>
</thead>
<tbody>
<tr>
<td>std::sort</td>
<td>0.000936333</td>
<td>0.012468</td>
<td>0.071469</td>
</tr>
<tr>
<td>qsort</td>
<td>0.001347</td>
<td>0.012289333</td>
<td>0.111367</td>
</tr>
<tr>
<td>选择排序</td>
<td>0.033825</td>
<td>2.86037</td>
<td>333.48</td>
</tr>
<tr>
<td>插入排序</td>
<td>0.033676</td>
<td>3.161943333</td>
<td>341.91</td>
</tr>
<tr>
<td>跳过有序部分的鸡尾酒排序</td>
<td>0.091149667</td>
<td>9.482406667</td>
<td>1009.35</td>
</tr>
<tr>
<td>希尔排序</td>
<td>0.000645333</td>
<td>0.008864</td>
<td>0.12158</td>
</tr>
<tr>
<td>自顶向下归并排序</td>
<td>0.000623333</td>
<td>0.008097667</td>
<td>0.097622</td>
</tr>
<tr>
<td>快速排序</td>
<td>0.000550333</td>
<td>0.006777</td>
<td>0.080969</td>
</tr>
<tr>
<td>Floyd 优化堆排序</td>
<td>0.000673333</td>
<td>0.009133667</td>
<td>0.128802</td>
</tr>
<tr>
<td>基数排序</td>
<td>0.000163</td>
<td>0.002073333</td>
<td>0.028749</td>
</tr>
</tbody>
</table>
</div>
<p>仅仅是为了好玩，我又测量了 200000，300000，…，900000 的情况，得到：<br><img src="https://zhaozihanzzh.github.io/images/sort_time.png" srcset="/img/loading.gif" lazyload alt="总用时"><br><img src="https://zhaozihanzzh.github.io/images/sort_withoutn2.png" srcset="/img/loading.gif" lazyload alt="去除 O(n^2) 后的用时"><br>为了考察有序性对性能的影响，当数组长度为 10000，范围 <code>(-1000，1000)</code> 时，测量出完全升序、（第 0，10000，20000，30000，40000，…，90000）随机，其余位置升序、完全降序的情况：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>有序性</th>
<th>完全升序</th>
<th>接近升序</th>
<th>完全降序</th>
</tr>
</thead>
<tbody>
<tr>
<td>std::sort</td>
<td>0.001059</td>
<td>0.005846</td>
<td>0.001357</td>
</tr>
<tr>
<td>qsort</td>
<td>0.002488</td>
<td>0.002918</td>
<td>0.004248</td>
</tr>
<tr>
<td>选择排序</td>
<td>2.84899</td>
<td>3.72152</td>
<td>2.87279</td>
</tr>
<tr>
<td>插入排序</td>
<td>8.6e-05</td>
<td>0.000498</td>
<td>6.33238</td>
</tr>
<tr>
<td>跳过有序部分的鸡尾酒排序</td>
<td>0.000123</td>
<td>1.48579</td>
<td>6.57123</td>
</tr>
<tr>
<td>希尔排序</td>
<td>0.000667</td>
<td>0.00176</td>
<td>0.001462</td>
</tr>
<tr>
<td>自顶向下归并排序</td>
<td>0.001812</td>
<td>0.001958</td>
<td>0.002136</td>
</tr>
<tr>
<td>快速排序</td>
<td>0.001385</td>
<td>0.115653</td>
<td>0.001515</td>
</tr>
<tr>
<td>Floyd 优化堆排序</td>
<td>0.004723</td>
<td>0.004694</td>
<td>0.005258</td>
</tr>
<tr>
<td>基数排序</td>
<td>0.002475</td>
<td>0.002295</td>
<td>0.002025</td>
</tr>
</tbody>
</table>
</div>
<p>为了了解整型的情况，我又对 <code>(0, 1000000)</code> 的正整数排序进行测试，这次将基数排序替换为整型版本，并加入了计数排序：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数组长度</th>
<th>10000</th>
<th>100000</th>
<th>1000000</th>
</tr>
</thead>
<tbody>
<tr>
<td>std::sort</td>
<td>0.001190667</td>
<td>0.005622667</td>
<td>0.068292</td>
</tr>
<tr>
<td>qsort</td>
<td>0.002274667</td>
<td>0.009722333</td>
<td>0.104763</td>
</tr>
<tr>
<td>选择排序</td>
<td>0.046129</td>
<td>2.66948</td>
<td>308.974</td>
</tr>
<tr>
<td>插入排序</td>
<td>0.031989</td>
<td>2.98289</td>
<td>311.727</td>
</tr>
<tr>
<td>跳过有序部分的鸡尾酒排序</td>
<td>0.077564667</td>
<td>8.208996667</td>
<td>857.231</td>
</tr>
<tr>
<td>希尔排序</td>
<td>0.000599</td>
<td>0.00847</td>
<td>0.110247</td>
</tr>
<tr>
<td>自顶向下归并排序</td>
<td>0.000569667</td>
<td>0.007658667</td>
<td>0.095276</td>
</tr>
<tr>
<td>快速排序</td>
<td>0.000516333</td>
<td>0.006403333</td>
<td>0.071781</td>
</tr>
<tr>
<td>Floyd 优化堆排序</td>
<td>0.000665667</td>
<td>0.00898</td>
<td>0.131631</td>
</tr>
<tr>
<td>基数排序</td>
<td>0.001474</td>
<td>0.014975667</td>
<td>0.134972</td>
</tr>
<tr>
<td>计数排序</td>
<td>0.0004</td>
<td>0.002697667</td>
<td>0.062725</td>
</tr>
</tbody>
</table>
</div>
<p>由于 O2 优化等因素的影响，实际得到的结果与预想有些出入。<br>总之，尽管排序算法性能差距悬殊，可有时人和人之间的差别比这还大呢！</p>
<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>《算法（第 4 版）》P154
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a target="_blank" rel="noopener" href="http://blog.sciencenet.cn/blog-83029-468247.html">http://blog.sciencenet.cn/blog-83029-468247.html</a>
<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>《算法（第 4 版）》P208
<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1690708?from=article.detail.1394343">https://cloud.tencent.com/developer/article/1690708?from=article.detail.1394343</a>
<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45557225/article/details/105956950">https://blog.csdn.net/qq_45557225/article/details/105956950</a>
<a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/12/06/hackermath-int-divisibility/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">整数的可除性</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/09/25/touchpad-clevo-arch/">
                        <span class="hidden-mobile">神船 TX6 修复 ArchLinux 下触摸板问题</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js" ></script>



  <script  src="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js" ></script>



  <script defer src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://lib.baomitu.com/mathjax/3.2.0/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
