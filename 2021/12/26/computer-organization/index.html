

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/res/avatar.png">
  <link rel="icon" href="/images/res/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#90a4ae">
  <meta name="author" content="zhaozihanzzh">
  <meta name="keywords" content="">
  
    <meta name="description" content="计算机组成原理一、计算机系统概论1. 计算机的分类、发展电子计算机分哪两类？“电脑”指的是？其中&amp;#x2003;&amp;#x2003;&amp;#x2003;又可进一步分成&amp;#x2003;&amp;#x2003;&amp;#x2003;和&amp;#x2003;&amp;#x2003;&amp;#x2003;。计算机已经经历了五代发展。到目前为止，计算机中所有信息仍以二进制方式表示的理由是（由物理器件的性能决定）。现代计算机已经从以运算器为中心发展到">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机组成原理">
<meta property="og:url" content="https://zhaozihanzzh.github.io/2021/12/26/computer-organization/index.html">
<meta property="og:site_name" content="Blogs of mefailedcoder">
<meta property="og:description" content="计算机组成原理一、计算机系统概论1. 计算机的分类、发展电子计算机分哪两类？“电脑”指的是？其中&amp;#x2003;&amp;#x2003;&amp;#x2003;又可进一步分成&amp;#x2003;&amp;#x2003;&amp;#x2003;和&amp;#x2003;&amp;#x2003;&amp;#x2003;。计算机已经经历了五代发展。到目前为止，计算机中所有信息仍以二进制方式表示的理由是（由物理器件的性能决定）。现代计算机已经从以运算器为中心发展到">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-12-26T00:01:14.000Z">
<meta property="article:modified_time" content="2022-01-16T16:28:52.944Z">
<meta property="article:author" content="zhaozihanzzh">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>计算机组成原理 - Blogs of mefailedcoder</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"zhaozihanzzh.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#cfd8dc","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>mefailedcoder</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/images/res/default.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="计算机组成原理"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-12-26 08:01" pubdate>
          2021-12-26 08:01
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          27k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          226 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">计算机组成原理</h1>
            
              <p class="note note-info">
                
                  
                    Last updated on January 17, 2022 am
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="一、计算机系统概论"><a href="#一、计算机系统概论" class="headerlink" title="一、计算机系统概论"></a>一、计算机系统概论</h2><h3 id="1-计算机的分类、发展"><a href="#1-计算机的分类、发展" class="headerlink" title="1. 计算机的分类、发展"></a>1. 计算机的分类、发展</h3><p>电子计算机分哪两类？“电脑”指的是？其中<u>&#x2003;&#x2003;&#x2003;</u>又可进一步分成<u>&#x2003;&#x2003;&#x2003;</u>和<u>&#x2003;&#x2003;&#x2003;</u>。计算机已经经历了五代发展。到目前为止，计算机中所有信息仍以二进制方式表示的理由是（由物理器件的性能决定）。现代计算机已经从以运算器为中心发展到以存储器为中心。<br>冯·诺依曼计算机的主要特点是：（存按单使单）<br>  ▪ 存储程序方式，程序控制；<br>  ▪ 按地址访问，指令顺序执行；<br>  ▪ 单元定长的一维线性空间存储器；<br>  ▪ 使用低级机器语言，数据以二进制表示；<br>  ▪ 单处理机结构，以运算器为中心。<br>改进后的冯·诺依曼计算机使其从原来的以运算器为中心演变为以存储器为中心。从系统结构上讲，主要是通过各种并行处理手段提高计算机系统性能。<br>程序和指令存储器分离的结构叫哈佛体系结构。<br>指令流时间上在取指周期被取出，空间上由内存流向指令寄存器；数据流时间上在执行周期被取出，空间上由内存流向数据寄存器。</p>
<h3 id="2-性能指标"><a href="#2-性能指标" class="headerlink" title="2. 性能指标"></a>2. 性能指标</h3><p>处理机字长是指处理机运算器中一次能完成二进制数运算的位数，总线宽度一般指 CPU 中运算器与存储器之间进行互连的内部总线二进制位数，存储器带宽是指单位时间从存储器读出的二进制数信息量。主频是时钟周期的倒数。CPI 指<u>&#x2003;&#x2003;&#x2003;</u>，MIPS 指 <u>&#x2003;&#x2003;&#x2003;</u>，FLOPS 指 <u>&#x2003;&#x2003;&#x2003;</u>（科学运算常用）。</p>
<h3 id="3-计算机硬件"><a href="#3-计算机硬件" class="headerlink" title="3. 计算机硬件"></a>3. 计算机硬件</h3><p>冯诺依曼体系结构分为 <u>&#x2003;&#x2003;&#x2003;</u> 五部分，其中 <u>&#x2003;&#x2003;&#x2003;</u>构成了 CPU。<br>存储器分为 <u>&#x2003;&#x2003;&#x2003;</u> 两部分。主存储器包括 MAR（地址寄存器，存放访存地址）、MDR（数据寄存器，位数等于存储字长，等于一个存储单元中二进制代码位数。注意数据字长形容的对象是数据总线，是数据总线一次并行传送的位数，可以与 MDR 位数不等）、存储体、时序控制逻辑组成。地址寄存器（MAR）、数据寄存器（MDR）是存在于 CPU 中的，但并未集成到运算器与控制器之中。辅助存储器中的信息必须调入主存后才能被 CPU 访问。<br>CPU 和 <u>&#x2003;&#x2003;&#x2003;</u> 构成了主机，除主机外的其他硬件设备叫做 <u>&#x2003;&#x2003;&#x2003;</u>。<br>控制器由程序计数器（PC，位数得能实现一次对存储器中指令的访问，一般和 MAR 相同）、指令寄存器（IR，存放欲执行指令，对汇编程序员不可见）、控制单元（CU）组成。<br>运算器以 ALU 为核心，包含累加器（ACC）、乘商寄存器（MQ）、操作数寄存器（X）以及程序状态计数器（PSW）等若干寄存器。<br>从格式上看，指令可分成 <u>&#x2003;&#x2003;&#x2003;</u> 两部分。把指令和数据存放在同一存储器，按地址访问并顺序执行指令，形成冯诺依曼体系结构。冯诺依曼机最根本的特征即“存储程序”原理（将指令以代码的形式事先输入计算机主存储器，然后按其在主存储器中的首地址执行程序的第一条指令，以后按程序的规定顺序执行其他指令），基本工作方式是控制流驱动方式。将指令、数据分开存放，形成更加快速的哈佛结构。一个字节（B）由 8 位（bit）二进制组成，将一个字的二进制位数叫字长。取指周期中指令流流向控制器（PC-&gt;MAR-&gt;M-&gt;MDR-&gt;IR），执行周期中数据流流向运算器。<br>多个系统部件通过<u>&#x2003;&#x2003;&#x2003;</u>进行数据传送。</p>
<h3 id="4-计算机软件"><a href="#4-计算机软件" class="headerlink" title="4. 计算机软件"></a>4. 计算机软件</h3><p>计算机软件分为<u>&#x2003;&#x2003;&#x2003;</u>（诊断程序、练习程序、汇编程序、编译程序、解释程序、操作系统、数据库管理系统）和<u>&#x2003;&#x2003;&#x2003;</u>。（数据库管理系统不等于数据库系统，数据库系统甚至包括用户）编译程序与运行系统合称为<u>&#x2003;&#x2003;&#x2003;</u>。语言分为机器语言、汇编语言、高级语言三层。</p>
<h3 id="5-计算机系统"><a href="#5-计算机系统" class="headerlink" title="5. 计算机系统"></a>5. 计算机系统</h3><p>将程序固定在 ROM 中组成的部件称为固件。软件与硬件在逻辑上是等价的，完整计算机系统由硬件设备与软件系统组成。把计算机系统分为<u>&#x2003;&#x2003;&#x2003;</u>五级。<br>兼容性的对象是软件或硬件，不是软件和硬件之间。</p>
<p>注意错题：CPU 速度提高 50%，不是速度翻一倍。</p>
<h2 id="二、运算方法和运算器"><a href="#二、运算方法和运算器" class="headerlink" title="二、运算方法和运算器"></a>二、运算方法和运算器</h2><h3 id="1-数字表示格式"><a href="#1-数字表示格式" class="headerlink" title="1. 数字表示格式"></a>1. 数字表示格式</h3><p>约定最低位是第 0 位。<br>定点数常用于表示整数。<br>十进制数串在计算机内可以用字符串形式表示，也可以用压缩的十进制数串表示（BCD 码、ASCII 码的后四位）。<br>可以对真值使用原码表示法、反码表示法（正数不变，负数符号位不变，其余位取反）、补码表示法。同一数的补码和移码（+2^n-1）表示，符号位相反，其余相同。<br>浮点数的基数是指的指数（阶码）的底数，不管基数是多少，尾数、阶码本身还是二进制表示的。<br>浮点数的规格化表示：当尾数的值不为 0 时，尾数域的最高有效位为 1。引入规格化是为了<u>&#x2003;&#x2003;&#x2003;</u>。<br>IEEE754 浮点数格式：32 位浮点数第 31 位为符号位 S，23-30 位为阶码 E（8 位），0-22 位为尾数 M；64 位浮点数第 63 位为符号位 S，52-62 位为阶码E（exponent，11 位），0-51 位为尾数 M（mantissa）。尾数相当于采用原码表示。阶码采用移码表示，对于 32 位浮点数，其阶码要用真值加上 2^(8-1)-1=127 得到；对于 64 位，这个值是 2^(11-1)-1=1023。采用规格化表示时，由于尾数最高位一定为 1，因此规定不显式地保存这一位。对于 32 位浮点数，E = 255，M ≠ 0 时为 NaN（“错误 Error 拉满（不等于 0）”无定义），E = 255 且 M = 0 时表示无穷大（结合符号位），E = 0 且 M = 0 时为正零或负零，E = 0 且 M ≠ 0 时为非规格化数，此时 N=(-1)^S×(0.M)×2^-126，即尾数前面是 0，阶码取最小的正常阶码 (1-127=-126，我想是因为强行表示超大的数误差太大，不如表示小数)。<br>可以看出，不能正好表示时，浮点数的绝对值越大，其精度越低。</p>
<h3 id="2-汉字表示方法"><a href="#2-汉字表示方法" class="headerlink" title="2. 汉字表示方法"></a>2. 汉字表示方法</h3><p>汉字的输入编码：用西文标准键盘录入汉字的编码。区位码（十进制）是 94 * 94 二维数组的两个下标。国标码是区位码的十六进制 + 2020H。<br>汉字内码：国标码加上 8080H （把两字节的最高位置为 1 以便于和 ASCII 码的最高位为 0 区分）<br>汉字字模码：点阵显示用</p>
<h3 id="3-校验码"><a href="#3-校验码" class="headerlink" title="3. 校验码"></a>3. 校验码</h3><p>奇偶校验：增加一位使得整个编码中的 1 的个数为奇数个或偶数个。</p>
<h3 id="4-定点加法与减法"><a href="#4-定点加法与减法" class="headerlink" title="4. 定点加法与减法"></a>4. 定点加法与减法</h3><p>减法通过取反与最低位全加器进位为 1 来实现。判断是否发生溢出，方法一是采用双符号位（变形补码）：运算后符号位为<u>&#x2003;&#x2003;&#x2003;</u>时说明发生溢出，<u>&#x2003;&#x2003;&#x2003;</u>是正溢，<u>&#x2003;&#x2003;&#x2003;</u>是负溢；<u>&#x2003;&#x2003;&#x2003;</u>位是正确的符号。方法二是单符号位，通过<u>&#x2003;&#x2003;&#x2003;</u>判断。<br>构建加法器，有串行加法器和并行加法器。并行加法器又分为串行进位（行波进位）和并行进位（先行进位）。完全采用并行进位造成电路过于复杂，常采用分组并行进位，组内采用并行快速进位，组间可用串行进位（形成所谓“单级先行进位”），也可用并行快速进位（“多级先行进位”）。<br>由于每一级异或门延迟 3T，其余门延迟 T，n 位行波进位加法器（串行进位的并行加法器）的总延迟为 <u>&#x2003;&#x2003;&#x2003;</u>。</p>
<h3 id="5-定点乘法"><a href="#5-定点乘法" class="headerlink" title="5. 定点乘法"></a>5. 定点乘法</h3><p>通过斜向进位实现阵列乘法器。（先用 n^2 个与门得出 1 * 1 的乘积，再用 n(n-1) 个全加器）延迟为 <u>&#x2003;&#x2003;&#x2003;</u>。<br>带符号的阵列乘法器，需要算前求补、算后求补。<br>手工运算，正常列竖式即可。</p>
<h3 id="6-定点除法"><a href="#6-定点除法" class="headerlink" title="6. 定点除法"></a>6. 定点除法</h3><p>不够减时，采用恢复余数法或加减交替法（不恢复余数法）。<br>用 n^2 个可控加法减法单元（CAS）实现阵列除法器。<br>手工运算，要注意写成加法的竖式而不是除法的，让每一列的小数点对齐，“右移”不是直接空出前面的，而是采用算术右移。加减交替法运算，最后的余数为负数时需要恢复。</p>
<h3 id="7-定点运算器"><a href="#7-定点运算器" class="headerlink" title="7. 定点运算器"></a>7. 定点运算器</h3><p>根据总线所处的位置，将总线分为<u>&#x2003;&#x2003;&#x2003;</u>和<u>&#x2003;&#x2003;&#x2003;</u>，其中内部总线是<u>&#x2003;&#x2003;&#x2003;</u>，外部总线就是（前面介绍的）<u>&#x2003;&#x2003;&#x2003;</u>。<br>运算器大体有 <u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>三种结构形式。</p>
<h3 id="8-浮点加减运算"><a href="#8-浮点加减运算" class="headerlink" title="8. 浮点加减运算"></a>8. 浮点加减运算</h3><p>浮点加减运算大体分为<u>&#x2003;&#x2003;&#x2003;</u>四步。（也可分为五步）<br>对阶的原则是<u>&#x2003;&#x2003;&#x2003;</u>。浮点数加减是否溢出，关键是对阶后的阶码是否溢出，而不是尾数。运算时尾数如果发生正上溢（进位），要应进行向右规格化（“右规”，尾数进行算术右移）；阶码上溢一般看成<u>&#x2003;&#x2003;&#x2003;</u>，阶码下溢（注意和负上溢的区别）看成<u>&#x2003;&#x2003;&#x2003;</u>。<br>当且仅当浮点数在对阶或向右规格化时需要舍入，可以选择<u>&#x2003;&#x2003;&#x2003;</u>四种舍入处理方法。舍入不一定产生误差，如 11.00 向下舍入到 11.0。<br>对阶不会造成阶码上溢，但尾数舍入可能（1.1111…+1.1111… 右规后阶码加一）<br>注意，算术移位时双符号位只有低符号位需要参与移位；补码左移需要原符号位和原最高有效位相同。</p>
<h3 id="9-浮点乘除运算"><a href="#9-浮点乘除运算" class="headerlink" title="9. 浮点乘除运算"></a>9. 浮点乘除运算</h3><p>浮点乘除运算不存在对阶问题，有符号浮点乘除法运算分为<u>&#x2003;&#x2003;&#x2003;</u>六步。</p>
<h3 id="10-浮点运算流水线"><a href="#10-浮点运算流水线" class="headerlink" title="10. 浮点运算流水线"></a>10. 浮点运算流水线</h3><p>流水线能经济地实现时间并行性。把具有线性优先关系的流水线称为<u>&#x2003;&#x2003;&#x2003;</u>。<br>定义 k 级线性流水线的加速比为 <u>&#x2003;&#x2003;&#x2003;</u>，绘制其流水时空图。</p>
<p>错题：Booth 乘法，11.0011 右移是 11.10011；反码符号位不变；补码不恢复余数除法，异号相除时，够减商 0，不够减商 1；引入规格化是为了提高数据表示的精度；已知x= -0.1001，y=0.1101，试用原码加减交替除法求x/y=？写出计算机的运算过程及运算结果。注意！商是正的！</p>
<h2 id="三、存储系统"><a href="#三、存储系统" class="headerlink" title="三、存储系统"></a>三、存储系统</h2><h3 id="1-存储系统概述"><a href="#1-存储系统概述" class="headerlink" title="1. 存储系统概述"></a>1. 存储系统概述</h3><p>在现代计算机中，主存储器处于全机的中心位置。<br>构成多级存储系统的依据是<u>&#x2003;&#x2003;&#x2003;</u>（具体解释这一名词：<u>&#x2003;&#x2003;&#x2003;</u>）。内存储器（不包括寄存器）是指 CPU <u>&#x2003;&#x2003;&#x2003;</u>，分为<u>&#x2003;&#x2003;&#x2003;</u>和<u>&#x2003;&#x2003;&#x2003;</u>，后者又分为随机存取存储器（RAM）、只读存储器（ROM）。也就是说，CPU 访问主存可以不经过 cache。辅助存储器（外存储器）中的信息必须调入内存储器后才可以被 CPU 访问。操作系统保存在硬盘上时，内存储器必须采用 RAM+ROM（BIOS 等用于引导）。<br>cache - 主存 层次主要解决 CPU 速度与主存不匹配问题，主存 - 辅存主要解决存储系统容量问题。其中，cache / 主存 系统的效率为单次 cache 访问用时除以平均访问用时。cache 与主存的管理是完全借助硬件的，而主存与辅存的管理则借助<u>&#x2003;&#x2003;&#x2003;</u>。<br>按存取方式，可以把存储器分为随机存取存储器、顺序存取存储器、<u>&#x2003;&#x2003;&#x2003;</u>。磁盘是<u>&#x2003;&#x2003;&#x2003;</u>。<br>如果编址的最小单位是字存储单元，称为按字编址；如果编址的最小单位是字节存储单元，称为按字节编址。当存储字的字长高于 8 位（1 字节）时，称一个存储字内部的字节排列方式为端模式，大端模式是将存储字的最高有效字节（MSB）放入存储体的低地址端（“内存的开头”），小端（x86）则是将存储字的低有效字节（LSB）放入存储体的低地址端。（是根据谁在内存的低地址端，即谁更靠前的）</p>
<h3 id="2-技术指标"><a href="#2-技术指标" class="headerlink" title="2. 技术指标"></a>2. 技术指标</h3><p>存取时间是指<u>&#x2003;&#x2003;&#x2003;</u>，存储周期（存取周期）是指<u>&#x2003;&#x2003;&#x2003;</u>，存取周期 = 存取时间 + 恢复时间（eg. 破坏性读出）。<br>存储器带宽指单位时间（常指 1s）内存取的信息量，若系统总线宽度为 W 位，则存储器带宽为 W*1s/存取周期。<br>位扩展（扩展位数，一次并行读写更多位，数据线位数增加），字扩展（扩展字数，地址高位用来片选），字位扩展。</p>
<h3 id="3-静态随机存取存储器（SRAM）"><a href="#3-静态随机存取存储器（SRAM）" class="headerlink" title="3. 静态随机存取存储器（SRAM）"></a>3. 静态随机存取存储器（SRAM）</h3><p>高速缓冲存储器常用 SRAM 构成，不需要刷新；RAM 用 DRAM 构成，需要周期性地刷新。<br>SRAM 是触发器实现，相对 DRAM 成本高，功耗高，速度快，存储密度低。<br>为了写入可靠，写使能信号是最先结束的，其余如片选等可能要延长。</p>
<h3 id="4-动态随机存取存储器（DRAM）"><a href="#4-动态随机存取存储器（DRAM）" class="headerlink" title="4. 动态随机存取存储器（DRAM）"></a>4. 动态随机存取存储器（DRAM）</h3><p>由于 DRAM 容量大，为减少芯片引脚数量，将地址分为行、列两部分分时传送。<br>写使能在地址变化（信号不稳定）时必须是高电平（高电平无效）。<br>DRAM 破坏性读出，读出后要刷新。刷新以行为单位。此外，由于电容漏电，每隔一段时间必须刷新（称这个时间为刷新周期，通常取 2ms），可采用集中式刷新策略（刷新周期中拿出一段来专门用于刷新所有行，不响应读写请求，故存在访存死区时间，但读写时不受刷新影响，存取速度高）或分散式刷新策略（每次存取后拿出一段时间刷新一行，没有死区，但加长了系统的存取周期，降低了整机的速度；事实上刷新间隔是小于刷新周期的，造成浪费）或异步刷新（每隔 刷新周期/行数 这一时间刷新一行，避免 CPU 连续等待过长时间，且减小刷新次数）。若将刷新安排在不需要访问存储器的译码阶段，则既不会加长存取周期，又不会产生死区时间，称为“透明刷新”。<br>在传统异步 DRAM 上增加时钟信号，是同步 DRAM（SDRAM）最主要的改进。</p>
<h3 id="5-只读存储器"><a href="#5-只读存储器" class="headerlink" title="5. 只读存储器"></a>5. 只读存储器</h3><p>掩模ROM，一次性编程ROM（PROM），光可擦可编程只读存储器（EPROM），电可擦PROM（E²PROM），闪速存储器（Flash）</p>
<h3 id="6-并行存储器"><a href="#6-并行存储器" class="headerlink" title="6. 并行存储器"></a>6. 并行存储器</h3><p>为了提高 CPU 与主存之间的数据交换速率，可以在<u>&#x2003;&#x2003;&#x2003;</u>层次提高单个芯片的访问速度（突发传输、同步 DRAM），在<u>&#x2003;&#x2003;&#x2003;</u>层次采用多端口存储器、多体交叉存储器，在<u>&#x2003;&#x2003;&#x2003;</u>层次采用分层存储结构（增加 cache、采用虚拟存储器等）。<br>双端口存储器是<u>&#x2003;&#x2003;&#x2003;</u>并行技术的体现，具有两组相互独立的读写控制电路。当两个端口的地址不相同时，读写不冲突。当两个端口同时存取同一地址，且至少有一个端口进行写操作时，发生读写冲突，这时芯片判断逻辑会对一个端口置 BUSY 标志，暂时关闭此端口的读写。仲裁逻辑有<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>两种判断方式。<br>多模块交叉存储器（多体交叉存储器）是<u>&#x2003;&#x2003;&#x2003;</u>并行技术的体现。当寻址采用<u>&#x2003;&#x2003;&#x2003;</u>时，某一模块出现故障时其他模块可以正常工作，且易于通过增添模块来扩充存储器容量，但带宽有限；<u>&#x2003;&#x2003;&#x2003;</u>寻址将连续地址分配在相邻的不同模块内，提高了存储器带宽。为了实现流水线方式存取，假设模块存取一个字的存储周期为 T，总线传送周期为 τ，存储器的交叉模块数为 m，应当满足<u>&#x2003;&#x2003;&#x2003;</u>，称<u>&#x2003;&#x2003;&#x2003;</u>叫做交叉存取度。</p>
<h3 id="7-cache-存储器"><a href="#7-cache-存储器" class="headerlink" title="7. cache 存储器"></a>7. cache 存储器</h3><p>若 cache 在 CPU 外，则其控制逻辑常常与主存合在一起。<br>cache 与 CPU 间以<u>&#x2003;&#x2003;&#x2003;</u>为单位进行数据交换，但与主存之间以<u>&#x2003;&#x2003;&#x2003;</u>为单位进行数据交换。cache 的数据块大小称为行，主存的数据块大小称为块，行和块是大小<u>&#x2003;&#x2003;&#x2003;</u>的。一个 cache 行中可能包含若干字，因此地址最低几位常常是块内地址（字地址）。<br>当 CPU 读取内存一个字时，发出内存地址到 cache 和主存，如果字在 cache 中，称为 cache <u>&#x2003;&#x2003;&#x2003;</u>；若不在，称为 cache <u>&#x2003;&#x2003;&#x2003;</u>，此时有两种策略，既可以把字复制到 cache，之后再送给 CPU，也可以同时把字送给 CPU 和 cache。cache/主存 系统的平均访问时间就是平均每次访问内存的用时，而 cache/主存 系统的访问效率 e=<u>&#x2003;&#x2003;&#x2003;</u>。（前面已有这一空）<br>把主存地址映射到 cache 时，有<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>三种方式。全相联映射使用昂贵的相联存储器实现对标记的存储；命中率高、利用率高，但高速比较器电路难于设计实现，适合小容量 cache。直接映射截取地址中间的几位（因为最低位是块内地址）作为 cache 地址，成本低，变换地址快速，但命中率低，冲突频繁，且存在空置问题，适合大容量 cache。组相联映射中组内全相联，组间直接映射，将中间部分最<u>&#x2003;&#x2003;&#x2003;</u>（低/高）的几位作为组号（组号往往从 0 开始），高位作为标记用于比较。每组行数一般取值较小，称 <u>&#x2003;&#x2003;&#x2003;</u> 为 v 路组相联 cache。<br>直接映射 cache 遇到冲突，直接把原主存块换出；全相联映射与直接映射可以采用<u>&#x2003;&#x2003;&#x2003;</u>（使用最少的）、<u>&#x2003;&#x2003;&#x2003;</u>（没使用最多的）、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>四种替换算法。<br>为了与主存内容保持一致，可选用<u>&#x2003;&#x2003;&#x2003;</u>（写 cache 未命中时<u>&#x2003;&#x2003;&#x2003;</u>。显著减少写主存策略，存在数据不一致的隐患）、<u>&#x2003;&#x2003;&#x2003;</u>（写 cache 未命中有 WTWA(<u>&#x2003;&#x2003;&#x2003;</u>)、WTNWA(<u>&#x2003;&#x2003;&#x2003;</u>) 两选择，cache 中无须每行设置一个修改位和判断逻辑，但降低了性能）、<u>&#x2003;&#x2003;&#x2003;</u>（<u>&#x2003;&#x2003;&#x2003;</u>，以便维护系统全部 cache 的一致性）三种写操作策略。</p>
<h3 id="8-虚拟存储器"><a href="#8-虚拟存储器" class="headerlink" title="8. 虚拟存储器"></a>8. 虚拟存储器</h3><p>为了能在编制程序时独立编址，引入地址转换部件，将用户编制程序时使用的地址（编译程序生成）称为<u>&#x2003;&#x2003;&#x2003;</u>或<u>&#x2003;&#x2003;&#x2003;</u>，对应的存储空间称为<u>&#x2003;&#x2003;&#x2003;</u>或<u>&#x2003;&#x2003;&#x2003;</u>，将物理内存的访问地址称为<u>&#x2003;&#x2003;&#x2003;</u>或<u>&#x2003;&#x2003;&#x2003;</u>，其对应的存储空间称为<u>&#x2003;&#x2003;&#x2003;</u>或<u>&#x2003;&#x2003;&#x2003;</u>。称把虚地址变换为主存的物理地址这一过程为<u>&#x2003;&#x2003;&#x2003;</u>，称把虚地址变换为辅存的物理地址的过程为<u>&#x2003;&#x2003;&#x2003;</u>。虚存是个概念模型，不是实际的存储器。程序的虚地址空间可以远大于实地址空间（提高容量），也可以远小于实地址空间（缩短指令中地址长度）。<br>在三级存储体系中，cache-主存和主存-辅存这两个存储层次的共同点包括：①出发点相同：二者都是为了提高存储系统的性能价格比而构造的层次性存储体系，都力图使存储系统的性能接近高速存储器，而价格接近低速存储器；②原理相同：都是利用了程序运行时的局部性原理把最常用的信息块从相对慢速而大容量的存储器调入相对高速而小容量的存储器；不同点包括：①目的不同：cache 主要解决主存与 CPU 的速度差异问题；而虚存就性能价格比的提高而言主要是解决存储容量的问题（另外还包括存储管理、主存分配和存储保护等方面）；②数据通路不同：CPU 与 cache 和主存之间均有直接通路，cache 不命中时可直接访问主存，而虚存的辅存与 CPU 之间不存在直接的数据通路，当主存不命中时，只能通过调页解决，CPU 最终还是要访问主存；③透明性不同：cache 的管理完全由硬件完成，对系统程序与应用程序均透明，而虚存管理由软件（操作系统）和硬件共同完成，对系统程序不透明，对应用程序透明（段式和段页式管理对应用程序“半透明”）；④未命中时的损失不同：由于主存的存取时间是 cache 的存取时间的 5~10 倍，而辅存的存取时间通常是主存的存取时间的上千倍，故虚存未命中时系统的性能损失要远大于 cache 未命中时的损失。</p>
<h3 id="9-页式虚拟存储器"><a href="#9-页式虚拟存储器" class="headerlink" title="9. 页式虚拟存储器"></a>9. 页式虚拟存储器</h3><p>页式虚拟存储器中，把虚地址空间分成等长的<u>&#x2003;&#x2003;&#x2003;</u>，相应地把虚地址分成<u>&#x2003;&#x2003;&#x2003;</u>（高字段）和<u>&#x2003;&#x2003;&#x2003;</u>（低字段），把实地址空间分成同样长度的<u>&#x2003;&#x2003;&#x2003;</u>，相应地把实存地址分为<u>&#x2003;&#x2003;&#x2003;</u>（高字段）和<u>&#x2003;&#x2003;&#x2003;</u>（低字段）。大多数系统中每个进程对应一个<u>&#x2003;&#x2003;&#x2003;</u>，把逻辑页号作为偏移地址（即数组下标）时，每个逻辑页在这个表中都有一个记录<u>&#x2003;&#x2003;&#x2003;</u>与指示该逻辑页是否已调入主存的有效位。因此，地址变换时用逻辑页号作为页表数组下标找到相应物理页号，把物理页号作为地址高字段与页内地址拼接即可得到完整的<u>&#x2003;&#x2003;&#x2003;</u>。（物理页号并不对应“页表”）<br>称以上虚地址到主存物理地址的变换表为<u>&#x2003;&#x2003;&#x2003;</u>，而虚地址到辅存物理地址的变换表为<u>&#x2003;&#x2003;&#x2003;</u>。（页表往往指内页表）<br>由于页表在主存中访问页表要多访问一次主存，可以通过把页表中最活跃的部分放入专用于页表缓存的高速存储部件<u>&#x2003;&#x2003;&#x2003;</u>（通常由相联存储器实现）中来缓解这一问题。称转换后援缓冲器为 <u>&#x2003;&#x2003;&#x2003;</u>，而主存中的<u>&#x2003;&#x2003;&#x2003;</u>为<u>&#x2003;&#x2003;&#x2003;</u>。<br>操作系统把某一页移到辅存上时，必须从 cache 中删除该页的内容，同时修改页表和 TLB。<br>最坏的情况下，访问存储器会在<u>&#x2003;&#x2003;&#x2003;</u>产生三次缺失。<br>页式虚拟存储器使得主存利用率高，变址速度快，易于辅存管理，但程序模块化性能差。</p>
<h3 id="10-段式虚拟存储器"><a href="#10-段式虚拟存储器" class="headerlink" title="10. 段式虚拟存储器"></a>10. 段式虚拟存储器</h3><p>段是按照<u>&#x2003;&#x2003;&#x2003;</u>划分并且长度可以<u>&#x2003;&#x2003;&#x2003;</u>的区域，段式虚拟存储系统中虚地址由<u>&#x2003;&#x2003;&#x2003;</u>和<u>&#x2003;&#x2003;&#x2003;</u>（偏移量）组成，虚地址到主存地址的变换通过<u>&#x2003;&#x2003;&#x2003;</u>实现。每个程序设置一个段表，用段号作为段表的“数组下标”访问段表，段表每一个表项对应一个段，一个段至少包括<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>三个字段。<br>地址变换时，对于每个虚地址，先以<u>&#x2003;&#x2003;&#x2003;</u>为索引访问段表的表项，若<u>&#x2003;&#x2003;&#x2003;</u>，则将虚地址的<u>&#x2003;&#x2003;&#x2003;</u>与表项的<u>&#x2003;&#x2003;&#x2003;</u>相比较，如果不越界，那么<u>&#x2003;&#x2003;&#x2003;</u> 求得主存地址；如果缺段，从辅存中调入，并修改段表。（相加不等于拼接，段式虚拟存储器中没有地址的拼接）<br>段式虚拟存储器段的逻辑独立，便于程序、数据共享、动态链接，但易产生碎片，使得主存利用率低，辅存管理难度大，变址慢。</p>
<h3 id="11-段页式虚拟存储器"><a href="#11-段页式虚拟存储器" class="headerlink" title="11. 段页式虚拟存储器"></a>11. 段页式虚拟存储器</h3><p>每个程序先分<u>&#x2003;&#x2003;&#x2003;</u>，再分<u>&#x2003;&#x2003;&#x2003;</u>；虚地址由<u>&#x2003;&#x2003;&#x2003;</u> 组成。多任务系统中还有<u>&#x2003;&#x2003;&#x2003;</u>，寻址时用它为下标访问<u>&#x2003;&#x2003;&#x2003;</u>并与虚地址中的段号相加，得到访问段表时的偏移量。<br>兼顾了段页式的优点，但地址变换要多次查表，速度慢。<br>从辅存调页到主存时，如果主存已满，需要进行页面替换，可以采用<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>等算法。</p>
<p>错题：位扩展 32 片 256K×1 位的 SRAM，构成 256K×32 位；当 CPU 与存储器连接时，可以把较多的地址线、数据线合成一条粗线；主存的第 24 块实际上是 23（从 0 开始）。判断：访问存储器的请求是由 CPU 发出的-&gt;错误，访问存储器的请求可以由 CPU 或 I/O 发出</p>
<h2 id="四、指令系统"><a href="#四、指令系统" class="headerlink" title="四、指令系统"></a>四、指令系统</h2><h3 id="1-指令系统概述"><a href="#1-指令系统概述" class="headerlink" title="1. 指令系统概述"></a>1. 指令系统概述</h3><p><u>&#x2003;&#x2003;&#x2003;</u>简称指令，一台计算机中所有指令的集合称为<u>&#x2003;&#x2003;&#x2003;</u>（指令集），按指令系统功能构造硬件组织。复杂指令系统计算机（CISC）指令系统庞大，产生浪费，根据 8/2 原则提出了精简指令系统计算机（RISC）。RISC 有三要素，即<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>。<br>使用式子表示时，→右边实际上是比左边少一对括号的，即→右侧默认是地址，但→左侧是数据，需要(地址)。</p>
<h3 id="2-指令格式"><a href="#2-指令格式" class="headerlink" title="2. 指令格式"></a>2. 指令格式</h3><p>表示一条指令的机器字叫 <u>&#x2003;&#x2003;&#x2003;</u>，简称指令，通常用<u>&#x2003;&#x2003;&#x2003;</u>（OP）和<u>&#x2003;&#x2003;&#x2003;</u>（A）表示。根据指令中的操作数地址个数，将指令称为几操作数指令或几地址指令。三地址指令功能是<u>&#x2003;&#x2003;&#x2003;</u>，适用于<u>&#x2003;&#x2003;&#x2003;</u>的场合，为了加快速度常把地址指定为运算器中通用寄存器的地址，但指令码较长。二地址指令的指令功能是<u>&#x2003;&#x2003;&#x2003;</u>，长度适中，使用方便。其中，按操作数的来源又分为<u>&#x2003;&#x2003;&#x2003;</u>型、<u>&#x2003;&#x2003;&#x2003;</u>型、<u>&#x2003;&#x2003;&#x2003;</u>型指令。一地址指令另一个操作数地址是隐含的，对于只需一个地址的指令而言其指令字长度短。零地址指令不需要操作数。<br>由于机器字长通常与主存单元的位数一致，指令字长度等于机器字长度的指令称为单字长指令，指令字长度等于半个机器字长度的指令称为半字长指令，指令字长度等于两个机器字长度的指令称为双字长指令。指令系统中指令字长度相等时，称为等长指令字结构；否则称为变长指令字结构。为了确保指令字长度尽可能统一，可以采用<u>&#x2003;&#x2003;&#x2003;</u>技术（类似前缀码），如预留出 1111 来扩展操作码的长度。可以对频率较高的指令采用较短的操作码。</p>
<h3 id="3-操作数的寻址方式"><a href="#3-操作数的寻址方式" class="headerlink" title="3. 操作数的寻址方式"></a>3. 操作数的寻址方式</h3><p>形成操作数有效地址的方式称为操作数的寻址方式。在冯·诺依曼体系结构中，指令的寻址和数据的寻址是交替进行的。<br>称指令中给出的地址为<u>&#x2003;&#x2003;&#x2003;</u>（A），操作数的实际访存地址为<u>&#x2003;&#x2003;&#x2003;</u>（EA）。由于指令中的地址码往往由形式地址和寻址方式特征位等组合而成，因此指令中的地址码通常不是操作数的有效地址。形成操作数有效地址的方法称为操作数的寻址方式。<br>立即寻址中，指令中的地址字段给出的不是操作数地址，而是操作数本身，直观速度快，但不便于更改，不够通用灵活，且操作数的寻址范围受限制。<br>直接寻址中，指令中的地址字段给出操作数的内存地址 A，此时形式地址就是有效地址，因此又称形式地址为直接地址。这样速度快，但寻址范围<u>&#x2003;&#x2003;&#x2003;</u>，且不易修改。有效地址 E=D，操作数 S=(E)=(D)。<br>间接寻址中地址字段给出的是操作数地址的地址，指令格式为 <u>&#x2003;&#x2003;&#x2003;</u> | <u>&#x2003;&#x2003;&#x2003;</u> | <u>&#x2003;&#x2003;&#x2003;</u>。若寻址特征位 I = 0，D 为<u>&#x2003;&#x2003;&#x2003;</u>；I=1，D 为<u>&#x2003;&#x2003;&#x2003;</u>。可以多次间址，一次间址 E=<u>&#x2003;&#x2003;&#x2003;</u>，S=<u>&#x2003;&#x2003;&#x2003;</u>；二次间址 E=<u>&#x2003;&#x2003;&#x2003;</u>，S=<u>&#x2003;&#x2003;&#x2003;</u>。这样扩大了寻址范围，但访存次数多，效率较低，且可能出现无穷间址（死循环）。一般更常用寄存器间址实现扩大寻址范围。<br>寄存器寻址指令中的地址字段给出的是<u>&#x2003;&#x2003;&#x2003;</u>，这样压缩了指令字的长度，有效解决指令码长度短与内存容量大的矛盾，同时加快指令执行速度，能扩大寻址范围，但寄存器有限。此时 S=(R<sub>n</sub>)。<br>寄存器间接寻址与寄存器寻址相似，但此时寄存器中存放的不是<u>&#x2003;&#x2003;&#x2003;</u>，而是<u>&#x2003;&#x2003;&#x2003;</u>。真正的操作数在内存中，E=(R<sub>n</sub>)。<br>偏移寻址是直接寻址与寄存器间接寻址的结合，地址 E=A+(R)，指令中的两个地址字段至少有一个是显式的。具体来说，相对寻址中 EA=<u>&#x2003;&#x2003;&#x2003;</u>，称 A 为相对偏移量，A 可以正可以负；基址寻址中 EA=<u>&#x2003;&#x2003;&#x2003;</u>，在不更改指令内容的情况下，基址是<u>&#x2003;&#x2003;&#x2003;</u>（变/不变）的，而偏移量是<u>&#x2003;&#x2003;&#x2003;</u>（变/不变）的，偏移量的位数相对较短；变址寻址 EA=<u>&#x2003;&#x2003;&#x2003;</u>，形式地址不变，可以用同一条指令来访问数组。变址寻址可以实现程序块的规律变化，而基址寻址可以扩大寻址范围。<br>段寻址实质是一种基址寻址，将段寄存器的基地址<u>&#x2003;&#x2003;&#x2003;</u>后与偏移量<u>&#x2003;&#x2003;&#x2003;</u>得到有效地址。<br>堆栈寻址，将寄存器 Ri 内容压入堆栈时， PUSH Ri 具体执行 <u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u> 操作；POP Ri 具体执行<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>操作。注意堆栈的生长方向与主存地址的关系。<br>隐含寻址的操作数地址是隐含的，如单地址指令。有利于缩短指令字长。</p>
<h3 id="4-指令的寻址方式"><a href="#4-指令的寻址方式" class="headerlink" title="4. 指令的寻址方式"></a>4. 指令的寻址方式</h3><p>指令的寻址方式有顺序寻址（PC 值 + 1）、跳跃寻址。</p>
<p>给出一条指令格式，试分析指令格式的特点：①几字长几地址指令②操作码可指定多少指令③二地址的话是 RR 型、RS 型、SS 型。<br>如果问寻址方式的话，需要根据寻址特征位算出可以有几种寻址方式。（2^n）</p>
<p>错题：注意指令中的地址码划分为几段和几地址指令没有直接关系，偏移寻址也可能是单地址指令（用两个地址字段描述一个地址），最终要看操作数的个数。<br>没有提“寄存器寻址，寄存器间址寻址”这种的，不考虑寻址特征位。<br>题 4-9 CPU 中有 16 个 32 位通用寄存器，设计一种能容纳 64 种操作的指令系统。如果采用通用寄存器作基址寄存器，则 RS 型指令的最大存储空间是多少？</p>
<h2 id="五、中央处理器"><a href="#五、中央处理器" class="headerlink" title="五、中央处理器"></a>五、中央处理器</h2><h3 id="1-CPU-的功能和组成"><a href="#1-CPU-的功能和组成" class="headerlink" title="1. CPU 的功能和组成"></a>1. CPU 的功能和组成</h3><p>用来使计算机在程序被装入内存储器后能自动地完成取指令、执行指令的任务的部件叫做中央处理器。其基本功能有<u>&#x2003;&#x2003;&#x2003;</u>（保证机器按顺序执行程序）、<u>&#x2003;&#x2003;&#x2003;</u>（产生、管理指令的操作信号）、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>（CPU 的根本任务）。<br>CPU 的核心部件为<u>&#x2003;&#x2003;&#x2003;</u>（又分为<u>&#x2003;&#x2003;&#x2003;</u>部件、<u>&#x2003;&#x2003;&#x2003;</u>部件、<u>&#x2003;&#x2003;&#x2003;</u>部件，具体主要有五个部件，实现了取指令、分析指令、执行指令、中断处理和响应特殊请求）、<u>&#x2003;&#x2003;&#x2003;</u>（ALU、通用寄存器、DR、PSWR，接受 <u>&#x2003;&#x2003;&#x2003;</u> 的命令），基本部分由<u>&#x2003;&#x2003;&#x2003;</u>三大部分组成。<br>CPU 中至少有六类寄存器：<u>&#x2003;&#x2003;&#x2003;</u>（暂时存放由内存读出的一条指令或一个数据字，或向内存存入一条指令或一个数据字时将其暂时放在这里；可以作为 CPU 与内存、外部设备之间信息传送的中转站，或补偿 CPU 和内存、外围设备之间在操作速度上的差别，还可在单累加器结构运算器中作操作数寄存器），<u>&#x2003;&#x2003;&#x2003;</u>（保存<u>&#x2003;&#x2003;&#x2003;</u>的一条指令）、<u>&#x2003;&#x2003;&#x2003;</u>（名字上看起来不像个寄存器）、<u>&#x2003;&#x2003;&#x2003;</u>（保持当前 CPU 访问的地址信息，保证读写操作进行时地址稳定）、<u>&#x2003;&#x2003;&#x2003;</u>（为 ALU 提供工作区，有多个时要进行编址并使通用寄存器堆结构）、<u>&#x2003;&#x2003;&#x2003;</u>（由各种状态条件标志拼凑而成）。<br>把许多寄存器之间传送信息的通路称为数据通路。<u>&#x2003;&#x2003;&#x2003;</u>负责产生取指令和执行指令所需的各种操作控制信号，从而建立数据通路，这种部件可分为时序逻辑型（<u>&#x2003;&#x2003;&#x2003;</u> ）和存储逻辑型（<u>&#x2003;&#x2003;&#x2003;</u>）实现的。时序产生器负责对其产生的操作信号进行时间上的控制，负责控制时钟脉冲的送出与封锁，从而实现启停。<br>当取出一条指令时，指令从 cache 送到 <u>&#x2003;&#x2003;&#x2003;</u>，接下来指令的操作码送入<u>&#x2003;&#x2003;&#x2003;</u>，再送入<u>&#x2003;&#x2003;&#x2003;</u>。</p>
<h3 id="2-指令周期"><a href="#2-指令周期" class="headerlink" title="2. 指令周期"></a>2. 指令周期</h3><p><u>&#x2003;&#x2003;&#x2003;</u>是取出一条指令并执行这条指令的时间，常常用若干<u>&#x2003;&#x2003;&#x2003;</u>周期（又称<u>&#x2003;&#x2003;&#x2003;</u>周期，通常用<u>&#x2003;&#x2003;&#x2003;</u>规定，也就是说一条指令的取出阶段需要一个<u>&#x2003;&#x2003;&#x2003;</u>周期）数表示。一个 CPU 周期又包含若干<u>&#x2003;&#x2003;&#x2003;</u>（又称 T 周期或节拍脉冲，是<u>&#x2003;&#x2003;&#x2003;</u>）。CPU 执行一个微操作命令（即控制信号）的最小时间单位就是时钟周期。<br>单周期 CPU 在一个时钟周期内完成从取指到执行的所有操作，因此指令执行时间以最长时间的指令为准，效率低；多周期 CPU 在一个时钟周期完成一个阶段的指令执行，不同指令所用周期数可以<u>&#x2003;&#x2003;&#x2003;</u>。<br>机器周期可以是定长或变化的。<br>可以用方框图语言来表示一条指令的指令周期。一个方框花费一个<u>&#x2003;&#x2003;&#x2003;</u>，表示数据通路的操作或某种控制操作，菱形符号不占用单独的 CPU 周期，而是在时间上依附于它前面的一个方框，表示某种判别或测试。末尾的折线符号表示指令执行完后转入<u>&#x2003;&#x2003;&#x2003;</u>。</p>
<h3 id="3-时序产生器和控制方式"><a href="#3-时序产生器和控制方式" class="headerlink" title="3. 时序产生器和控制方式"></a>3. 时序产生器和控制方式</h3><p>计算机时序采用多级时序体制。时序体制最基本的体制是电位-脉冲制，硬布线控制器中时序信号往往采用主状态周期-节拍电位-节拍脉冲三级体制，微程序控制器中时序信号比较简单，一般采用节拍电位-节拍脉冲两级体制，节拍电位表示一个 CPU 周期的时间。<br>控制器的控制方式常用的有同步控制方式、异步控制方式、联合控制方式三种，同步控制方式中每条指令所需的机器周期数和时钟周期数都是事先固定的（不同的指令可以有统一的机器周期，也可以对某些时间紧张的操作延长机器周期，或采用中央控制与局部控制结合：大部分指令固定机器周期，少数复杂指令采用另外的时序进行计时），异步控制方式中每个操作控制信号需要占用多少时间就占用多少时间，联合控制方式是前两种方式的结合（可以把大部分操作序列安排在固定的机器周期中，对某些时间难以确定的操作则以执行部件的“回答”信号作为结束标志）。</p>
<h3 id="4-微程序控制器"><a href="#4-微程序控制器" class="headerlink" title="4. 微程序控制器"></a>4. 微程序控制器</h3><p>控制部件通过控制线向执行部件发出的控制命令叫做<u>&#x2003;&#x2003;&#x2003;</u>（如下令打开某个门），执行部件收到后进行的动作叫<u>&#x2003;&#x2003;&#x2003;</u>。受限于数据通路的结构，在同时或同一个<u>&#x2003;&#x2003;&#x2003;</u>周期中可以并行执行的微操作叫做<u>&#x2003;&#x2003;&#x2003;</u> ，而不能在同时或同一个<u>&#x2003;&#x2003;&#x2003;</u>内并行执行的微操作叫<u>&#x2003;&#x2003;&#x2003;</u> 。<br>一组实现一定操作功能的微命令的组合构成一条<u>&#x2003;&#x2003;&#x2003;</u>。微指令可以用二进制代码来表示，微指令分为<u>&#x2003;&#x2003;&#x2003;</u>字段（用于产生微命令）和<u>&#x2003;&#x2003;&#x2003;</u>字段（用于确定下一条<u>&#x2003;&#x2003;&#x2003;</u>的地址，分为<u>&#x2003;&#x2003;&#x2003;</u>字段（确定是否修改下址字段）和<u>&#x2003;&#x2003;&#x2003;</u>字段）。实现机器指令功能的微指令序列叫做<u>&#x2003;&#x2003;&#x2003;</u>。微程序设计技术是用软件方法来设计硬件的一门技术。<br>为了保证机器控制信号的同步，可以把微指令周期时间设计得和 CPU 周期时间相等。一条机器指令对应一个微程序。<br>微程序控制器主要由<u>&#x2003;&#x2003;&#x2003;</u>（只读，存放实现全部指令系统的微程序）、<u>&#x2003;&#x2003;&#x2003;</u> （其中<u>&#x2003;&#x2003;&#x2003;</u>存放将要访问的下一条微指令的地址，<u>&#x2003;&#x2003;&#x2003;</u> 保存微指令的操作控制字段和判别测试字段，不保存下址字段是因为下址字段已经进了微地址寄存器）、<u>&#x2003;&#x2003;&#x2003;</u> （条件转移时修改微地址）三大部分组成。<br>设计微指令结构时，应该追求①有利于缩短微指令字长度；②有利于减小控制存储器的容量；③有利于提高微程序的执行速度；④有利于对微指令的修改；⑤有利于提高微程序设计的灵活性。<br>微命令编码是微指令中的操作控制字段采用的表示方法，通常有<u>&#x2003;&#x2003;&#x2003;</u>（操作控制字段中的每一位代表一个微命令，简单直观，但微指令字较长，使得控制存储器容量较大）、<u>&#x2003;&#x2003;&#x2003;</u> （我想其名字应该是来自译码的逆操作。又叫字段编译法，把 <u>&#x2003;&#x2003;&#x2003;</u> 的微命令信号组成一个小组（字段），通过小组（字段）译码器对每一个微命令信号进行译码，译码输出作为操作控制信号，使得微指令字大大缩短，稍稍减慢微程序的执行速度。注意译码输出要留出一组来表示都没有以上信号，如某一相斥性微命令组包括 8 个微命令，则需要 log<sub>2</sub>8 + 1 = 4 位）、<u>&#x2003;&#x2003;&#x2003;</u>（前两种混合使用）三种方法表示。<br>为了确定下一条微指令的地址，微地址的形成方法中可以采用计数器方式（顺序执行的微指令序列安排在控存的连续单元内，非顺序执行时通过转移方式转去指定地址；顺序控制字段较短，但多路并行转移功能弱）、多路转移方式（在出现分支时按顺序控制字段的判别测试标志和当前的状态条件来选择一个微地址，灵活性好，但需要用组合逻辑方法设计）。<br>微指令的格式分为水平型微指令和垂直型微指令两大类。水平型微指令即为一次定义并执行多个并行操作微命令的微指令，垂直型微指令在微指令中有微操作码字段，由微操作码规定微指令的功能，一条微指令中只有一到两个微操作命令，故同一条机器指令对应的微程序要比水平型微指令中的长。水平型微指令并行操作能力强，效率高，但用户难以掌握；垂直型微指令要经过译码，影响速度，但易于掌握。<br>静态微程序设计中，一条机器指令对应的微程序是不改变的；动态微程序设计采用 EEPROM 作为控制存储器，可以改变微程序。<br>微程序设计步骤：①根据数据通路，写出每条指令的执行过程，画出微程序流程图；②写出每条微指令所发出的微操作控制信号；③按照微指令格式，编写每条微指令的代码；④对照指令的执行流程图，分配微指令的地址；⑤将写好的微指令按分配好的微地址装入控制存储器。</p>
<p>错题：要多加一个机器周期，实现M-&gt;DR，这一步的微命令是 R/W拔=R。最后记得公操作。</p>
<h3 id="5-硬布线控制器"><a href="#5-硬布线控制器" class="headerlink" title="5. 硬布线控制器"></a>5. 硬布线控制器</h3><p>把控制部件看作产生专门固定时序控制信号的逻辑电路，形成的由门电路和触发器构成的复杂树形逻辑网络称为硬布线控制器。其速度高于微程序控制器，但设计、调试非常复杂。 </p>
<h3 id="6-流水-CPU"><a href="#6-流水-CPU" class="headerlink" title="6. 流水 CPU"></a>6. 流水 CPU</h3><p>广义上的并行性既包括同时性，又包括并发性。计算机的并行处理技术主要有时间并行（流水部件，多体交叉存储器）、空间并行（多处理器，双端口存储器）、时间并行加空间并行（超标量流水）。<br>CPU 按流水方式，组织为指令部件、指令队列、执行部件。为了使存储器的存取时间与流水线的其他各过程段的速度匹配，可采用多体交叉存储器；为了解决执行段速度匹配的问题，可以把执行部件分为定点执行部件、浮点执行部件两个可以并行执行的部分，在浮点执行部件中的浮点加法部件和浮点乘除部件并行，同时浮点运算部件以流水线方式工作。<br>只有一条指令流水线的计算机称为标量流水计算机，具有两条以上指令流水线的计算机称为超标量流水计算机。<br>流水线加速比与前面浮点运算相似，为<u>&#x2003;&#x2003;&#x2003;</u>。<br>在流水线运行中，相邻指令间存在某些关系导致不能同时被流水操作，发生断流的现象称为<u>&#x2003;&#x2003;&#x2003;</u>，分为<u>&#x2003;&#x2003;&#x2003;</u>（指令重叠执行时不同指令争用同一功能部件。如取指和取操作数争用内存时，可以将取指操作推迟一周期，或采用双端口存储器，或把数据和指令分开存放）、<u>&#x2003;&#x2003;&#x2003;</u> （必须等前一条指令执行完毕才能执行后一条指令，可以推迟下一指令，或采用数据旁路（内部向前）技术直接把结果传送给下一指令）和 <u>&#x2003;&#x2003;&#x2003;</u> （由转移指令、中断引起，可以采用 <u>&#x2003;&#x2003;&#x2003;</u> （让紧跟在转移指令之后，已进入流水线的少数几条指令 <u>&#x2003;&#x2003;&#x2003;</u> ，而不是排空流水线，这样如果这些指令是与转移指令结果无关的有用指令，则有效地利用了时间）、<u>&#x2003;&#x2003;&#x2003;</u> （依据指令过去的行为，硬件实现选择出现概率高的分支））。其中局部性相关有<u>&#x2003;&#x2003;&#x2003;</u>，全局性相关有<u>&#x2003;&#x2003;&#x2003;</u>。<br>数据相关又可以分为 RAW、WAW、WAR，在相邻的两条指令中，可能同时存在多种数据相关，如 M(B)-&gt;R<sub>6</sub>，(R<sub>6</sub>)*(R<sub>7</sub>)-&gt;R<sub>6</sub>。</p>
<h2 id="六、总线"><a href="#六、总线" class="headerlink" title="六、总线"></a>六、总线</h2><h3 id="1-总线的基本概念"><a href="#1-总线的基本概念" class="headerlink" title="1. 总线的基本概念"></a>1. 总线的基本概念</h3><p><u>&#x2003;&#x2003;&#x2003;</u>是构成计算机系统的互联机构，是多个系统功能部件之间进行数据传送的公共通路。单处理器系统中的总线大致分为<u>&#x2003;&#x2003;&#x2003;</u>（片内总线，CPU 内部连接各寄存器和运算器等部件之间的总线）、<u>&#x2003;&#x2003;&#x2003;</u>（CPU 同其他高速部件如存储器、通道等互联的总线）、<u>&#x2003;&#x2003;&#x2003;</u>（低速 I/O 设备之间互联的总线）。<br>总线的特性有<u>&#x2003;&#x2003;&#x2003;</u>（总线的物理连接方式，包括根数、插头、引脚排列等）、<u>&#x2003;&#x2003;&#x2003;</u>（描述每根线的功能）、<u>&#x2003;&#x2003;&#x2003;</u>（信号传递方向、电平范围）、<u>&#x2003;&#x2003;&#x2003;</u>（时序关系）。<br>系统总线的<u>&#x2003;&#x2003;&#x2003;</u>使得各厂家不同方法实现的相同功能部件可互换使用。总线带宽指总线本身能达到的最高传输速率，单位 MB/s。</p>
<h3 id="2-总线的连接方式"><a href="#2-总线的连接方式" class="headerlink" title="2. 总线的连接方式"></a>2. 总线的连接方式</h3><p>通过适配器（简称接口）可以实现高速 CPU 与低速外设之间工作速度上的匹配和同步，并完成计算机和外设之间的所有数据传送和控制。根据连接方式不同，单机系统中总线结构分为<u>&#x2003;&#x2003;&#x2003;</u>（每个设备被指定一个总线地址，外围设备译码器按地址字段决定是否响应；扩展性强，利于扩展成多 CPU 系统，但高速设备和低速设备挂同一总线，且只能一对一对工作，速度受限制，且所有设备与总线接口必须统一）、<u>&#x2003;&#x2003;&#x2003;</u>（高中低速设备连接到不同总线上同时工作，提高效率和吞吐量，且处理器结构的变化不影响高速总线）。<br><u>&#x2003;&#x2003;&#x2003;</u>是具有缓冲、转换、控制功能的逻辑电路。</p>
<h3 id="3-早期总线内部结构"><a href="#3-早期总线内部结构" class="headerlink" title="3. 早期总线内部结构"></a>3. 早期总线内部结构</h3><p>早期总线是处理器芯片引脚的延伸，由按功能分为<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>三类的信号线组成，其不足之处有<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>。</p>
<h3 id="4-当代流行的总线结构"><a href="#4-当代流行的总线结构" class="headerlink" title="4. 当代流行的总线结构"></a>4. 当代流行的总线结构</h3><p>当代总线追求与结构、CPU、技术无关的标准。总线控制器完成多个总线请求者之间的协调与仲裁。整个总线分为<u>&#x2003;&#x2003;&#x2003;</u>（由地址线、数据线、控制线组成）、<u>&#x2003;&#x2003;&#x2003;</u>（包括总线请求线和总线授权线）、<u>&#x2003;&#x2003;&#x2003;</u>（包括中断请求线、中断认可线）、<u>&#x2003;&#x2003;&#x2003;</u>（时钟信号线、电源线、地线等）四部分。</p>
<h3 id="5-总线的信息传送"><a href="#5-总线的信息传送" class="headerlink" title="5. 总线的信息传送"></a>5. 总线的信息传送</h3><p>串行传送通常以第一个脉冲信号表示数码的<u>&#x2003;&#x2003;&#x2003;</u>，每次一位，最后一个脉冲信号表示数码的<u>&#x2003;&#x2003;&#x2003;</u>。可以指定位时间来指定一个二进制位占用的时间长度。串行传送只需一根传输线，成本低，适合远距离传送，但速度慢。<br>并行传送同时传送多位，速度快，但需要更多传输线，适用于近距离部件。出于速度和效率考虑，系统总线上传送的信息必须采用并行传送方式。</p>
<h3 id="6-总线仲裁"><a href="#6-总线仲裁" class="headerlink" title="6. 总线仲裁"></a>6. 总线仲裁</h3><p>主方（主设备）可以启动一个总线周期，而从方只能响应主方的请求，为了解决多个主设备同时竞争总线控制权的问题，必须有总线仲裁部件，按总线仲裁电路的位置不同，仲裁方式分为<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>两类。<br>集中式仲裁由中央仲裁器对主方的总线请求信号进行裁决，并送出总线授权信号，可采用<u>&#x2003;&#x2003;&#x2003;</u>（总线授权信号串行地在 I/O 接口间传送，直到到达的接口有总线请求；<u>&#x2003;&#x2003;&#x2003;</u>的设备有最高优先级；所需传输线少，便于更改扩充，但对电路故障很敏感，且优先级低的设备可能长期不能使用总线）、<u>&#x2003;&#x2003;&#x2003;</u>（请求总线的设备发送自己的地址，若地址与计数器计数值一致时即获得总线使用权，优先次序可根据计数器的起点来变动（固定优先级、循环优先级），但线数较多）、<u>&#x2003;&#x2003;&#x2003;</u>（响应速度快，不需要一个一个地查询，且优先级灵活，但控制线数目多）三种方式实现，当代总线普遍采用独立请求方式。总线仲裁器又称总线控制器。<br>分布式总裁不需要集中的总线仲裁器，而是每个潜在的主方有仲裁器，请求总线时把仲裁号发送到仲裁总线上后把总线上的号与自己的相比，如果大于自己的，那么请求不予响应。</p>
<h3 id="7-总线的定时"><a href="#7-总线的定时" class="headerlink" title="7. 总线的定时"></a>7. 总线的定时</h3><p>总线上信息传送大致可分为请求总线、总线仲裁、寻址、信息传送、状态返回五个阶段。为了同步主方、从方的操作，需要制定定时协定。<u>&#x2003;&#x2003;&#x2003;</u>中总线中包含时钟信号线，事件出现在总线上的时间由总线时钟信号决定，大多数事件只占据单一时钟周期。这种方式传输频率较高，但必须按慢的模块来设计公共时钟，各模块存取时间相差很大时会大大损失效率。<u>&#x2003;&#x2003;&#x2003;</u>中后一事件出现在总线上的时刻取决于前一事件的出现时刻，不需要统一的公共时钟信号，建立在应答式或互锁机制之上，总线周期长度可变，但更加复杂。</p>
<h3 id="8-总线的数据传送模式"><a href="#8-总线的数据传送模式" class="headerlink" title="8. 总线的数据传送模式"></a>8. 总线的数据传送模式</h3><p>常见的有读、写操作，块传送操作，写后读、读修改写操作，广播、广集操作。</p>
<h3 id="9-PCI-总线"><a href="#9-PCI-总线" class="headerlink" title="9. PCI 总线"></a>9. PCI 总线</h3><p>典型的多总线结构中有<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>三种桥，分别连接<u>&#x2003;&#x2003;&#x2003;</u>总线与<u>&#x2003;&#x2003;&#x2003;</u>总线、<u>&#x2003;&#x2003;&#x2003;</u>总线与<u>&#x2003;&#x2003;&#x2003;</u>总线、<u>&#x2003;&#x2003;&#x2003;</u>总线与<u>&#x2003;&#x2003;&#x2003;</u>总线。HOST 桥又称北桥，HOST 总线是连接北桥和 CPU 之间的数据通路，连接内存控制器、cache 等。PCI 总线是与处理器无关的高速外围总线，是至关重要的层间总线，采用<u>&#x2003;&#x2003;&#x2003;</u>总线定时协定、<u>&#x2003;&#x2003;&#x2003;</u>仲裁策略，基本传输机制是猝发式数据传送机制。<u>&#x2003;&#x2003;&#x2003;</u>是 PCI 总线控制器。<br>读操作时，桥可早于上层总线进行预读；写操作时，桥可以把上层写周期缓存下来进行延迟写。</p>
<p>错题：计算总线带宽时没有使用 MB/s。</p>
<h2 id="七、外存与-I-O-设备"><a href="#七、外存与-I-O-设备" class="headerlink" title="七、外存与 I/O 设备"></a>七、外存与 I/O 设备</h2><h3 id="1-外围设备概述"><a href="#1-外围设备概述" class="headerlink" title="1. 外围设备概述"></a>1. 外围设备概述</h3><p>一般来说，外围设备由<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>组成（可以以磁盘为例记忆），外围设备可以分为<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>。</p>
<h3 id="2-磁盘存储设备"><a href="#2-磁盘存储设备" class="headerlink" title="2. 磁盘存储设备"></a>2. 磁盘存储设备</h3><p>磁盘存储器、磁带存储器均属于磁表面存储器，容量大，位价格低，记录介质可重复使用，断电后可保存信息（“永久性存储器”），一般为顺序存取存储器，但存取速度较慢，机械结构复杂，对工作环境要求高。<br>温彻斯特磁盘机（温盘）是可移动磁头固定盘片的磁盘机，高速旋转的气垫将磁头平稳浮起，防尘性能好，可靠性高，对使用环境要求不高，是最有代表性的硬磁盘存储器。<br>把磁盘片表面称为<u>&#x2003;&#x2003;&#x2003;</u>（最上面盘的上表面和最底下盘的下表面不算，其余两面都是），每个记录面上都有一个磁头，所有记录面上的磁头固定在步进电机上，记录面上一系列同心圆称为<u>&#x2003;&#x2003;&#x2003;</u>（最外面一个称为 <u>&#x2003;&#x2003;&#x2003;</u>），每个磁道又分为若干<u>&#x2003;&#x2003;&#x2003;</u>（虽然外面弧长更长，但仍然按最里面的算），每个区存放相同数量的字或字节。称<u>&#x2003;&#x2003;&#x2003;</u>为磁盘的柱面。磁盘可编址为<u>&#x2003;&#x2003;&#x2003;</u> 。<br>磁盘存储器的存储密度分为道密度、位密度、面密度。道密度是<u>&#x2003;&#x2003;&#x2003;</u>，单位为道/英寸；位密度是磁盘<u>&#x2003;&#x2003;&#x2003;</u>，单位是位/英寸；面密度是<u>&#x2003;&#x2003;&#x2003;</u>，单位为位/英寸²。磁盘存储器的存储容量是其能存储的字节总数，分为非格式化容量（磁表面可以利用的磁化单元总数，注意不同道可以存储的字节数按内圈磁道周长×位密度得出）、格式化容量（计算机系统中按特定格式记录所能存储的容量）。<br>磁盘的寻址时间是<u>&#x2003;&#x2003;&#x2003;</u>，包括<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>，这两个时间往往是变化的，因此常用其平均值表示，平均寻道时间是<u>&#x2003;&#x2003;&#x2003;</u>，平均等待时间是<u>&#x2003;&#x2003;&#x2003;</u>。磁盘的存取时间是从读写命令发出开始到第一笔数据读写所用的时间，包括寻道时间、等待时间、内务操作时间（一般很短，计算时可忽略不计）。故平均存取时间近似等于<u>&#x2003;&#x2003;&#x2003;</u>。总的平均读写时间在平均存取时间上还加上传输时间，即随着盘片的转动把要传送的字节写入花的时间。<br>如果某文件长度超过了一个磁道的容量，应将其记录在同一个<u>&#x2003;&#x2003;&#x2003;</u>，因为不需要重新找道。<br>数据传输率指磁盘存储器在单位时间内向主机传送数据的字节数。外部数据传输率指<u>&#x2003;&#x2003;&#x2003;</u>。内部数据传输率指<u>&#x2003;&#x2003;&#x2003;</u>。</p>
<h3 id="3-显示设备"><a href="#3-显示设备" class="headerlink" title="3. 显示设备"></a>3. 显示设备</h3><p>分辨率指显示器能表示的像素个数，<u>&#x2003;&#x2003;&#x2003;</u>指黑白显示器中所显示的像素点的亮暗差别，或彩色显示器表示的颜色的不同，如用 8 位表示一个像素，则有 256 级灰度。为了人眼能看到稳定的图像显示，CRT 显示器必须使电子束不断地重复扫描整个屏幕，这一过程称为<u>&#x2003;&#x2003;&#x2003;</u>。按人的视觉生理，刷新频率大于<u>&#x2003;&#x2003;&#x2003;</u>时才不会感到闪烁；一般采用电视的标准，即<u>&#x2003;&#x2003;&#x2003;</u>。把一帧图像存储在<u>&#x2003;&#x2003;&#x2003;</u>（视频存储器或显存）中来提供刷新图像的信号，其存储容量由分辨率与灰度级共同决定。<br>显示字符的方法以<u>&#x2003;&#x2003;&#x2003;</u>为基础。将点阵存入由 ROM 构成的字符发生器中（二进制 0 为空白，1 为填充；二进制高位填入存储器一个字的高位，低位填入低位），构成点阵表示。</p>
<p>错题：计算盘组容量时直接拿总的磁道数目乘了位密度。</p>
<h2 id="八、输入输出系统"><a href="#八、输入输出系统" class="headerlink" title="八、输入输出系统"></a>八、输入输出系统</h2><h3 id="1-CPU-与外设之间的信息交换方式"><a href="#1-CPU-与外设之间的信息交换方式" class="headerlink" title="1. CPU 与外设之间的信息交换方式"></a>1. CPU 与外设之间的信息交换方式</h3><p>为了保证高速的主机和不同速度的外设之间的高效和可靠的交互，CPU 必须通过 I/O 接口与外设连接，因此 CPU 的输入输出操作实际上分 I/O 接口与外设间的数据传送，以及 CPU 与 I/O 接口之间的数据传送。为了与 CPU 交互信息的方便，在接口内部一般要设置一些能被 CPU 直接访问的寄存器，称为端口。端口通常有统一编址方式（和内存单元联合在一起编址，不需要专门的 I/O 指令组）、I/O 独立编址方式（内存地址和 I/O 设备地址分开，用专门的 I/O 指令组访问 I/O 设备）。<br>根据外设工作速度的不同，I/O 接口与外设之间数据传送有无条件传送方式（机械开关、发光二极管等速度极慢或简单的外围设备）、应答方式（异步传送方式）（慢速或中速的外围设备，如键盘；如双线握手方式，设置一信号线让发方指示数据是否有效，另一信号线指示收方是否已取走数据）、同步传送方式（高速的外围设备）。<br>CPU 管理外围设备（CPU 对接口）可以采用<u>&#x2003;&#x2003;&#x2003;</u>（只有当接口与外设之间采用无条件传送方式时才能采用）、<u>&#x2003;&#x2003;&#x2003;</u>（CPU 希望接收一个字时，通过接口对目标设备的状态进行查询，如果未准备好，则不断地查询并等待，直到目标设备准备好；CPU 发送数据时类似，不过外设先通过接口发出请求输出信号，CPU 再查询。软硬件结构简单，但 CPU 被外设独占，效率低下，适用于连接低速外设或 CPU 任务不繁忙时）、<u>&#x2003;&#x2003;&#x2003;</u> （外围设备主动通知 CPU 自己准备好了，CPU 暂停现行程序，转向<u>&#x2003;&#x2003;&#x2003;</u>，处理完后返回原来的任务；节省了 CPU 时间，适用于随机出现的服务请求，适合于计算机工作量十分饱满而对 I/O 的实时性要求又较高的系统；但软硬件复杂，服务开销时间大）、<u>&#x2003;&#x2003;&#x2003;</u> （<u>&#x2003;&#x2003;&#x2003;</u>从 CPU 那里接管对总线的控制，数据交换不经过 CPU，直接在内存和外围设备之间进行；传输速度高，但与中断相比需要更多的硬件，适用于内存和高速外围设备之间大批数据交换的场合）、<u>&#x2003;&#x2003;&#x2003;</u>（CPU 将部分权力下放给通道，常用于服务器；高性能处理器配置专门的输入输出处理器（IOP）；与 DMA 相仿，大大提高 CPU 工作效率，但耗费更多硬件，适用于数据传输率高的设备）。<br>综上所述，外围设备的输入/输出方式中，主要由程序实现的有<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>，主要由硬件实现的有<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>。</p>
<h3 id="2-程序查询方式"><a href="#2-程序查询方式" class="headerlink" title="2. 程序查询方式"></a>2. 程序查询方式</h3><p>程序查询方式的接口是最简单的，包括设备选择电路（实际上是设备地址的译码器）、数据缓冲寄存器、设备状态标志。程序查询时，先向 I/O 设备发出命令字，请求进行数据交换，再从 I/O 接口读入状态字，如果没有就绪，就继续重复前面的步骤，直至设备准备好后 CPU 从 I/O 接口的数据缓冲寄存器中输入或输出数据并将接口中的状态标志复位。</p>
<h3 id="3-程序中断方式"><a href="#3-程序中断方式" class="headerlink" title="3. 程序中断方式"></a>3. 程序中断方式</h3><p>中断是一种程序随时切换的方式，分为内中断（机器内部原因导致出错引起的中断，也叫异常）、外中断（外部设备请求服务）。中断的典型应用包括实现 CPU 与外界进行信息交换的握手联络（在速度较慢的外围设备准备自己的数据时 CPU 执行主程序，实现并行工作）、故障处理（硬件故障如掉电、校验错、运算出错，软件故障如溢出、地址越界、非法指令）、实时调度、程序调度（操作系统进行多任务调度的手段）、软中断（程序自愿中断，和子程序调用功能相似）。<br>响应中断需要满足：一条指令执行完毕，转入公操作、中断开放（CPU 内“中断屏蔽”触发器为 0）、外设向 CPU 发出中断请求信号（外设“中断请求”触发器为 1，接口“中断允许”触发器为 1）。<br>当满足响应中断的条件时，CPU 发出中断响应信号并关闭中断（“中断屏蔽”触发器置 1），进入中断响应周期，接着获取中断源对应的中断服务程序入口地址：可以采用<u>&#x2003;&#x2003;&#x2003;</u>方式和<u>&#x2003;&#x2003;&#x2003;</u>方式。在向量中断方式中，中断向量是<u>&#x2003;&#x2003;&#x2003;</u>（有的系统还包括中断服务程序开始执行时的 PSW 初始值），将中断向量保存在<u>&#x2003;&#x2003;&#x2003;</u>，中断向量地址指<u>&#x2003;&#x2003;&#x2003;</u>；当 CPU 识别出某中断源时，硬件直接产生与之对应的<u>&#x2003;&#x2003;&#x2003;</u>并送入 CPU。中断向量方式的优点是中断处理程序可以放在内存任意可放的位置，且便于修改，但需要<u>&#x2003;&#x2003;&#x2003;</u>次访问内存。在查询中断方式中，所有中断服务程序安排一个公共的中断服务程序，在中断响应时由公共的中断服务程序查询中断源，并跳转到相应的中断服务程序人口；利于更灵活地调整优先级。<br>单级中断系统是中断结构中最基本的形式，所有中断源属于同一级，当响应某一中断请求时，<u>&#x2003;&#x2003;&#x2003;</u>（允许/不允许）其他中断源打断中断服务程序，此时中断服务程序分为<u>&#x2003;&#x2003;&#x2003;</u>步骤。（中断周期由硬件实现，响应中断、关中断是在中断服务程序中看不见的，称为“中断处理的隐操作”）<br>多级中断系统中中断源按中断事件轻重缓急分成若干级别，其中在一维多级中断中每一级中断中只有一个中断源，在二维多级中断中每一级中断中有多个中断源。多级中断之间可以实现中断嵌套，但同一级内不同中断源的中断不能嵌套。n 级中断中有 n 个中断屏蔽触发器，总称为中断屏蔽寄存器，是多级中断中重要的程序现场，在响应中断时要把中断屏蔽寄存器中的内容保存起来并设置新的中断屏蔽状态，在某一级中断被响应时要置“1”（关）本级和优先权低于本级的中断屏蔽触发器，清“0”（开放）优先权高于本级的中断屏蔽触发器。和单级中断相似，多级中断中也使用中断堆栈保存现场信息。</p>
<h3 id="4-DMA-方式"><a href="#4-DMA-方式" class="headerlink" title="4. DMA 方式"></a>4. DMA 方式</h3><p>DMA 方式中<u>&#x2003;&#x2003;&#x2003;</u>从 CPU 接管对<u>&#x2003;&#x2003;&#x2003;</u>的控制，使得数据交换不经过 CPU，但数据传送前的准备工作、传送后的处理工作均由 CPU 程序完成。DMA 方式速度快，CPU 效率高，适用于高速外设与内存交换信息，但功能单一，硬件复杂；可用于磁带、磁盘、光盘等外存储设备接口、网络通信接口、动态存储器刷新、高速数据采集接口。<br>根据每次 DMA 请求时 DMA 控制器将占用多少个总线周期，将 DMA 传送分为<u>&#x2003;&#x2003;&#x2003;</u>（停止 CPU 访存；控制简单，适用于数据传输率高的设备连续传送，但由于外设传送两个数据之间间隔大于内存存储周期，在 DMA 控制器访问内存阶段内存效能不能充分发挥）、<u>&#x2003;&#x2003;&#x2003;</u>（DMA 传送数据时若 CPU 不需要访存，则挪用一两个周期无影响；若 CPU 需要访存，此时<u>&#x2003;&#x2003;&#x2003;</u>优先；较好地发挥内存和 CPU 的性能，但每次 DMA 传送都伴随申请总线控制权、建立总线控制权、归还总线控制权的过程，时间较长，适用于 I/O 设备读写周期大于内存存储周期的情况）、<u>&#x2003;&#x2003;&#x2003;</u>（CPU 周期大于主存存储周期时，把 CPU 周期分为两个分周期，一个专供 DMA 访问主存，一个专供 CPU 访问，提高了 DMA 效率，但 CPU 需要连续访存时需要等待双倍时间，不利于 CPU 效率提高，且外设工作周期是主存工作周期的数十倍，分配给 DMA 访问内存的周期大部分用不上，造成浪费）。<br>当 I/O 设备准备好发送接收数据时，发出 DMA 请求，DMA 控制器向 CPU 发出总线使用权请求，CPU 响应该请求后与总线脱离，DMA 控制器接管总线，发送出内存地址，开始数据交换，每传送一个字都修改发送的内存地址和 DMA 控制器中的字计数器，直至结束。DMA 操作结束后，DMA 控制器向 CPU 发送中断，CPU 进行校验传入的数据、检查是否出错等工作。<br>DMA 与程序中断相比，程序中断实际上是 CPU 的程序切换，而 DMA 则由 DMA 控制器进行数据交换，CPU 让出存储周期；程序中断可完成复杂操作如处理异常事件，而 DMA 只能实现简单的数据加工；程序中断开销大，DMA 以硬件换 CPU 时间；DMA 和程序中断的响应时间不同，CPU 对中断的响应是在执行完一条指令之后，而对 DMA 的响应可以在指令执行过程中的任何两个存储周期之间（因为 DMA 中 CPU 只需要一个存取周期就可以实现 I/O 和主存的通信，所以在一个机器周期结束就可以；但是中断方式需要存储程序断点，所以只能在一个指令的结束才能响应<br>）；DMA 的优先级高于一般的程序中断。</p>
<p>错题：一次中断处理过程中，最多可有几次关中断和开中断，它们分别是基于什么目的？<br>答：各两次<br>第一次关中断：保证在保存断点和现场的一段时间内，CPU不能响应其他的中断<br>第一次开中断：允许中断嵌套，可以响应优先级更高的中断请求<br>第二次关中断：确保在恢复现场的过程中不响应其他的中断。<br>第二次开中断：现场恢复结束后开中断便于响应新的中断请求。</p>
<p>部分参考了王道考研《计算机组成原理》。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" class="category-chain-item">计算机组成原理</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>计算机组成原理</div>
      <div>https://zhaozihanzzh.github.io/2021/12/26/computer-organization/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>zhaozihanzzh</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>December 26, 2021</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/01/16/hackermath-rsa/" title="RSA 论文翻译：一种实现数字签名和公钥密码系统的方法">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">RSA 论文翻译：一种实现数字签名和公钥密码系统的方法</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/12/15/hackermath-modernalgebraecc/" title="群、环、域、椭圆曲线">
                        <span class="hidden-mobile">群、环、域、椭圆曲线</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
      <div class="col-lg-7 mx-auto nopadding-x-md">
        <div class="container custom mx-auto">
          <p>感谢您的阅读，支付宝 App 搜索 841423265 或扫描下方二维码可领取实体店通用红包，每天可领取一次。</p><details> <summary>展开二维码</summary> <img src="https://zhaozihanzzh.github.io/images/res/redenvelope.jpg" srcset="/img/loading.gif" lazyload/> </details>
        </div>
      </div>
    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
