<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2022/07/31/computer-networks/"/>
    <url>/2022/07/31/computer-networks/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="一、计算机网络体系结构"><a href="#一、计算机网络体系结构" class="headerlink" title="一、计算机网络体系结构"></a>一、计算机网络体系结构</h2><h3 id="1-计算机网络定义"><a href="#1-计算机网络定义" class="headerlink" title="1. 计算机网络定义"></a>1. 计算机网络定义</h3><p>一组通过<u>&#x2003;&#x2003;&#x2003;</u>相互连接的<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>。完整的计算机网络由硬件、软件、协议三大部分组成。协议是计算机网络的核心。</p><h3 id="2-计算机网络分类"><a href="#2-计算机网络分类" class="headerlink" title="2. 计算机网络分类"></a>2. 计算机网络分类</h3><p>按传输技术分为<u>&#x2003;&#x2003;&#x2003;</u>链路和<u>&#x2003;&#x2003;&#x2003;</u>链路；按网络尺度可以分为<u>&#x2003;&#x2003;&#x2003;</u>（如蓝牙）、<u>&#x2003;&#x2003;&#x2003;</u>（一般在一座建筑物内或附近；用于公司时成为企业网络）、<u>&#x2003;&#x2003;&#x2003;</u>（例如基于有线电视网的）、<u>&#x2003;&#x2003;&#x2003;</u>（范围很大）。其中俗称<u>&#x2003;&#x2003;&#x2003;</u>的 IEEE 802.3 是最常见的有线<u>&#x2003;&#x2003;&#x2003;</u>。一组相互连接的网络称为互联网络，将两个或多个网络连接起来并提供必要转换的机器的硬件和软件方面的总称叫<u>&#x2003;&#x2003;&#x2003;</u>；按网络的拓扑结构分为<u>&#x2003;&#x2003;&#x2003;</u>（节省线路，对故障敏感、重负载时效率低）、<u>&#x2003;&#x2003;&#x2003;</u>（便于集中控制，成本高，中央设备故障敏感）、<u>&#x2003;&#x2003;&#x2003;</u>（最典型例子是<u>&#x2003;&#x2003;&#x2003;</u>，信号单向传输）、<u>&#x2003;&#x2003;&#x2003;</u>（可靠性高，控制复杂、成本高）；按交换技术分为<u>&#x2003;&#x2003;&#x2003;</u>（数据直接传送，时延小，但利用率低）、<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>（也称<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>网络）（可以实现不同链路间不同传输速率的转换，资源开销<u>&#x2003;&#x2003;&#x2003;</u>，缓冲区难以管理）、<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>（也称<u>&#x2003;&#x2003;&#x2003;</u>网络，其缓冲易于管理，现在的主流网络基本都可视为这一网络）（王道P3）。</p><h3 id="3-参考模型"><a href="#3-参考模型" class="headerlink" title="3. 参考模型"></a>3. 参考模型</h3><p>网络软件：为了降低网络设计的复杂性，绝大多数网络组织成一个层次栈或分级栈，每一层向上一层提供服务，相邻层次之间的是<u>&#x2003;&#x2003;&#x2003;</u>，不同机器上构成相应层次的实体称为<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>。P22 下层可以向上层提供面向连接的或无连接的服务。<br>参考模型：OSI参考模型又称为ISO的开放系统互连参考模型，自底向上分别有<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>七层；底四层协议数据单元（PDU）分别为<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>（太硬了，包你断），物理层传输原始比特，数据链路层需要让原始的传输设施变成一条没有漏检传输错误的线路，网络层的关键问题是路由；传输层把上一层的数据分割成较小单元，确保其正确地发送。TCP/IP 参考模型以最主要的两个协议命名，分为<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>。</p><h3 id="4-Internet-标准领域有影响力的组织"><a href="#4-Internet-标准领域有影响力的组织" class="headerlink" title="4. Internet 标准领域有影响力的组织"></a>4. Internet 标准领域有影响力的组织</h3><p>建立 ARPANET 时成立的非正式委员会 -&gt; Internet 活动委员会（其交流过程通过一系列技术报告实现，称“请求注释” RFC） -&gt; 重组为 Internet 研究任务组（IRTF）和 Internet 工程任务组（IETF）。RFC 要上升为因特网的正式标准需经过<u>&#x2003;&#x2003;&#x2003;</u>-&gt;<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>（从这个阶段开始正式成为 RFC 文档）-&gt;<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>-&gt;<u>&#x2003;&#x2003;&#x2003;</u>。基本思想 -&gt; RFC -&gt; 可正常工作实现，严格测试 -&gt; Internet 标准。万维网联盟（W3C）则负责制定 Web 标准。国际标准化组织（ISO）（提出 OSI）、国际电信联盟（ITU）下属的 ITU-T、国际电气电子工程师协会（IEEE）（提出 802）都是相关的网络标准。（王道P5）<br>度量单位：1kbps = 1000 bit/s，1Mbps=10^6 bit/s，但 1KB = 2^10B。</p><h2 id="二、物理层"><a href="#二、物理层" class="headerlink" title="二、物理层"></a>二、物理层</h2><p>物理层在网络设备之间提供透明的比特流传输。</p><h3 id="1-数据通信理论基础"><a href="#1-数据通信理论基础" class="headerlink" title="1. 数据通信理论基础"></a>1. 数据通信理论基础</h3><p>码元是指用一个固定时长（码元宽度）的信号波形（数字脉冲）表示一位 k 进制数字。<br>可以双向同时使用的链路称为全双工链路，可以双向使用但一次只能使用一个方向的链路称为半双工链路，只能单向传输的链路是单工链路。<br>一般情况下，在 0 到 f<sub>c</sub> 的频率范围内，振幅在传输过程中不会衰减，f<sub>c</sub> 为 <u>&#x2003;&#x2003;&#x2003;</u>，这段在传输过程中振幅不会明显减弱的频率的宽度就称为<u>&#x2003;&#x2003;&#x2003;</u>，其本质是传输信道的物理特性。“带宽在 3MHz 到 4MHz 之间” -&gt; 带宽为<u>&#x2003;&#x2003;</u>MHz。（P71）<br>模拟带宽（物理带宽）单位为<u>&#x2003;&#x2003;&#x2003;</u>，指的是<u>&#x2003;&#x2003;&#x2003;</u>；数字带宽单位为<u>&#x2003;&#x2003;&#x2003;</u>，指的是<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>。<u>&#x2003;&#x2003;&#x2003;</u>指的是单位时间内数字通信系统传输的码元的个数，单位是<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>。（王道P32）<br>奈奎斯特定理：经过物理带宽为 B Hz 的低通滤波器后，只需进行每秒 <u>&#x2003;&#x2003;&#x2003;</u> 次采样，就可以完全重构信号。如果信号包括 V 个离散等级，最大传输速率为<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>。（P73）当一次采样 16bit 时，信号的离散等级为？<br>噪声分贝值计算公式？<br>香农定理：带宽为 B Hz、噪声比为 S/N 的有噪声信道，最大数据速率为<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>。（为了记住公式：极端情况下，可达到 0）</p><h3 id="2-传输介质"><a href="#2-传输介质" class="headerlink" title="2. 传输介质"></a>2. 传输介质</h3><p>磁介质：磁带、磁盘手动传送（P74）<br>双绞线：最常用的古老传输介质（电话系统），由两根相互绝缘的铜线牢牢地缠绕在一起构成。<u>&#x2003;&#x2003;&#x2003;</u>用于连接异种设备，<u>&#x2003;&#x2003;&#x2003;</u>用于连接同种设备。其带宽取决于铜线的粗细和传输距离，距离太远时对于模拟信号需要使用放大器，对于数字信号需要中继器。5 类双绞线单位长度缠绕更紧，串扰更少，可用于 100Mbps、1Gbps 以太局域网。到 6 类线为止，所有的双绞线都是<u>&#x2003;&#x2003;&#x2003;</u>双绞线（UTP），价格较低廉；7 类线有屏蔽层。（P75）<br>同轴电缆（coax）：分为 50Ω 和 75Ω，抗干扰性更好，广泛应用于有线电视和城域网。<br>光纤：利用光导纤维传递光脉冲（全反射），由<u>&#x2003;&#x2003;&#x2003;</u>和<u>&#x2003;&#x2003;&#x2003;</u>组成，其中<u>&#x2003;&#x2003;&#x2003;</u>传播单一光线，直径<u>&#x2003;&#x2003;</u>，成本<u>&#x2003;&#x2003;</u>，带宽<u>&#x2003;&#x2003;&#x2003;</u>，适合<u>&#x2003;&#x2003;&#x2003;</u>距离传输；多模光纤适合<u>&#x2003;&#x2003;&#x2003;</u>距离传输。光纤容量<u>&#x2003;&#x2003;</u>，损耗<u>&#x2003;&#x2003;</u>，抗电磁干扰能力<u>&#x2003;&#x2003;&#x2003;</u>，保密性<u>&#x2003;&#x2003;&#x2003;</u>，重量<u>&#x2003;&#x2003;&#x2003;</u>。（王道P54）多根光纤包在护套中可以形成光缆。<br>光纤 VS 铜线：光纤的带宽高、衰减低；光纤受电磁干扰小；不易被腐蚀。但光纤易折断，光纤接口成本高。</p><h3 id="3-物理层接口"><a href="#3-物理层接口" class="headerlink" title="3. 物理层接口"></a>3. 物理层接口</h3><p>四个重要特性为<u>&#x2003;&#x2003;&#x2003;</u>（接线器形状）、<u>&#x2003;&#x2003;&#x2003;</u>（某条线上的电压范围）、<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>（某一电平的意义）、<u>&#x2003;&#x2003;&#x2003;</u>（事件顺序）。（没有“物理特性”！）</p><h3 id="4-数字调制"><a href="#4-数字调制" class="headerlink" title="4. 数字调制"></a>4. 数字调制</h3><p>把数据从数字变为模拟信号称为<u>&#x2003;&#x2003;&#x2003;</u>，把模拟信号变回数字信号称为<u>&#x2003;&#x2003;&#x2003;</u>，把数据从数字变为数字信号称为<u>&#x2003;&#x2003;&#x2003;</u>。一般将从 0 到某个最大频率的信号称为 <u>&#x2003;&#x2003;&#x2003;</u> 信号，将被搬移并占用某个更大频率范围的信号称为<u>&#x2003;&#x2003;&#x2003;</u>，无线连接一般采用通带传输，而基带传输常用于有线。<br>数字数据编码为数字信号：<br>归零编码：每个周期的后半段均为 0。<br>不归零（NRZ）编码简单，但很少使用，曼彻斯特编码（起源于与时钟异或）需要两倍带宽（以太网使用）（从低电平到高电平是<u>&#x2003;&#x2003;</u>，从高电平到低电平是<u>&#x2003;&#x2003;&#x2003;</u>），不归零逆转（NRZI）对于 1 <u>&#x2003;&#x2003;&#x2003;</u>，对于 0 <u>&#x2003;&#x2003;&#x2003;</u>。USB 使用 NRZI。4B/5B 编码是什么？什么是双极编码（AMI）？<br>数字数据编码为模拟信号：通带传输可以使用<u>&#x2003;&#x2003;&#x2003;</u>键控、<u>&#x2003;&#x2003;&#x2003;</u>键控、<u>&#x2003;&#x2003;&#x2003;</u>键控，结合振幅和相位时可以形成<u>&#x2003;&#x2003;&#x2003;</u>（QAM），可以作出星座图，当波特率为 B，采用 m 个相位，n 种振幅时数据传输速率=<u>&#x2003;&#x2003;&#x2003;</u>。为了让少量突发噪音引发的比特出错的位数尽可能小，提出了<u>&#x2003;&#x2003;&#x2003;</u>码，其相邻符号比特只有一个比特不同。<br>模拟数据编码为数字信号：PCM（<u>&#x2003;&#x2003;&#x2003;</u>，用于电话系统）P119</p><h3 id="5-多路复用"><a href="#5-多路复用" class="headerlink" title="5. 多路复用"></a>5. 多路复用</h3><p>复用模式使得多个信号共享传输线路，<u>&#x2003;&#x2003;&#x2003;</u>将频谱分成多个频段，每个用户占有一个频段，如 AM 调幅，<u>&#x2003;&#x2003;&#x2003;</u>使信道之间完全隔离（正交频分复用是没有的）；<u>&#x2003;&#x2003;&#x2003;</u>中每个用户周期性地获得整个带宽一个非常短的时间，可能需要保护时间间隔；<u>&#x2003;&#x2003;&#x2003;</u>是扩展频谱通信的一种形式，用户只能发送分配给它的<u>&#x2003;&#x2003;&#x2003;</u>（1）或其<u>&#x2003;&#x2003;&#x2003;</u>（0），所有的码片序列都两两<u>&#x2003;&#x2003;&#x2003;</u>；<u>&#x2003;&#x2003;&#x2003;</u>（WDM）在光纤上复用信号，本质上与 FDM 相同。</p><h3 id="6-公共电话交换网络"><a href="#6-公共电话交换网络" class="headerlink" title="6. 公共电话交换网络"></a>6. 公共电话交换网络</h3><p>电话机 —&lt;—本地回路，传送模拟信号的双绞线—&gt;— 端局（编码解码器（codec）采用 PCM 进行模拟数据-&gt;数字信号）—&lt;—中继线，数字光纤—&gt;— 交换局  &lt;..<br>电话系统分为<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>（P111）。<br>为了减少错误，采用<u>&#x2003;&#x2003;&#x2003;</u>编码调制（TCM 或网格编码调制）在样本中留出额外的位进行纠错。<br>基于 PCM 的 TDM 中，北美、日本使用<u>&#x2003;&#x2003;&#x2003;</u>，其余国家使用<u>&#x2003;&#x2003;&#x2003;</u>。</p><h3 id="7-交换技术"><a href="#7-交换技术" class="headerlink" title="7. 交换技术"></a>7. 交换技术</h3><p><u>&#x2003;&#x2003;&#x2003;</u>在发送数据前需要建立一条端到端的路径，分为连接建立、数据传输和连接释放三个阶段，其时延小、有序、无冲突、控制简单，但建立连接速度慢，且线路独占效率低，难以规格化；<u>&#x2003;&#x2003;&#x2003;</u>在交换节点采用存储转发的方式，无须建立连接、动态分配线路，可靠性高、利用率高，但有转发时延，且网络结点缓存空间大，现在常常被<u>&#x2003;&#x2003;&#x2003;</u>取代，这是一种限制每次传送的数据块大小的上限以形成分组的方式，其优点在于相对报文交换简化了存储管理、缩短传输时延，且分组逐个传输使得后一个分组的存储和前一个分组的转发可以并行，减少出错和重发，但需要传输额外的控制信息，控制复杂，处理时间长，同时分组顺序无保证。（王道P36）<br>分组交换根据其通信子网向端点提供的服务分为面向连接的<u>&#x2003;&#x2003;&#x2003;</u>（保证到达，对长时间、频繁的数据交换效率高，每个分组使用长度较短的虚电路号）和无连接的<u>&#x2003;&#x2003;&#x2003;</u>（不保证可靠性，不一定按序，每个分组使用长度较长的目的 IP）。网络中传输是否有确认和这两种服务没有关系。（王道P38）</p><h3 id="8-物理层设备"><a href="#8-物理层设备" class="headerlink" title="8. 物理层设备"></a>8. 物理层设备</h3><p>中继器：将信号整形放大再转发出去；两端必须是同一协议<br>集线器：本质上是多端口的中继器，因扩大冲突域、降低性能而走向消亡；<u>&#x2003;&#x2003;</u>双工。（王道P58）</p><h2 id="三、数据链路层"><a href="#三、数据链路层" class="headerlink" title="三、数据链路层"></a>三、数据链路层</h2><p>重新复习三.1，选择重传常常跟<u>&#x2003;&#x2003;&#x2003;</u>策略结合到一起，简述 1-坚持载波检测多路访问（CSMA）（冲突时等待多久？冲突的机会取决于<u>&#x2003;&#x2003;&#x2003;</u>？）什么是 CSMA/CD ？检测冲突的最小时间是？其低负载（只有一个站发送数据）下的信道利用率、高负载（所有站都要发数据）下的信道利用率如何计算？802.11 帧有<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>三种。VLAN 发送过程？VID？802.11Q 帧？</p><h3 id="1-数据链路层的功能"><a href="#1-数据链路层的功能" class="headerlink" title="1. 数据链路层的功能"></a>1. 数据链路层的功能</h3><p>通常可以为上层（网络层）提供无确认的无连接服务（如<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>，适合错误率<u>&#x2003;&#x2003;&#x2003;</u>或实时通信如语音传输），有确认的无连接服务（适用于错误率高的信道，如<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>），有确认的有连接服务（长距离且不可靠，如卫星信道）。不存在无确认的有连接服务。<br>为了方便检测错误或纠正错误，可以将比特流拆成多个离散的帧。成帧可以使用<u>&#x2003;&#x2003;&#x2003;</u>（利用头部的一个字段标识帧中字节数，简单，但一旦出错难以恢复）、<u>&#x2003;&#x2003;&#x2003;</u>（任意比特数的帧不适用，必须是 8 的倍数）、<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>（任意字节可用）、<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>（不再需要字节填充或比特填充，效率高）。成帧时既要首部，也要尾部，因为要从一串比特流中区分开来；而有了帧尾后其上的分组（IP 数据报）就不需要尾部了。<br>首部和尾部的重要作用是确定帧的分界，其余的（帧的数据部分）长度上限为最大传送单元（英文<u>&#x2003;&#x2003;&#x2003;</u>）（王道P66）。<br>数据链路层还可以进行差错控制、流量控制。<br>网卡工作在物理层和数据链路层的 MAC 子层。</p><h3 id="2-差错检测和纠正"><a href="#2-差错检测和纠正" class="headerlink" title="2. 差错检测和纠正"></a>2. 差错检测和纠正</h3><p>假设有 m 个数据位，r 个校验位，n=m+r，一个包含了数据位和校验位的 n 位单元称为 n 位码字，码率为 m/n，两个码字中<u>&#x2003;&#x2003;&#x2003;</u>称为海明距离，全部码字的海明距离指的是<u>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;</u>。为了检测 d 位错误，需要的海明距离最小为 <u>&#x2003;&#x2003;&#x2003;</u>；为了纠正 d 位错误，需要的海明距离最小为 <u>&#x2003;&#x2003;&#x2003;</u>。（P159）<br>纠错码可以在错误发生频繁的信道（如无线链路）应用。为了纠正单个错误，m、r 有什么关系？<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>。（P160）掌握海明码是如何纠一位错的？纠一位错的海明码可以纠突发错误吗？（可以，将 k 个码字按行排列成矩阵，按列发送。发生突发错误时，每列至多只有一个错误时，可以纠正。）<br>检错码适合用在出错较少的光纤等，可以用奇偶校验码（突发错误有 1/2 可能检测不出来）、循环冗余检验码（CRC，广泛应用于数据链路层）。CRC 中最高位和最低位的系数为<u>&#x2003;&#x2003;&#x2003;</u>，生成多项式 G(x)=x^4+x+1 的阶数 r=<u>&#x2003;&#x2003;&#x2003;</u>，除以多少？列竖式时最后要补几个零？，如何计算 CRC？以 1101011011，G(x)=x^4+x+1 为例。带 r 个校验位的多项式编码可以检测到所有长度<u>&#x2003;&#x2003;&#x2003;</u>的突发错误。</p><h3 id="3-基本数据链路层协议"><a href="#3-基本数据链路层协议" class="headerlink" title="3. 基本数据链路层协议"></a>3. 基本数据链路层协议</h3><p>发送方在前移到下一个数据之前必须等待肯定确认的协议称为肯定确认重传协议。</p><h3 id="4-滑动窗口协议"><a href="#4-滑动窗口协议" class="headerlink" title="4. 滑动窗口协议"></a>4. 滑动窗口协议</h3><p>暂时延缓确认以便于将确认信息搭载到下一个出境数据帧的技术称为<u>&#x2003;&#x2003;&#x2003;</u>，其可以更好地利用信道带宽。<br>在滑动窗口协议中，发送方维持一组序号对应着允许它发送（包括已发送未被确认）的帧，这些帧落在<u>&#x2003;&#x2003;&#x2003;</u>中，当有新的数据包从网络层到来时（前提是窗口没达到最大尺寸），被赋予窗口中的下一个最高序号，窗口的上边界前移，收到确认时下边界前移；接收方维持一组序号对应着允许它接收的帧，这些帧落在<u>&#x2003;&#x2003;&#x2003;</u>中。两个窗口可以不同大小。但接收时数据链路层交给网络层的数据包必须与发送时数据包的次序相同。<br>为了找到合适的连续发送帧的上限数 w，需要计算一帧从发送到被接收方接收期间信道上可容纳的帧数（<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>）BD，则 w=<u>&#x2003;&#x2003;&#x2003;</u>。（P180）<br>在管道化传输中哪两种基本方法可以解决错误？（GBN，SR）P181 错误较少发生时适合使用哪个？选择重传常常跟<u>&#x2003;&#x2003;&#x2003;</u>策略结合到一起。对于回退 n 帧协议而言，可以发送的帧数量与序号个数有什么关系？选择重传呢？选择重传中接收方需要多大缓冲区？P188 NAK 丢了会怎样？会重发 NAK 吗？P188<br>解释信道效率（信道利用率）、信道吞吐率？发送方在一个发送周期（如，从开始发送数据到收到第一个确认帧为止）的时间内有效地发送数据所需要的时间占整个发送周期的比率；信道吞吐率为信道利用率×发送方的发送速率，单位 bps。</p><h3 id="5-介质访问控制"><a href="#5-介质访问控制" class="headerlink" title="5. 介质访问控制"></a>5. 介质访问控制</h3><p>用来确定多路访问信道下一个使用者的协议属于数据链路层的介质访问控制子层（MAC，Medium Access Control）。<br>静态信道分配方法：FDM、TDM、WDM、CDMA 等，不能适应突发流量。<br>冲突检测：比较收发信号能量和脉冲宽度的变化<br>冲突窗口：<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>，等于信号在最远两工作站传输延迟的两倍，即一倍的 RTT（Round Trip Time），因此发送最短帧的用时也要大于冲突窗口时间。<br>竞争协议：ALOHA 协议：想发就发，先发后听；有帧损坏，随机等待。其中又分为<u>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;</u>和<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>。（所有帧长度相等）用帧时表示<u>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;</u>，那么纯 ALOHA 的冲突危险期为 <u>&#x2003;&#x2003;&#x2003;&#x2003;</u>，最好的信道利用率约为<u>&#x2003;&#x2003;&#x2003;</u>；分槽 ALOHA 的冲突危险期为<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>，最好的信道利用率为<u>&#x2003;&#x2003;&#x2003;</u>（1/e）。P202<br>站监听是否有传输并据此行动的协议称为<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>。有线网络通常<u>&#x2003;&#x2003;</u>载波侦听，无线通常<u>&#x2003;&#x2003;</u>载波侦听（eg. A 和 B 接入同一 WiFi，A 不一定和 B 在彼此信号范围内）。简述 1-坚持载波检测多路访问（CSMA）（冲突时等待多久？冲突的机会取决于<u>&#x2003;&#x2003;&#x2003;</u>？）？非坚持 CSMA（在有站传输时会一直监听吗）？p-坚持 CSMA（p 是发送还是不发送的概率？适用于时间连续还是离散？在有站发送时等待多久？无站发送却因为概率原因不发送的话等待一个时间槽还是随机时间）？什么是 CSMA/CD ？其原则用八字怎么描述？检测冲突的最小时间是？<br>（总结：有站传输时要么不管它，要么等待随机时间）<br>无冲突协议（了解）：</p><ul><li>位图协议（采用了基本位图法），在发送之前先广播自己的意愿的协议叫<u>&#x2003;&#x2003;&#x2003;</u>：竞争期 j 号站在 j 号槽中插入一位来声明要发送帧，当所有 N 个槽经过后，所有在槽中插入 1 位的站按<u>&#x2003;&#x2003;&#x2003;</u>顺序传送数据。其低负载（只有一个站发送数据）下的信道利用率、高负载（所有站都要发数据）下的信道利用率如何计算？P209</li><li>令牌传递：拿到令牌后，有帧则先发送帧，之后再给下一个站传递令牌。用物理总线实现令牌环为令牌总线。 P210</li><li>二进制倒计数 P210</li></ul><p>有限竞争协议（了解）：自适应树遍历协议 P212<br>无线局域网协议（了解）：隐藏终端问题，暴露终端问题</p><h3 id="6-局域网之以太网"><a href="#6-局域网之以太网" class="headerlink" title="6. 局域网之以太网"></a>6. 局域网之以太网</h3><p>分为经典以太网（原始形式，<u>&#x2003;&#x2003;</u>双工，1-坚持 CSMA/CD）、交换式以太网（速度可达 Gbps，是目前使用的）。<br>DIX 以太网帧（通常的使用标准）和 IEEE 802.3 帧有细微的区别：<br>IEEE 802.3 帧：<br>前导码 10101011 | 目的地址（第 1 字节最低位为 1 说明是组播） | 源地址（MAC）| 长度（不包括前导码，包括帧头帧尾，64~1518 字节，最长防止缓冲区溢出；不和上层打交道，不用类型；值 &lt; 1536）| 数据（最少 46 字节，保证最小 64 字节）| 校验（CRC32，4 字节，校验除了前导码的内容）（“钱墓园常数觉”）<br>以太帧：<br>前导码 10101010 | 目的地址 | 源地址 | 长度 | 类型 （值 &gt; 1536 即 0x600）| 数据<br>MAC 地址：前 24 二进制位是 OUI，代表组织。可以用破折号、冒号或句点，但必须是 16 进账。<br>经典以太网使用 1-持续的 CSMA/CD，当冲突发生后时间被分为长度等于往返传播时间的离散的时间槽，用<u>&#x2003;&#x2003;&#x2003;</u>算法确定随机等待的时间。达到<u>&#x2003;&#x2003;&#x2003;</u>次冲突后随机数的区间固定为<u>&#x2003;&#x2003;</u>，达到<u>&#x2003;&#x2003;&#x2003;</u>次冲突时放弃。<br>交换式以太网：交换机分割了冲突域，可以连接两个不同协议的网络，可以连接快速与慢速的主机（进行缓存），可以只把流量转发到其目的端口。<br>以太网命名方式：<br>10：10Mbps 传输带宽 Base：基带传输 2（或 5）：同轴电缆传输的长度，5 - 500m，2 - 185m<br>10Base5 - 粗缆 总线型拓扑<br>10Base2 - 细缆 总线型拓扑<br>10BaseTX：T - 铜质非屏蔽双绞线 100m 星形拓扑（中心为集线器）<br>F - 光缆 2000m P217和袁老师课件 点对点拓扑<br>快速以太网 100Base-T，如果使用全双工方式的话就不需要 CSMA/CD 了。</p><h3 id="7-局域网之-IEEE-802-11"><a href="#7-局域网之-IEEE-802-11" class="headerlink" title="7. 局域网之 IEEE 802.11"></a>7. 局域网之 IEEE 802.11</h3><p>无线局域网分为<u>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;</u>的无线局域网（星形拓扑，中心叫<u>&#x2003;&#x2003;&#x2003;</u>，是数据链路层设备，采用 CSMA/CA）和无<u>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;</u>的无线局域网（又叫自组织网络）。王道P112<br>802.11 帧有<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>三种。P113（数控管）<br>802.11 数据帧由 MAC 首部（较为复杂）、帧主体（数据）、MAC 尾部（帧校验序列）组成，MAC 首部中前三个地址字段的内容取决于帧控制字段的“去往 AP”和“来自 AP”，地址 1 是直接接收数据帧的结点地址，地址 2 是实际发送数据帧的结点地址。A —(去往 AP, AP, A, B)—&gt; AP —(来自 AP, B, AP, A)—&gt; B 王道P114<br>路由器与 AP 是独立的，路由器是网络层设备。</p><h3 id="8-VLAN"><a href="#8-VLAN" class="headerlink" title="8. VLAN"></a>8. VLAN</h3><p>通过虚拟局域网（VLAN），可以把一个较大的局域网分割成一些较小的逻辑上的 VLAN，每个 VLAN 是一个较小的<u>&#x2003;&#x2003;&#x2003;</u>。王道P115<br>注意，VLAN 既可以隔离冲突域，又可以隔离广播域。王道P138<br>发送过程？（在何处交换的是 802.11Q 帧？）VID？王道P116</p><h3 id="9-数据链路层设备"><a href="#9-数据链路层设备" class="headerlink" title="9. 数据链路层设备"></a>9. 数据链路层设备</h3><p>两个或多个以太网通过网桥连接后形成覆盖范围更大的以太网，原来的每个以太网成为一个网段。以太网交换机是一个多端口的网桥，工作在数据链路层，交换机可以隔离<u>&#x2003;&#x2003;&#x2003;</u>。以太网交换机可以同时连通多对端口，使每对互相通信的主机都能无碰撞地传输数据。<br>以太网交换机的交换方式可以采用<u>&#x2003;&#x2003;&#x2003;</u>（速度快，但无法在不同速率端口之间交换，缺乏安全性（错帧被转发））、<u>&#x2003;&#x2003;&#x2003;</u>（有延迟，但可靠性高，可以在不同速率之间转换）、无碎片交换（折中，因为很多发生冲突的帧是小于 64 字节的残帧）。P263<br>网桥工作在混杂模式下，每个网桥有一个（哈希）表，使用后向学习算法（泛洪，转发，过滤，学习）：<br>对于每个入境帧，如果去往目标地址的端口和源端口相同，则<u>&#x2003;&#x2003;&#x2003;</u>；如果去往目标地址的端口和源端口不同，则<u>&#x2003;&#x2003;&#x2003;</u>；如果目标地址未知，则采用<u>&#x2003;&#x2003;&#x2003;</u>法，将帧发送到除<u>&#x2003;&#x2003;&#x2003;</u>的<u>&#x2003;&#x2003;&#x2003;</u>端口；<br>记录（或更新）端口上发送的帧的源地址以及时间到表中；<br>有一个进程定期删除一段时间前的表项。P259</p><p>交换机和网桥的不同之处：王道P138（连-通-发）<br>交换机一般直接连接局域网主机，网桥常常要连接集线器（网桥只有两个端口）<br>交换机允许多对计算机同时通信，网桥仅允许每个网段上的计算机同时通信<br>网桥只能采用存储转发方式，交换机还可以采用直通方式</p><h3 id="10-生成树协议"><a href="#10-生成树协议" class="headerlink" title="10. 生成树协议"></a>10. 生成树协议</h3><p>（这部分填空答案在下面，因为课本、王道上好像没有）<br>网桥之间的冗余链路生成了拓扑环路，可能产生广播风暴、多帧传送、MAC 地址库不稳定的问题。<br>为此，STP（Spanning Tree Protocol）规定每个网络有一个根网桥，每个网桥有一个根端口，每一个网段有一个<u>&#x2003;&#x2003;&#x2003;</u>；只使用<u>&#x2003;&#x2003;&#x2003;</u>转发；<u>&#x2003;&#x2003;&#x2003;</u>侦听工作报文，在某些端口失效时可以重新启用。<br>生成树算法生成无逻辑回路的生成树，但不能保证<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>。</p><p>答案：指定端口 指定端口 非指定端口 路径最优</p><h2 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h2><p>复习：IPv4 和 v6 头部的长度字段比较？网点本地地址？可聚合<u>&#x2003;&#x2003;&#x2003;</u>地址？</p><h3 id="1-网络层功能与设计"><a href="#1-网络层功能与设计" class="headerlink" title="1.网络层功能与设计"></a>1.网络层功能与设计</h3><p>网络层任务之一是将异构网络互联，网络层中继系统为<u>&#x2003;&#x2003;&#x2003;</u>，网络层以上的中继系统为<u>&#x2003;&#x2003;&#x2003;</u>。王道P140<br>网络层向传输层提供无连接服务，这样的网络叫<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>；提供面向连接的服务，这样的网络叫<u>&#x2003;&#x2003;&#x2003;</u>。IP 协议是<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>的重要范例。在面向连接的服务中，每个数据包包含一个标识符（虚电路号），路由器具有替换出境数据包中连接标识符的能力以防不同的源主机发出同样标识符的数据包而冲突，这叫标签交换。P276</p><h3 id="2-路由算法"><a href="#2-路由算法" class="headerlink" title="2. 路由算法"></a>2. 路由算法</h3><p>路由算法分为非自适应算法（<u>&#x2003;&#x2003;&#x2003;</u>）（网络管理员手工配置，在小型网络中易实施、安全稳定开销小）、自适应算法（<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>）（最常见；有助于流量控制，开销大）。<br>路由算法的目的是为所有路由器发现和使用<u>&#x2003;&#x2003;&#x2003;</u>。P281<br><u>&#x2003;&#x2003;&#x2003;</u>算法（DV）：每个路由器维护一张以网络每个路由器对应一个表项的路由选择表（即矢量），储存每个目的网络及到其的最短距离（距离又称代价）（可以用跳数或平均延迟、带宽之类的衡量）以及下一跳，如<u>&#x2003;&#x2003;&#x2003;</u>协议（这一协议使用<u>&#x2003;&#x2003;&#x2003;</u>作为距离的度量，且最大值为 15，可见只适用于小型网络，王道P146）。所有结点都定期地（RIP 是 30s）将他们的整个路由选择表传送给所有直接相邻的结点，当某一结点被通告一条新的、在本地路由表中不存在的路由时加入这条新的路，当发来的路由信息中有一条到达某目的地的路由代价更小时替换。P285<br>距离-向量路由算法更新报文的大小与通信子网的结点数成正比，在通信子网上传送的路由选择信息的数量容易变大。王道P146<br>距离矢量路由算法对于好消息反应迅速，对于坏消息反应迟缓（慢收敛），坏消息具有<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>问题，可以用毒性逆转等方式缓解（解释毒性逆转？）。P287</p><p><u>&#x2003;&#x2003;&#x2003;</u>（LS）算法使用<u>&#x2003;&#x2003;&#x2003;</u>法将包含发送方<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>及代价的链路状态数据包向本自治系统中所有路由器发送信息（而不是只向相邻的发送；采用序号作为标识，链路状态数据包中还记录着年龄，请判断是每一跳减少年龄还是每秒钟？），且可以在仅当链路状态发生变化时才发送。P289<br>此算法每个结点使用同样的原始状态数据独立计算路径，不依赖<u>&#x2003;&#x2003;&#x2003;</u>的计算；<u>&#x2003;&#x2003;&#x2003;</u>排查故障；且由于链路状态报文仅运载单个结点关于直接链路的信息，大小与网络中的路由结点数<u>&#x2003;&#x2003;&#x2003;</u>，有更好的规模可扩展性。<br>DV 是应用层协议，OSPF 是网络层协议。OSPF 有哪五种分组类型？王道P189<br>（答案：问候分组，数据库描述分组，链路状态请求分组，链路状态更新分组，链路状态确认分组）<br>层次路由：网络规模增长，路由表过大，路由需要分层；因特网将整个互联网划分为许多较小的自治系统，在一个自治系统内部所使用的路由选择协议称为内部网关协议（英文<u>&#x2003;&#x2003;&#x2003;</u>，例如 RIP、OSPF；网关是路由器的旧称），在自治系统之间的路由选择协议称为外部网关协议（英文<u>&#x2003;&#x2003;&#x2003;</u>，如 Internet 上的 BGP）。<br>广播路由：逆向路径转发算法、使用生成树。<br>组播路由<br>选播路由：数据包被传给最近的组成员<br>移动主机路由：家乡代理，三角路由<br>自组织网络（Ad hoc）路由</p><h3 id="3-拥塞控制算法（站在更高角度了解）"><a href="#3-拥塞控制算法（站在更高角度了解）" class="headerlink" title="3. 拥塞控制算法（站在更高角度了解）"></a>3. 拥塞控制算法（站在更高角度了解）</h3><p>按生效从慢到快：<br>流量感知路由（把延迟算入权重，路由表可能会剧烈摇摆）<br>准入控制（广泛应用在虚电路）<br>流量调节（向源主机返回抑制包，显式拥塞通知；逐跳后压（生效较快，但需要每个路由器具有缓存空间））<br>负载脱落</p><h3 id="4-服务质量（站在更高角度了解）"><a href="#4-服务质量（站在更高角度了解）" class="headerlink" title="4. 服务质量（站在更高角度了解）"></a>4. 服务质量（站在更高角度了解）</h3><p>应用需求（分带宽、延迟、抖动、丢失）<br>流量整形（不考）<br>包调度<br>准入控制</p><h3 id="5-网络互联"><a href="#5-网络互联" class="headerlink" title="5. 网络互联"></a>5. 网络互联</h3><p>今天，网桥主要用来连接链路层的同类网络，路由器用来连接网络层不同的网络。P330<br>网络层屏蔽了不同网络的硬件体系上的差异。<br>多协议路由器可以处理多个网络协议。<br>隧道：源主机和目标主机所在网络的类型完全相同，但中间隔着一个不同类型的网络。但隧道无法到达位于隧道之下网络的主机。<br>数据包分段：大数据包穿过路径最大传输单元（MTU）更小的网络时，需要允许<u>&#x2003;&#x2003;&#x2003;</u>将数据包拆分成段。P333<br>将分段重新组成原始的数据包，有<u>&#x2003;&#x2003;&#x2003;</u>分段（重组发生在<u>&#x2003;&#x2003;&#x2003;</u>分段中提供计数字段，且所有数据包必须经过<u>&#x2003;&#x2003;&#x2003;</u>出口路由器，还需要<u>&#x2003;&#x2003;&#x2003;</u>到达的段）和<u>&#x2003;&#x2003;&#x2003;</u>分段（重组发生在<u>&#x2003;&#x2003;&#x2003;</u>；开销可能比透明分段高）两种策略，IP 采用的是<u>&#x2003;&#x2003;&#x2003;</u>。<br>路径 MTU 发现：找到路径上最小的 MTU</p><h3 id="6-Internet-网络层"><a href="#6-Internet-网络层" class="headerlink" title="6. Internet 网络层"></a>6. Internet 网络层</h3><p>IP 提供一种尽力而为（Best Effort）的（不可靠服务）；为路由提供信息，被称作“被路由”协议<br>IP 地址实际上指向的是网络接口。<br>IP 地址分为 A、B、C、D、E 五大类；A 第一个八位组为网络部分，第一位为 0（0~127）；B 前两个八位组为网络部分，前 2 位为 10（128~191）；C 前三个八位组为网络部分，前 3 位为 110（192~223），最多只有 254 台主机（主机部分全为 0 的是网络地址，全为 1 的是广播地址，主机或接口都不能使用）；D 类用作组播，E 类用作科研。</p><p>0.0.0.0 指的是这个主机、这个网络，或路由器默认网关（转发时，目的网络是其他网络时选择默认路由）；255.255.255.255 是泛洪广播地址，为了避免广播风暴，事实上是本地广播地址，路由器不会转发；127 开头的是 Lookback Network（环回地址）；169.254.0.0 是非法地址，如无法从 DHCP Server 正常拿到地址，此地址无法正常通信。</p><p>主路由器（边界路由器）利用子网掩码机制决定分组向内部哪个转发。子网掩码既可以用点分十进制，也可用斜杠 网络位数+子网位数 表示（子网位数是从主机位数借位而来）；路由器不必记录全部主机的 IP，只用按位与；IP 地址由两级结构变成了三级结构。广播地址、网络地址不能标识主机，因此子网的主机位数至少保留 2 位（否则除了全 0 就是全 1）。网络地址正是路由表的查找入口。</p><p>IP 寻址只找到目的机所在的网络，MAC 地址找到目的机。执行 IP 寻址的主要设备就是路由器，一个路由器一跳（hop），最后一跳会解开，最后一个网络上 MAC 寻址会起作用（主要是交换机执行）。MAC 寻址对比 IP 寻址？MAC 寻址只适合小型网络，而 IP 寻址在整个互联网上逐跳推进，MAC 地址是平面的，IP 地址是结构化的，本身携带了位置信息；分别位于数据链路层、网络层；MAC 地址目前还没有用尽的可能，IPv4 已经枯竭；表示的格式不同。<br>路由器收到分组后有三个动作：解封装（打开到网络层，取目的 IP）；目的 IP 和子网掩码进行按位与，得到目的网络（目的网络是路由表的查找入口；路由表只保存网络地址，不保存具体的主机）；重新封装，传给路由表中的下一条（TTL 要减一；TTL - 1 为 0 后会向源发送一个超时信息，同时丢弃）。<br>在不同网络中传送时，MAC 帧中的源地址和目的地址是否会发生变化？王道P158（这是因为具体传送数据帧的数据链路层只认识 MAC）</p><p>IP 分组：头部 + 数据。<br>头部：12 基本字段（20 字节） + 选项部分。<br>IPv4 头部格式：<br>协议版本（0100：v4，4 位）；报头长度（4 位，单位是 4 字节，即要乘 4；0101（头部最小是 20 字节）~1111）；区分服务（Differentiated Service，8 位，没怎么用）；数据报总长度（16 位，单位为字节）；数据包标识号（16 位，确定分段属于哪一个数据报，是为分段准备的），标志位（3 位，决定是否要分片，如从大 MTU 网络进入小 MTU 网络；MF=1 说明有 More Fragment，即还没到结尾；DF=1 说明 Dont Fragment，不可分段），分段偏移量（13 位，分片后可以用于重组；以 8 字节为偏移单位，因此除了最后一个分片外，每个分片的长度都是 8B 的整数倍），生存时间（TTL，8 位，目前单位为跳数），用户协议（8 位，说明传输层用的是什么协议，17 - UDP，6 - TCP），报头校验和（16 位，只对头部计算），源 IP 地址（32 位），目的 IP 地址（32 位），可变长选项（很少使用），填充（将选项填充为 32 位的整数倍，否则报头长度没法是 4 字节的整数倍）。</p><p>有了地址聚合，同样一个 IP 地址，不同的路由器可以将其作为不同大小的子网的一部分（更外围的路由器可以将多个小前缀的地址块合并成一个大前缀的地址块），减小路由表大小，此设计叫<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>；前缀重叠时，采用<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>。P343</p><p>NAT 中文名叫做<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>，使用的三个私有 IP 地址（可重用 IP 地址）范围是<u>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;</u>，出境数据包进入 NAT 盒子后替换源 IP 地址和 <u>&#x2003;&#x2003;&#x2003;&#x2003;</u>。NAT 减少地址消耗，隐藏内部网络结构，但 NAT 实际上违反了协议分层规则：NAT 路由器还需要查看和转换传输层的端口号（工作在传输层）。P347</p><p>IPv6：根本上解决 IP 地址耗尽问题，支持单播、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>（不是广播！），但我们本科生只关注单播，使用<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>书写方式（八个 16 位组），0123-&gt;123，双冒号表示多个全 0（只能出现一次）。从 v4 向 v6 过渡可以采用双协议栈或隧道技术。</p><p>“邻节点”在同一链路（这里的“链路”是由内部路由器分割的线路）上可以跨越交换机。<br>特殊的 IPv6 地址：<br>::/128：未指定（还没获取到地址；路由表默认路由）<br>::1/128 （127 个 0）：环回地址，相当于 127.0.0.1<br>FF 开头（高八位全是 1）：组播<br>FE80 开头 FE80::/10：链路本地地址<br>FEC0 开头 FEC0::/10：网点本地地址<br>链路本地地址只用在单一链路上，不转发到其他链路上，模式为 FE80:0:0:0:EUI 地址。EUI 由 MAC 生成，把 MAC 从中间切开，加上 15 个 1，1 个 0 后把（后 64 位的）从高位数第七位改成 1，形成 64 位 IPv6。<br>可聚合全球单播地址：高 64 位为网络位，低 64 位为主机位（Interface ID）；最高的 48 位是提供商分配的，中间 16 位可以用来子网规划。如何生成？启动后 -&gt; 链路本地地址 -&gt; 和默认网关通信，获取全球 IPv6 地址前缀 -&gt; 加上 Interface ID（三种方式生成：手工，EUI-64 生成（安全隐患），随机生成）生成</p><ul><li>IPv6 固定头部（基本头部）相比 IPv4 的变化：只有 8 个字段，更精简；但有 40 个字节（IPv4 不含选项只要 20 字节）。<br>协议版本 4bit 0110 | 业务等级（提供区分服务，表明优先级） 8bit | 流标签（建立伪连接的能力） 20bit | 净荷长度（指明数据长度，不包括报头） 16bit | 下一个头（指明了当前头之后有哪种扩展头；如果当前是最后一个，就退化为表明搭载的协议，6 - TCP 17 - UDP） 8bit | 跳数限制（HP=TTL） 8bit | 源地址 128bit | 目的地址 128bit<br>相对 IPv4 增加：流标签 修改：长度（v6 只有一个长度了，因为有个“下一个头”）、跳数限制 删除：分段用的标志、分段偏移量（IPv6 需要先知道最小的 MTU）、校验和（数据链路层、传输层常常都校验）、选项</li><li>IPv6 扩展头</li></ul><h3 id="7-Internet-控制协议"><a href="#7-Internet-控制协议" class="headerlink" title="7. Internet 控制协议"></a>7. Internet 控制协议</h3><p>ARP 协议中文叫<u>&#x2003;&#x2003;&#x2003;</u>，每台主机有 ARP 高速缓存；如果转发时 ARP 高速缓存中有目的主机 MAC，则将 MAC 地址写入 MAC 帧；如果没有，则把 <u>&#x2003;&#x2003;&#x2003;&#x2003;</u>写入 MAC 目的地址并广播 ARP 请求分组，目标主机收到后发送单播还是广播响应？王道P158</p><p>ICMP（Internet 控制消息协议）：ICMP 是网络层协议，被封装在<u>&#x2003;&#x2003;&#x2003;</u>中，ICMP 报文分为 ICMP 询问报告（如 ECHO）、ICMP 差错报告（TIME EXCEEDED（TTL=0））。P358<br>（这部分是 MOOC 上的，答案在后面）ping 命令：向目的站点发送<u>&#x2003;&#x2003;&#x2003;</u>报文，目的站点发回<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>报文。tracert 命令是通过<u>&#x2003;&#x2003;&#x2003;</u>得到途径的路由器列表。PMTU（路径 MTU）发送 DF=1 的数据包，得到 PMTU。<br>答案：ICMP 回声请求&#x2003;ICMP 回声应答&#x2003;ICMP 超时报文</p><p>DHCP（动态主机配置协议）：客户端-服务器模式</p><h3 id="8-网络层设备"><a href="#8-网络层设备" class="headerlink" title="8. 网络层设备"></a>8. 网络层设备</h3><p>路由器分割广播域。<br>王道考研认为，转发表/路由表是不一样的，分组的转发实际上靠的是转发表（讨论路由选择的原理时一般不区分）<br>路由表：目的网络/子网掩码，代价（跳数、带宽），…<br>直连路由：接口直连的子网<br>静态路由：人工配置（其中有个默认路由，找不到路时从这里转发）（在小型网络中容易实施，稳定安全开销小；适合小型的网络或默认路由）<br>动态路由：路由选择协议自动建立的（最常见，适合大型的、动态变化的，使实施更复杂，有安全隐患，维护需要 CPU 内存 带宽开销）</p><h2 id="五、传输层"><a href="#五、传输层" class="headerlink" title="五、传输层"></a>五、传输层</h2><h3 id="1-传输服务"><a href="#1-传输服务" class="headerlink" title="1. 传输服务"></a>1. 传输服务</h3><p>完成传输层任务的硬件或软件叫传输实体，传输层协议数据单元为 TPDU（数据段 Segment）。<br>传输层提供应用进程之间的逻辑通信，不同应用进程可以使用同一协议；传输层对收到的报文（首部和数据部分）进行差错检测，但网络层只检查 IP 数据报的首部。<br>网络层往往为运营商架设，传输层能让用户控制；传输层为网络应用程序员提供统一的接口；网络层是主机到主机，传输层送到进程（端到端）。<br>通信模型：通信五元组？通信三元组？<br>答案（MOOC）：源 IP，源 Port，传输协议，目的 IP，目的 Port；源端点，传输协议，目的端点。</p><h3 id="2-UDP（用户数据报）协议"><a href="#2-UDP（用户数据报）协议" class="headerlink" title="2. UDP（用户数据报）协议"></a>2. UDP（用户数据报）协议</h3><p>无连接。<br>数据段头：<br>源端口 16 | 目的端口 16 | UDP 长度（头部 + 数据）| 校验和（不计算时置 0）<br>应用层的各种应用进程通过端口将其数据交付给传输层。应用程序用<u>&#x2003;&#x2003;&#x2003;</u>bit 的端口号标识，服务端的端口中知名端口只能由 UNIX 特权用户使用（小于<u>&#x2003;&#x2003;&#x2003;</u>），如 FTP 使用 <u>&#x2003;&#x2003;&#x2003;</u>，SSH 使用 <u>&#x2003;&#x2003;&#x2003;</u>，SMTP 使用 <u>&#x2003;&#x2003;&#x2003;</u>，HTTP 使用 <u>&#x2003;&#x2003;&#x2003;</u>，HTTPS 使用 <u>&#x2003;&#x2003;&#x2003;</u>。P427<br>服务端的登记端口/注册端口（非特权用户端口/用户端口）号范围是？客户端的动态端口（私人端口）号呢？王道P218<br>UDP 支持一对多、多对一、多对多吗？王道P222<br>UDP 校验和计算？（如果数据不是偶数怎么办？）王道P223</p><h3 id="3-TCP-协议"><a href="#3-TCP-协议" class="headerlink" title="3. TCP 协议"></a>3. TCP 协议</h3><p>TCP 协议是<u>&#x2003;&#x2003;&#x2003;</u>双工、点到点的面向连接服务，将数据视为无结构的字节流。开销大，<u>&#x2003;&#x2003;&#x2003;</u>支持组播、广播。P427<br>TCP 连接的端口称为套接字。<br>TCP 报文段的段头（最短为 20 字节，大于 UDP）：<br>源端口 16 | 目的端口 16 | 序号 32（发送数据的每个字节都占用一个序号，头部的不算）| 确认号（期待接收的字节编号；累计确认）32 | TCP 段头长度（单位是 4 字节，和 IPv4 一样）4 | 保留 + 控制位 | 窗口尺寸 16（从确认字节号开始连续发送的字节总数，防止接收方被数据淹没）| 校验和 | 紧急指针（指向从当前序号开始找到紧急数据的字节偏移量）<br>TCP 三次握手建立连接是具体怎样的？答：<br>Server 常常被动等待。<br>Client 发送连接请求 SYN=1，ACK=0，seq=x（随机；交换初始序列号），变为 SYN-SENT 状态<br>处于 LISTEN 状态的 Server 变为 SYN-RCVD 状态发送连接应答，SYN=1，ACK=1，seq=y，ack=x+1<br>Client 变为 ESTABLISHED 状态并发送：SYN=0，ACK=1，seq=x+1，ack=y+1<br>Server 收到后也变成 ESTABLISHED 状态。</p><p>SYN 泛洪，使用伪造的源 IP，服务器等不来第三次握手了</p><p>TCP 四次握手（四次挥手）释放连接：<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">(ESTABLISHED)               (ESTABLISHED)<br>主动关闭方 ----FIN=1，seq=u----&gt; 被动关闭方<br>(FIN-WAIT-1)<br>      &lt;----ACK=1，seq=v，ack=u+1----<br>(FIN-WAIT-2)                 (CLOSE-WAIT)<br>    此时已经释放掉客户端向服务器发送数据的通道<br>        &lt;----进行未完成的数据传送----<br><br>        &lt;---FIN=1，ACK=1，seq=w，ack=u+1<br>                             (LASK-ACK)<br>        ----ACK=1，seq=u+1，ack=w+1----&gt;<br>(TIME-WAIT)                  (CLOSED)<br>等待 2MSL<br>(CLOSED)<br></code></pre></td></tr></table></figure><br>我猜双方各自关闭各自的发送方向，因此只出现两次 FIN。</p><p>TCP 可靠传输的保障是什么？<br>答案（袁老师 PPT P107）：采用肯定确认重传技术；采用面向连接的数据传输服务；做了收发双方的优化；采用了窗口技术（接收窗口，拥塞窗口，发送窗口）；采用快速重传、快速恢复技术。（“肯连窗快”）<br>王道答案：校验，序号（首部的序号字段），确认（累计确认），重传（超时重传，冗余 ACK 重传 -&gt; 与累计确认紧密相关）王道P232</p><p>TCP 窗口为 0 时，发送者可以发送一个字节的数据段，以便让接受者再次发送期待接收的字节号和窗口数；或发送 Urgent 数据以杀掉远程机器的进程；但其他情况下不能正常发送数据段。<br>简述 Nagle 算法？当数据一个一个字节地发送时，只发送第一个字节，然后将后续的字节缓存起来直到发出的字节得到确认。只有第一次发送的数据包是小数据包。这样减少了所需带宽，但不利于 Internet 游戏。<br>简述 Clark 解决方案？接收方等到有了一定数量的空间之后再告诉发送方。（解决了傻瓜窗口综合症问题）<br>Nagle 送，Clark 收（拿镐送）</p><p>传输层流量控制 VS 数据链路层流量控制？王道P234（传输层是端到端，数据链路层是两个中间的相邻结点的流量控制；数据链路层的滑动窗口协议的窗口大小不能动态变化，传输层的可以）<br>TCP 拥塞控制：假设超时是由拥塞引起的。发送者维护接收窗口 rwnd（易获取）、拥塞窗口 cwnd（网络目前容量，难获取），发送窗口是这两个窗口的最小值。<br>慢启动算法：从当前使用的最大数据段长度初始化拥塞窗口，然后发送一个最大的数据段；如果未超时且未超过慢启动阈值，则翻倍（但不能跃过慢启动阈值）；如果超过了慢启动阈值，每个往返时间拥塞窗口只增加一段；收到三个冗余 ACK 则认为慢启动阈值（ssthresh）是当前拥塞窗口大小的一半（但不能小于 2），之后拥塞窗口设为 1。（王道认为，超时时拥塞窗口会直接设为 1）<br>发生重传后，慢启动阈值被设置为当前拥塞窗口的一半，拥塞窗口被设为 1 个包。（TCP Tahoe）<br>快速恢复：TCP Reno（拥塞窗口被设为慢启动阈值）<br>快速重传：利用冗余 ACK 表达中间有包丢了（因为是累计确认的），三个重复 ACK 会重传，不必等重传计时器超时</p><p>TCP 四个计时器具体是？<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>（防止接收窗口为 0 时死锁）、<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>。（袁老师 PPT）<br>答案：重传计时器、持续计时器、保活计时器、时间等待计时器。</p><h2 id="六、应用层"><a href="#六、应用层" class="headerlink" title="六、应用层"></a>六、应用层</h2><h3 id="1-DNS-域名系统"><a href="#1-DNS-域名系统" class="headerlink" title="1. DNS 域名系统"></a>1. DNS 域名系统</h3><p>Internet 被划分为多个<u>&#x2003;&#x2003;&#x2003;</u>域名，顶级域名被分为<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;&#x2003;</u>两种类型。绝对域名总是以<u>&#x2003;&#x2003;&#x2003;</u>结束。P472<br>顶级域名下还有二级域名、三级域名……每个域负责分配其子域。</p><p>DNS 的基本功能是将域名映射到资源记录，一条资源记录包括哪五元组？IPv4、IPv6 的类型是？P475</p><p>域名解析：将域名映射为 IP 地址。主机查询本地域名服务器（递归查询）：如果要寻找的域在本地域名服务器管辖范围内，本地域名服务器返回权威记录；如果被请求的域名是远程的，且本地未缓存，则本地域名服务器向根域名服务器发送查询请求（迭代查询，反复查询）：根域名服务器可能直接给出资源记录，也可能告诉它向哪个顶级域名服务器发起查询。<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">y.abc.com --递归查询-&gt; dns.xyz.com --迭代查询-&gt; 根域名服务器<br>                                        &lt;-<br>                                        -&gt; dns.com<br>                                        &lt;- 找 <br>                                        -&gt; dns.abc.com<br>                                        &lt;- 权威资源记录 或 明确回答非法<br>                &lt;-<br>z.abc.com -&gt; dns.xyz.com<br>          &lt;-缓存-<br></code></pre></td></tr></table></figure><br>共有<u>&#x2003;&#x2003;</u>个根域名服务器？命名为？</p><p>DNS 消息通常使用 UDP 搭载，但 UDP 报文超过 512 字节时，需要用 TCP；主从域名服务器数据更新同步也需要 TCP。</p><h3 id="2-电子邮件"><a href="#2-电子邮件" class="headerlink" title="2. 电子邮件"></a>2. 电子邮件</h3><p>电子邮件系统包括<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>两类子系统，<br>SMTP 采用 ASCII 发送（用 MIME 收发多媒体邮件，二进制数据基于<u>&#x2003;&#x2003;&#x2003;</u>编码），在两个 MTA 之间运行。由 ISP 的 MTA 暂存，在用户接受邮件后删除：<u>&#x2003;&#x2003;&#x2003;</u>协议；MTA 永久保存：<u>&#x2003;&#x2003;&#x2003;</u>协议。P481（SMTP 发，另两个收）</p><h3 id="3-万维网"><a href="#3-万维网" class="headerlink" title="3. 万维网"></a>3. 万维网</h3><p>从体系结构方面看，Web 应用包括<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>三个组成部分。P500<br>服务器返回 Cookie，浏览器将其保存在本地，在访问时一并发送。<br>什么是代理？（eg.很多学生访问 12306，校园网代理能减少出口带宽）P501笔记<br>TCP 移交？</p><h3 id="4-对等网络（P2P）"><a href="#4-对等网络（P2P）" class="headerlink" title="4. 对等网络（P2P）"></a>4. 对等网络（P2P）</h3><p>所有参与节点均提供资源。<br>DHT（分布式哈希表）是<u>&#x2003;&#x2003;&#x2003;</u>的 P2P 网络，如 Chord：节点标识符为 160 位全体数字，排列成环；用 SHA-1 把 Chord 中的 IP 地址变成 160 位，这些节点标识符有节点（即 IP 地址）所对应；successor(k) 为<u>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;</u>，所有 160 位的数字排列成环，大多数标识符不对应节点；求要查找文件的文件名的 SHA-1，该文件就在 SHA-1 或其 successor 函数作为节点标识符对应的节点上。什么是指取表？第一项是加多少？P582</p><h2 id="七、Cisco-Packet-Tracer"><a href="#七、Cisco-Packet-Tracer" class="headerlink" title="七、Cisco Packet Tracer"></a>七、Cisco Packet Tracer</h2><p>有连接：TCP<br>无连接：802.3（无确认） 802.11 （有确认） IP UDP TFTP</p><p>RTT 是往返时间，不是单程<br>MSS：最大报文段长度</p><p>部分参考了王道考研《计算机网络》。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2022/07/26/operating-system/"/>
    <url>/2022/07/26/operating-system/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="一、操作系统概论"><a href="#一、操作系统概论" class="headerlink" title="一、操作系统概论"></a>一、操作系统概论</h2><h3 id="1-基本特征"><a href="#1-基本特征" class="headerlink" title="1. 基本特征"></a>1. 基本特征</h3><p>软件中最基础的部分是 <u>&#x2003;&#x2003;&#x2003;</u>，运行在 <u>&#x2003;&#x2003;&#x2003;</u>，具有对硬件的完全访问权，可以执行机器能够运行的任何指令。<br>操作系统基本特征：并发（同时存在多个运行的程序）、共享（系统资源供多个并发执行的进程共同使用）（并发和共享是最基本的）、虚拟（时分复用，如虚拟处理器；空分复用，如虚拟存储器）、异步。</p><h3 id="2-功能"><a href="#2-功能" class="headerlink" title="2. 功能"></a>2. 功能</h3><p>操作系统作为计算机系统资源的管理者（处理机管理，可归结为进程管理、存储器管理、设备管理，完成 I/O 请求等、文件管理）；操作系统作为用户与计算机硬件系统之间的接口（命令接口，程序接口如 GUI 调用的系统调用命令）；操作系统实现了对计算机资源的扩充</p><h3 id="3-操作系统发展历程"><a href="#3-操作系统发展历程" class="headerlink" title="3. 操作系统发展历程"></a>3. 操作系统发展历程</h3><p><u>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;</u> 阶段（无操作系统）：用户独占全机，CPU 等待手工操作<br><u>&#x2003;&#x2003;&#x2003;&#x2003;</u> 阶段：单道批处理系统：磁带上作业自动按顺序调入内存运行，内存中只有一道程序<br>多道批处理系统：宏观并行，微观串行，资源利用率高，但不提供人机交互能力，用户无法了解程序运行状态<br>分时操作系统：按时间片把处理机分给各作业，多用户，实时人机交互<br>实时操作系统：需要在某个时间限制内完成某些紧急任务。硬实时系统：绝对地在规定的时刻完成（eg. 飞行控制）；软实时系统：能偶尔违规（eg. 飞机订票系统）</p><h3 id="4-操作系统概念"><a href="#4-操作系统概念" class="headerlink" title="4. 操作系统概念"></a>4. 操作系统概念</h3><p>系统调用是什么？<br>答：程序与操作系统之间的接口，一般由汇编语言写成。<br>执行系统调用，需要传递系统调用参数，执行陷入指令（也就是说，要切换到内核态），执行相应的服务程序，返回用户态。<br>什么是 IPC（进程间通信）？<br>答：进程间协调和同步的通信称为进程间通信。<br>进程与程序间的不同？<br>进程是动态的，程序是静态的；进程有一定的生命周期；一个程序可以对应多个进程，但一个进程只对应单一程序；进程除了包括程序代码，还包括运行该程序所需要的资源。</p><h2 id="二、进程与线程"><a href="#二、进程与线程" class="headerlink" title="二、进程与线程"></a>二、进程与线程</h2><h3 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h3><p>什么是多道程序设计？<br>答：各个任务轮流使用 CPU，每个进程跑几十或几百毫秒。<br>什么是伪并行？<br>答：某一瞬间，CPU 只能执行一个进程，CPU 由一个进程快速切换至另一进程给人以并行的假象。<br>多道程序设计的目的？</p><ul><li>提高 CPU 的利用率；</li><li>提高内存和 I/O 设备的利用率；</li><li>改进系统的吞吐率；</li><li>充分发挥系统的并行性。<br>多道程序设计的缺点？<br>作业的周转时间延长。</li></ul><p>导致进程创建的事件有：</p><ul><li>系统初始化</li><li>由正在运行的进程创建</li><li>用户请求创建</li><li>批处理作业的初始化</li></ul><p>前台进程是什么？<br>与用户交互并完成相应工作的进程。<br>后台进程是什么？<br>非前台进程，具有某些专门的功能。<br>守护进程（daemons）是什么？在后台处理各种请求服务的进程。</p><p>UNIX 进程：父进程调用 Wait 可以等待子进程退出。</p><p>导致进程终止的条件？</p><ul><li>正常退出（自愿）</li><li>出错退出（自愿）eg: 输入文件不存在</li><li>严重错误（非自愿）eg: 内存越界</li><li>被其他进程杀死（非自愿）</li></ul><p>Unix 有进程组，Windows 无。</p><p>进程三种可能状态？</p><ul><li>运行态：正在使用 CPU</li><li>就绪态：在等待队列，随时可运行</li><li>阻塞态：无法运行，直到某些条件满足</li></ul><p>OS 中最核心的概念是进程。进程是 <u>&#x2003;&#x2003;&#x2003;&#x2003;</u> 的基本单位。什么是进程？<br>答：一个进程就是一个正在执行程序的实例，是包含运行一个程序所需要的所有信息的容器。<br>进程的信息保存在一个进程表中，进程表的表项为 <u>&#x2003;&#x2003;&#x2003;&#x2003;</u>（PCB），包括什么？进程从 P1 切换到 P2 时，将 P1 运行状态保存到 P1 的 PCB 中，从 P2 的 PCB 中读出相应的状态。<br>答：进程控制块 用户 ID（UID）、进程 ID（PID）、组 ID（GID）</p><h3 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h3><p>线程是什么？<br>答：线程是操作系统能够调度的最小单位。<br>线程间可以共享数据、内存。每个线程维护自己的程序计数器、寄存器、堆栈、状态。<br>为什么需要线程？<br>答：多个任务可以同时进行；可以共享变量等资源；线程比进程更经济，容易创建和销毁；在多核架构计算机上有用。</p><p>线程有哪两种实现方式？有什么优劣？<br>答：用户级线程：在用户空间实现线程，速度快、可扩展，但阻塞一个进程将阻塞该进程的所有线程，且无法在多核处理器上实现线程级别的并行；内核级线程：在内核空间实现线程，可以单独阻塞某个进程的一个线程，可以在多核处理器上实现线程级别的并行，但线程管理速度慢，线程表非常大，占内存。<br>还有混合实现方式。</p><h3 id="3-进程间通信（IPC）"><a href="#3-进程间通信（IPC）" class="headerlink" title="3. 进程间通信（IPC）"></a>3. 进程间通信（IPC）</h3><p>什么是竞争条件？<br>答：多个进程访问一个共享数据，数据的值由进程访问的先后顺序决定。<br>什么是临界资源？<br>答：互斥共享变量所代表的资源，即一次只能被一个进程使用的资源。<br>什么是临界区？<br>答：并发程序中与共享互斥变量相关的程序段，访问临界资源的程序片段。<br>实现互斥的方法？<br>答：严格轮换法（进程 A 退出临界区时把共享变量 turn 赋值 1，仅在 turn = 0 时进入临界区；进程 B 正相反，实现轮换执行。缺点是效率不高，必须轮换），Peterson’s 解法（双标志后检查法的改进，turn 避免相互谦让导致的饥饿；仍然有忙等待），硬件方案（测试并加锁 (TSL) 指令，将内存值保存到 CPU 寄存器并将此值赋 1）<br>忙等待不仅浪费 CPU，还可能导致优先级反转（优先级高的进程等优先级低的退出临界区）。<br>信号量原子操作：UP(V)，DOWN(P)。互斥量是特殊的信号量。</p><h3 id="4-进程间同步与互斥的关系"><a href="#4-进程间同步与互斥的关系" class="headerlink" title="4. 进程间同步与互斥的关系"></a>4. 进程间同步与互斥的关系</h3><p>同步是什么？互斥是什么？同步与互斥的关系是什么？<br>答：多个相互合作的进程，在一些关键节点上互相等待或互相交换信息，这种相互制约关系称为同步。<br>当一个进程进入临界区使用临界资源时，另一个进程必须等待其退出临界区后才可以访问，这种相互制约关系叫互斥。<br>互斥是同步的一种特殊情况。</p><p>使用信号量实现互斥时，互斥信号量初值常常为 1，实现同步时同步信号量初值一般为 0。</p><p>此部分应当看考研题。</p><h3 id="5-进程调度"><a href="#5-进程调度" class="headerlink" title="5. 进程调度"></a>5. 进程调度</h3><p>调度程序是什么？调度算法是什么？调度算法的目标是什么？<br>答：用于决定哪个进程使用 CPU 的操作系统模块叫调度程序；调度程序使用的算法叫调度算法；调度算法的目标有公平性（每个进程获得相同的 CPU 使用时间）、效率性（CPU 忙碌）、响应时间（指的是从发出命令到得到响应的时间）、周转时间（指的是从提交任务到任务执行完的时间）、吞吐量。</p><p>FCFS 先来先服务<br>SJF 最短作业优先，分为抢占式、非抢占式；平均周转时间最小，但难以预知进程的 CPU 用时<br>轮转调度<br>优先级调度（将 CPU 用时短视作优先级高则得到 SJF），可能有饥饿问题，对此可以引入老化技术，让等待进程的优先级随着时间推移而增大（eg. 响应比：(等待时间+要求服务时间)/要求服务时间）</p><h3 id="6-管程"><a href="#6-管程" class="headerlink" title="6. 管程"></a>6. 管程</h3><p>管程是由过程、变量、数据结构组成的集合，进程可以随意调用管程中的过程，但不能在管程外访问管程内的数据结构。编译器确保任一时刻管程中只能有一个活跃的进程。<br>条件变量允许一个进程在某个变量上等待，只有 wait（挂起调用的进程）、signal（唤醒在该变量上挂起的一个进程）两个操作。<br>管程的优缺点？</p><ul><li>编程方便</li><li>实现困难，难以在编程语言中引入</li></ul><h3 id="7-消息传递"><a href="#7-消息传递" class="headerlink" title="7. 消息传递"></a>7. 消息传递</h3><p>消息传递可能阻塞（同步）或非阻塞（异步）。最受欢迎的是不阻塞发送者，阻塞接受者。</p><h2 id="三、内存管理"><a href="#三、内存管理" class="headerlink" title="三、内存管理"></a>三、内存管理</h2><h3 id="1-克服内存容量限制（暂时不知道叫什么）"><a href="#1-克服内存容量限制（暂时不知道叫什么）" class="headerlink" title="1. 克服内存容量限制（暂时不知道叫什么）"></a>1. 克服内存容量限制（暂时不知道叫什么）</h3><p>克服内存容量限制的两个办法？<br>答：交换技术，虚拟内存</p><h3 id="2-交换技术"><a href="#2-交换技术" class="headerlink" title="2. 交换技术"></a>2. 交换技术</h3><p>把一个程序完整调入内存，使该进程运行一段时间，然后把它存回磁盘。<br>需要为可能增长的数据段和堆栈段预留空间。<br>在内存中产生多个空洞时，可以通过什么技术合并空闲区？<br>答：内存紧缩技术</p><h3 id="3-虚拟内存"><a href="#3-虚拟内存" class="headerlink" title="3. 虚拟内存"></a>3. 虚拟内存</h3><p>覆盖把程序划分成多个片段，能解决程序所需的内存大于内存空间的问题，但程序员所要做的非常复杂。虚拟内存把工作交给计算机去做。（只能基于非连续分配技术）<br>谁负责把虚拟地址映射成物理地址？<br>答：MMU（内存管理单元）<br>虚拟地址空间按固定大小划分为（虚拟）页面，物理内存中对应的单元称为（页）框。<br>页表实际上是把虚拟页映射成页框的函数。大部分操作系统为每个进程分配一个页表。<br>页表有哪两种保存方式？各有什么优劣？</p><ul><li>用寄存器矩阵构成页表：简单，但每次进程切换时都要把整个页表重新加载，代价十分高，严重影响性能；</li><li>把页表放在内存里，用一个单独的寄存器指向这个页表：上下文切换代价低，但读页表项时要访问一个或多个内存单元。<br>页表项结构：页框号 在/不在（指示是否有效） 保护位（指明权限） 修改位（是否修改过，供页面置换使用） 访问位  高速缓存禁止位（禁止该页面被高速缓存）<br>TLB（Translation Lookaside Buffer）（转换检测缓冲器，快表，相联存储器）</li></ul><p>多级页表能减小页表大小。<br>倒排页表是什么？<br>答：每个实际物理页框对应一个表项。这样节约存储表的内存，但增加了页访问时搜索表所需的时间。</p><h3 id="4-存储管理"><a href="#4-存储管理" class="headerlink" title="4. 存储管理"></a>4. 存储管理</h3><p>使用位图：查找位图中指定长度的连续 0 串较为耗时<br>使用链表的存储管理：分配空闲内存时有首次适配、下次适配、最佳适配、最大适配四种算法。</p><h3 id="5-页面置换算法"><a href="#5-页面置换算法" class="headerlink" title="5. 页面置换算法"></a>5. 页面置换算法</h3><p>OPT，NRU，FIFO，第二次机会页面置换算法，时钟页面置换算法，LRU，NFU，NFU 老化，工作集模型，工作集时钟算法<br>最优页面置换算法（OPT，OPTimal replacement）：替换最长时间内不再被访问的页面，性能最优，不可能实现<br>NRU（最近未使用）的思想？<br>答：每个页面有访问位（R）和修改位（M），其中访问位会定期清零；将页面分为 Class 0: 未访问，未修改 - Class 1: 未访问，已修改 - Class 2: 已访问，未修改 - Class 3: 已访问，已修改 四大类，NRU 随机从类别序号最低的页面中选择一个页面。<br>FIFO：维护装入内存中的页面的链表，每次置换最老的，容易实现。<br>第二次机会页面置换算法（Second Chance）：FIFO 中设置访问位 R，如果 R = 0，替换；R = 1，将其移动到链表尾部并令 R = 0。<br>时钟页面置换算法：环形链表，R = 1 时向前移动表针<br>LRU（最近最少使用）：假设最近被使用的页面有很大可能短期内还会被使用。软件方案：用链表将页面链接起来，每次内存请求更新链表，开销巨大；硬件方案：采用 64 位计数器硬件，将值保存到页表中，这样页表会更大。<br>NFU（最不经常使用）：是 LRU 的近似实现，每个时钟中断时增加相应页面的计数器。带老化技术的 NFU：每次计数器右移一位，最左端置 1。</p><h3 id="6-工作集模型"><a href="#6-工作集模型" class="headerlink" title="6. 工作集模型"></a>6. 工作集模型</h3><p>什么是局部性访问？<br>答：进程运行的任何阶段都只访问较少的一部分页面。<br>什么是请求调页：<br>答：页面在请求时才调入。<br>什么是颠簸（抖动）？<br>答：进程每执行几条指令就发生一次缺页中断。<br>什么是工作集？<br>答：进程最近一段时间访问的页面集合。<br>什么是工作集模型？<br>答：在进程运行之前，系统保持进程的工作集在内存中。<br>工作集模型页面置换：让一个进程的工作集是该进程在过去的 τ 虚拟时间内访问的页面集，则扫描页表，依次寻找直到找到满足条件的：R = 0，年龄大于 τ 的；R = 0，年龄不大于 τ 但最大的；R = 1，随机选择一个。工作集模型开销大。<br>WSClock（工作集时钟算法）：有一个定期的时钟中断（假设 τ 横跨多个时钟滴答）清除 R 位；扫描所有页面，若 R = 1，设置 上次使用时间 为 当前时间；若 R = 0 且生存时间大于 τ，替换之；若 R = 0 且生存时间小于等于 τ，看看它是不是生存时间最长的（扫描完就知道了），替换生存时间最长的 R = 0 页面；如果是最坏情况（不存在 R = 0 页面，所有页面都读过了），随机选择一个页面替换（最好是干净页面）。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.i4k.xyz/article/qq_36320285/93219003">[1]</span></a></sup></p><h3 id="7-页面置换算法建模"><a href="#7-页面置换算法建模" class="headerlink" title="7. 页面置换算法建模"></a>7. 页面置换算法建模</h3><p>什么是 Belady 异常现象？<br>答：采用更多的页框并不总使得缺页次数减少。（我认为，Belady 发生的原因是当页框数增加时，页框中的页面并不是增加前的超集）<br>LRU 算法建模：当页面被访问时移到表格的最顶端。<br>什么是栈置换算法？<br>答：基于 K 个页框的页面集合总是属于基于 (K + 1) 个页框的页面集合，这样的页面置换算法是栈置换算法。<br>全局分配策略对所有可运行的进程动态分配页框，局部分配策略只对单个进程分配。<br>全局分配策略可以防止颠簸并保持页命中率在一定范围内。<br>小页面优点是内部碎片小，缺点是进程需要大量的页，页表大。</p><h3 id="8-杂项"><a href="#8-杂项" class="headerlink" title="8. 杂项"></a>8. 杂项</h3><p>具有相同程序的两个进程可以共享页表<br>分页守护进程大部分时间处于睡眠状态，当唤醒时会检查内存状态，当空闲页框很少时换出一些页面。<br>读取数据到缓冲区（我觉得可以类比 DMA）时可以锁住（钉住，pinning）缓冲区页面。<br>后备存储：在磁盘上分配空间两种方法（此部分我没有详细地看）</p><h3 id="9-缺页中断处理"><a href="#9-缺页中断处理" class="headerlink" title="9. 缺页中断处理"></a>9. 缺页中断处理</h3><p>陷入内核 -&gt; 保存通用寄存器等信息 -&gt; 发现需要哪个虚拟页面 -&gt; 检查地址是否有效，检查存取与保护是否一致；无错则检查是否有空闲页框，如果无，页面置换算法淘汰一个页面 -&gt; 如果选择的页框“脏”，写回磁盘 -&gt; 页框干净后查找所需页面在磁盘地址并装入 -&gt; 更新页表 -&gt; 恢复发生缺页中断以前的状态，程序计数器重新指向这条指令 -&gt; 调度引发缺页中断的进程 -&gt; 返回到用户空间继续执行</p><h3 id="10-分段"><a href="#10-分段" class="headerlink" title="10. 分段"></a>10. 分段</h3><p>段是逻辑上独立的地址空间。段使用二维内存地址，由 段号，段偏移量 两部分组成。（是二维的，所以要相加；而分页则是一维的）</p><h3 id="11-分区存储管理"><a href="#11-分区存储管理" class="headerlink" title="11. 分区存储管理"></a>11. 分区存储管理</h3><p>固定分区，可变分区</p><p>连续分配管理方式：单一连续分配，固定分区分配，动态分区分配；<br>非连续分配管理方式：基本分页存储管理，基本分段存储管理，段页式存储管理</p><h3 id="12-内存管理"><a href="#12-内存管理" class="headerlink" title="12. 内存管理"></a>12. 内存管理</h3><p>内存管理的主要功能？</p><ul><li>内存空间的分配与回收</li><li>地址转换</li><li>内存空间的扩充</li><li>存储保护<br>什么是地址重定位？<br>答：将用户程序中的逻辑地址转换为运行时可由机器直接寻址的物理地址，这一过程称为地址重定位。</li></ul><h2 id="四、文件系统"><a href="#四、文件系统" class="headerlink" title="四、文件系统"></a>四、文件系统</h2><h3 id="1-文件"><a href="#1-文件" class="headerlink" title="1. 文件"></a>1. 文件</h3><p>常见的三种文件结构有字节序列（Windows、Linux）、记录序列（已过时，很少使用）、树（大型机）。<br>文件类型分为普通文件和目录文件，Unix 还有字符设备文件、块设备文件等。普通文件一般分为 ASCII 文件和二进制文件。<br>文件访问可以分顺序访问和随机访问。</p><h3 id="2-目录"><a href="#2-目录" class="headerlink" title="2. 目录"></a>2. 目录</h3><p>文件系统用目录记录文件的位置，一级目录只有一个目录（root），二级目录包含 root 和用户目录，层次目录包含 root 目录、用户目录和任意多的子目录。绝对路径包含从 root 目录到该文件的路径，相对路径包含从当前目录到该文件的路径。. 指当前目录，.. 指父目录。</p><h3 id="3-文件系统的实现"><a href="#3-文件系统的实现" class="headerlink" title="3. 文件系统的实现"></a>3. 文件系统的实现</h3><p>文件由哪两部分组成？<br>答：文件由文件控制块（FCB，保存文件属性，如文件名、存取控制，在 Unix 中称为 i-node）和文件体两部分构成。open 系统调用：读的是控制信息。<br>磁盘分为主引导记录：磁盘 0 号扇区，记录分区表；分区表给出每个分区的起始和结束地址；磁盘分区，每个分区都包含引导块（用于引导装载 OS）、超级块（文件系统参数）、空闲空间。<br>文件系统可以采取什么分配方式？其优缺点是什么？<br>连续分配（每个文件作为一连串的数据块存储，实现简单，读取性能好，但容易产生碎片，且要预先知道文件大小，如 CD-ROM）、链表分配（为每个文件构造磁盘块链表，但随机访问速度慢，且每个物理块中存储的数据不是 2 的整数幂次方）、文件分配表（FAT，把每个物理块的指针集中记录到一个表，放在内存中索引，优点是整个物理块可用于存储数据，且信息访问在内存中，访问快，缺点是需要占用大量内存（所有物理块都有个数组项））、I-节点（I-node）（记录文件属性以及文件内容的存储地址；索引节点下可以挂间接块）</p><h3 id="4-目录的实现"><a href="#4-目录的实现" class="headerlink" title="4. 目录的实现"></a>4. 目录的实现</h3><p>当一个文件被打开时，文件系统首先用用户给出的路径信息找到相应的目录项，目录项提供了查找文件物理块所需的信息（eg: i-节点的值）<br>文件属性可以存放在什么位置？</p><ul><li>简单目录：目录项中存储文件属性和地址；</li><li>引用 i-节点的目录：把文件属性存在 i-节点中。<br>有哪些方法处理长文件名？缺点？</li><li>目录项中固定长度（浪费空间）</li><li>目录项中记录可变长的文件名（删除文件产生空隙）</li><li>文件名放入目录后面的堆中（管理堆产生开销）<br>如何搜索文件？</li><li>从目录中线性搜索（慢）</li><li>哈希表（速度快，但有额外开销，文件多时才考虑）</li><li>将查找结果存入高速缓存</li></ul><h3 id="5-共享文件"><a href="#5-共享文件" class="headerlink" title="5. 共享文件"></a>5. 共享文件</h3><p>目录与共享文件的联系称为链接。<br>传统树形目录共享：将不同的 FCB 设为同一物理地址，但新增内容无法共享。<br>基于索引节点的共享方式（硬链接）：目录项指向相同的索引节点，需要增加一个计数值统计指向该索引节点的目录项的个数。优点是不需要多次访问磁盘，不需要额外空间存储文件路径名。<br>用符号链接实现文件共享（软链接）：符号链接文件包含该文件的路径，需要读取包含路径的文件再一级一级扫描，有额外磁盘开销。优点是符号链接可以指向其他机器文件。</p><h3 id="6-虚拟文件系统"><a href="#6-虚拟文件系统" class="headerlink" title="6. 虚拟文件系统"></a>6. 虚拟文件系统</h3><p>抽象出文件系统共有的部分。优点是对不同的文件系统使用相同的 API，将文件操作与具体的文件系统实现分开，具有更好的灵活性。</p><h3 id="7-磁盘空间管理"><a href="#7-磁盘空间管理" class="headerlink" title="7. 磁盘空间管理"></a>7. 磁盘空间管理</h3><p>磁盘块大：内部碎片，空间效率降低；块小：时间效率降低。<br>记录空闲块的方法？</p><ul><li>磁盘块链表（每个块都保存指向下一个空闲块的指针）</li><li>位图（空闲块用 1，已分配块用 0 表示）</li></ul><h3 id="8-文件系统备份"><a href="#8-文件系统备份" class="headerlink" title="8. 文件系统备份"></a>8. 文件系统备份</h3><p>哪两种备份策略？优缺点？</p><ul><li>物理转储：全部磁盘块复制，简单快速，但无法增量转储，不能满足对特定文件的恢复请求。</li><li>逻辑转储：从一个或几个指定的目录开始，递归地转储其自给定基准日期后更改的文件和目录。满足恢复特定文件或目录的请求。<br>逻辑转储算法四步骤？</li><li>将修改过的文件和全部目录标记；</li><li>去掉不包含任何修改过的文件或目录的目录上的标记；</li><li>转储所有标记为需转储的目录</li><li>转储被标记的文件</li></ul><h3 id="9-文件系统一致性"><a href="#9-文件系统一致性" class="headerlink" title="9. 文件系统一致性"></a>9. 文件系统一致性</h3><p>一致性检查分为块一致性检查和文件一致性检查。<br>块一致性检查步骤？<br>答：构建两张表，第一张表记录块在文件中出现的次数，第二张表记录块在空闲列表中的使用情况；然后通过扫描 i-node/FAT 更新第一张表的值，扫描空闲列表/位图更新第二张表的值；每一块或者在第一张表中为 1，或者在第二张表中为 1，如果都是 0（块丢失），添加到空闲列表，如果空闲列表中的值大于 1（空闲块重复），重新建立空闲表，如果数据块重复，则分配一个空闲块，复制重复的内容到该块，插入到其中一个文件中。<br>文件一致性检查步骤？<br>维护一张表，其中一个文件对应一个计数器；扫描文件系统，对目录中每个文件，计数器加一；比较计数值和 i-node 中的值，如果不相等，把 i-node 中的链接计数设为目录项个数。</p><h3 id="10-文件系统性能"><a href="#10-文件系统性能" class="headerlink" title="10. 文件系统性能"></a>10. 文件系统性能</h3><p>什么是块高速缓存？<br>答：一系列逻辑上属于磁盘，但实际上保存在内存中的块。<br>页面置换算法可用于管理高速缓存。<br>为了减少磁盘臂运动，可以把有可能顺序读取的数据放在一起。（i-node 放在磁盘开始位置）</p><h2 id="五、输入-输出"><a href="#五、输入-输出" class="headerlink" title="五、输入/输出"></a>五、输入/输出</h2><h3 id="1-I-O-设备"><a href="#1-I-O-设备" class="headerlink" title="1. I/O 设备"></a>1. I/O 设备</h3><p>块设备：传输以一个或多个完整的块为单位（如磁盘）<br>字符设备：以字符为单位发送或接收一个字符流（如键盘、鼠标、打印机）<br>其他设备：时钟<br>每个 I/O 设备有两个组成部分：物理部件与电子部件（即设备控制器，其任务是？）<br>答：控制设备的物理运行；将序列字位转化为字节块流；纠错<br>控制器与 CPU 的数据交互通过设备寄存器进行，为提高效率，设备通常还有数据缓冲区。</p><h3 id="2-访问-I-O-方式"><a href="#2-访问-I-O-方式" class="headerlink" title="2. 访问 I/O 方式"></a>2. 访问 I/O 方式</h3><p>每个控制寄存器被分配一个 I/O 端口号（不干扰内存操作，增加程序设计难度）<br>内存映射 I/O：所有控制寄存器映射到内存空间（与内存访问统一，增大系统设计难度）<br>混合方案：数据缓冲区用内存映射 I/O，控制寄存器用单独的 I/O 端口</p><h3 id="3-I-O-实现方式"><a href="#3-I-O-实现方式" class="headerlink" title="3. I/O 实现方式"></a>3. I/O 实现方式</h3><p>程序控制 I/O（忙等待）：CPU 与外围设备间的数据传送由 CPU 完成<br>中断驱动 I/O：CPU 初始化 I/O 并启动第一次 I/O 操作 -&gt; CPU 处理其他任务 -&gt;当 I/O 完成时产生中断 -&gt; CPU 处理中断 -&gt; CPU 恢复被中断的程序<br>使用 DMA 的 I/O：DMA 控制器进行数据交换</p><h3 id="4-I-O-软件层次"><a href="#4-I-O-软件层次" class="headerlink" title="4. I/O 软件层次"></a>4. I/O 软件层次</h3><p>I/O 软件有哪四个层次？</p><ul><li>用户级 I/O 软件（库过程（printf、scanf），假脱机（spooling）：如打印机守护进程打印假脱机目录下的文件）</li><li>与设备无关的操作系统软件（执行对所有设备公共的 I/O 功能，并且向用户层软件提供一个统一的接口；缓冲，提高数据传输率，防止溢出：无缓冲，用户空间缓冲（页面被调出的话会出问题）、内核空间缓冲接着复制到用户空间（效率高得多，但缓冲区满了调入内存时无法接收数据）、内核空间双缓冲（一个缓冲区正在被复制时另一个可以收集输入））</li><li>设备驱动程序（直接驱动 I/O 进行输入输出操作的软件，通常是内核的一部分；驱动程序阻塞自己，直到 I/O 操作完成并产生一个中断；禁止在驱动程序中调用系统调用）</li><li>中断处理程序（常常要唤醒设备驱动程序）<br>用户发出 I/O 请求后，用户程序 -&gt; 系统调用 -&gt; 设备驱动 -&gt; 中断处理</li></ul><h3 id="5-磁盘"><a href="#5-磁盘" class="headerlink" title="5. 磁盘"></a>5. 磁盘</h3><p>分为硬盘、软盘。磁盘被组织成柱面、盘面和扇区的层次。（磁盘的硬件结构包括磁头、磁道、扇区）<br>磁盘读写时间由 <u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u> 三部分组成。通常寻道时间占主要部分。<br>答：寻道时间、旋转延迟、实际数据传输时间。<br>错误验证由磁盘控制器完成。<br>对磁盘读写信息的最小单位是物理块。<br>为了隐藏每个磁道有多少扇区的细节，大多数现代磁盘除了物理几何规格外有一个虚拟几何规格呈现给操作系统。<br>磁盘在使用前，盘片必须低级格式化。一个磁盘扇区包括哪些部分？前导码包含柱面、扇区号等用以识别扇区，ECC 用于恢复错误。<br>答：前导码、数据部分（通常为 512 字节）、ECC。<br>柱面斜进的目的：让磁盘在一次连续的操作中读取多个磁道而不丢失数据。<br>由于读出扇区后要做 ECC 计算后才能传送数据，无法连着读取多个扇区，可以采用磁盘交错编号，如单交错、双交错。</p><h3 id="6-磁盘臂调度算法"><a href="#6-磁盘臂调度算法" class="headerlink" title="6. 磁盘臂调度算法"></a>6. 磁盘臂调度算法</h3><p>磁盘臂的调度由驱动程序调用处理。<br>常用的调度算法：</p><ul><li>先来先服务（FCFS）</li><li>最短寻道优先（SSF，Shortest Seek First）</li><li>电梯算法（要知道初始移动的方向，否则要讨论）</li></ul><h3 id="7-坏扇区处理"><a href="#7-坏扇区处理" class="headerlink" title="7. 坏扇区处理"></a>7. 坏扇区处理</h3><p>可以将磁盘中的一个备用扇区映射为对应的坏扇区，也可以顺序移动坏扇区后续的扇区。</p><h3 id="8-稳定存储器"><a href="#8-稳定存储器" class="headerlink" title="8. 稳定存储器"></a>8. 稳定存储器</h3><p>稳定存储器的目标是不惜一切代价保证磁盘数据的正确性。稳定存储器使用一对相同的磁盘。<br>稳定写的步骤是：驱动器 1 上写一个块，然后读并验证，若验证错误，则继续写并验证，直到正确；若 n 次后仍不正确，则将该块映射到备用块上。之后用同样的方法将数据备份到驱动器 2 上。<br>稳定读的步骤：从驱动器 1 上读块，若产生错误 ECC 则再次读，经过 n 次连续的失败后，从驱动器 2 上读取对应的数据块。</p><h3 id="9-廉价磁盘冗余阵列"><a href="#9-廉价磁盘冗余阵列" class="headerlink" title="9. 廉价磁盘冗余阵列"></a>9. 廉价磁盘冗余阵列</h3><h3 id="10-时钟"><a href="#10-时钟" class="headerlink" title="10. 时钟"></a>10. 时钟</h3><p>可编程时钟有哪两种操作模式？<br>答：一次完成模式（类似倒计时）与方波模式（周期性的时钟中断）。<br>时钟驱动功能：维护日时间；防止进程超时运行；处理用户进程提出的 alarm 系统调用等。<br>维护日时间的三种方法？<br>答：64 位寄存器保存时钟滴答；保存秒数和当前一秒中的时钟滴答；保存开机时间和从开机时间之后的时钟滴答。</p><h3 id="11-键盘"><a href="#11-键盘" class="headerlink" title="11. 键盘"></a>11. 键盘</h3><p>每次按键或释放均产生一个中断，键盘驱动从 I/O 端口提取键盘产生的扫描码，转为 ASCII 码。<br>处理方式：规范模式（驱动程序行内编辑并传给用户程序）、非规范模式（原始模式）。</p><h3 id="12-鼠标"><a href="#12-鼠标" class="headerlink" title="12. 鼠标"></a>12. 鼠标</h3><p>带跟踪球；光电鼠标。</p><h3 id="13-输出软件"><a href="#13-输出软件" class="headerlink" title="13. 输出软件"></a>13. 输出软件</h3><p>一个图形用户界面有哪四个基本要素？<br>答：窗口、图标、菜单、定点设备。</p><h3 id="14-电源管理"><a href="#14-电源管理" class="headerlink" title="14. 电源管理"></a>14. 电源管理</h3><p>省电的最常用办法是将设备设计成具有多种状态，如工作、睡眠、休眠、关闭。<br>电压减半，时钟速度减半，功耗减少到 1/4。</p><h2 id="六、死锁"><a href="#六、死锁" class="headerlink" title="六、死锁"></a>六、死锁</h2><h3 id="1-资源与死锁"><a href="#1-资源与死锁" class="headerlink" title="1. 资源与死锁"></a>1. 资源与死锁</h3><p>什么是资源？<br>答：资源指的是一种能够被请求、被使用和被释放的对象。<br>资源分为哪两类？<br>答：可抢占资源、不可抢占资源<br>请求失败，请求资源的进程常常会被阻塞<br>死锁的定义是？（注意其主语）<br>答：一个程序集处于死锁状态，当集合中的每个进程都在等待一个资源，而该资源又被集合中的另一个进程占有。</p><h3 id="2-死锁的条件"><a href="#2-死锁的条件" class="headerlink" title="2. 死锁的条件"></a>2. 死锁的条件</h3><p>死锁需要哪四个必要条件？</p><ul><li>互斥条件：进程拥有的资源不能被共享，只能由一个进程使用；</li><li>占有和等待条件：已得到资源的进程可以再请求新的资源</li><li>不可抢占条件：分配给进程的资源不可强制抢占，只能被拥有它的进程释放</li><li>环路等待条件：存在一条环路，环路中每个进程都在等待下一个进程所占有的资源。（这里的表述是“下一个”）</li></ul><h3 id="3-死锁建模"><a href="#3-死锁建模" class="headerlink" title="3. 死锁建模"></a>3. 死锁建模</h3><p>利用有向图建模：资源用方形，进程用圆形表示；从资源节点到进程节点的有向边代表该资源被请求、授权并占用；从进程节点指向资源节点的有向边表示当前进程正在请求该资源，并且该进程已经被阻塞。（怎么记忆呢？男的向女的伸手只是追求，女的向男的伸手才是追到；资源虽然有个“源”，但它并不是圆的）资源中的圆点或方块表示其实例</p><h3 id="4-处理死锁的策略"><a href="#4-处理死锁的策略" class="headerlink" title="4. 处理死锁的策略"></a>4. 处理死锁的策略</h3><p>鸵鸟算法，死锁检测与死锁恢复，死锁避免，死锁预防<br>鸵鸟算法：忽略死锁；如果概率非常小的话，预防死锁的代价非常高<br>死锁检测与恢复：每种类型一个资源的死锁检测：若从资源分配图中找到一个环，则说明存在死锁；每种类型多个资源的死锁检测：需要现有资源向量 E（资源总数）、当前分配矩阵 C（第 n 行是进程 n 已分配到的资源数）、可用资源向量 A、请求矩阵 R，具体算法是找到一行未标记的 R，其每个分量小于 A 中的值，将其标记为完成，然后把 C 中对应的值加入 A 中。（我叙述的，可能不规范）最后存在没有标记的进程，说明存在死锁；死锁恢复：利用抢占恢复（eg. 人工把打印机的文件拿出来），利用回滚恢复（周期性地对检查点检查，发现死锁则将进程恢复到一个更早的状态），通过杀死进程恢复。<br>死锁避免：动机是判断满足某个请求是否安全。什么是安全状态？安全状态和不安全状态的区别是？不安全状态并不必然转化为死锁状态（有进程提前终止）银行家算法理论上完美，实际上不实用，因为进程很难预知所需的资源，仅用于少量特殊系统。<br>答：一个状态是安全的，如果存在某种调度顺序使得每个进程都可以结束，即使所有进程都请求其所需的全部资源。（不存在时称为不安全状态）区别：在一个安全状态，系统可以保证（注意是“可以”）所有进程都能结束；在不安全状态，系统不保证所有进程都能结束。<br>死锁预防：能否破坏互斥条件？占有并等待呢？不可抢占呢？循环等待呢？<br>答：破坏互斥条件几乎不可能。破坏占有并等待条件可以要求进程在执行前获得所有资源，但进程可能在开始执行时无法知道所需的资源。破坏不可抢占条件可以在请求另外资源被拒绝时释放掉已有的资源，但不适用于打印机等。破坏循环等待条件可以让进程申请资源必须按资源编号升序提出，但难以确定资源编号顺序，且资源数目太多，难以一一编号。</p><h3 id="5-非资源死锁"><a href="#5-非资源死锁" class="headerlink" title="5. 非资源死锁"></a>5. 非资源死锁</h3><p>通信死锁</p><h3 id="6-两阶段加锁"><a href="#6-两阶段加锁" class="headerlink" title="6. 两阶段加锁"></a>6. 两阶段加锁</h3><p>阶段一：进程对所需的所有记录加锁，一次锁一个，如果某个记录已经被锁，则释放它加锁所有的记录，重新开始。<br>阶段二：完成更新，释放锁。<br>（类似一次请求所有的资源）</p><h3 id="7-饥饿"><a href="#7-饥饿" class="headerlink" title="7. 饥饿"></a>7. 饥饿</h3><p>什么是饥饿？<br>答：一个进程总是被剥夺处理其工作所必需的资源。<br>饥饿与死锁的比较？</p><ul><li>死锁会导致饥饿，但饥饿不一定死锁；</li><li>饥饿有可能自动结束，但死锁不会。</li></ul><h2 id="七、安全"><a href="#七、安全" class="headerlink" title="七、安全"></a>七、安全</h2><h3 id="1-环境安全"><a href="#1-环境安全" class="headerlink" title="1. 环境安全"></a>1. 环境安全</h3><p>信息系统的安全分解为哪三个部分？<br>答：数据机密性（数据暴露；PPT 上写的是生成一份未授权的软件副本也算）、数据完整性（数据篡改）、系统可用性（系统瘫痪或拒绝服务）<br>入侵者：闯入与自己毫不相干区域的人</p><h3 id="2-密码学原理"><a href="#2-密码学原理" class="headerlink" title="2. 密码学原理"></a>2. 密码学原理</h3><p>柯克霍夫原则：加密算法应该公开，加密的安全性由独立于加密算法之外的密钥决定。<br>私钥（对称密钥）：密钥量大，速度快<br>公钥加密，私钥解密，运算速度慢<br>数字签名：文档-&gt;散列值-&gt;私钥加密</p><h3 id="3-保护机制：保护域"><a href="#3-保护机制：保护域" class="headerlink" title="3. 保护机制：保护域"></a>3. 保护机制：保护域</h3><p>域是（对象，权限）对的集合，通常域相当于单个用户和用户组。<br>权限：对某个操作的执行许可<br>访问控制表：对每个对象给出任意用户的访问权限<br>权能字列表：对每个进程给出可访问对象</p><h3 id="4-用户验证"><a href="#4-用户验证" class="headerlink" title="4. 用户验证"></a>4. 用户验证</h3><p>常用使用口令验证（可以用“盐”克服加密口令的预计算）、基于实际物体的验证、生物识别验证。</p><h3 id="5-内部攻击"><a href="#5-内部攻击" class="headerlink" title="5. 内部攻击"></a>5. 内部攻击</h3><p>后门陷阱（插入额外代码）、欺骗登录</p><h3 id="6-外部攻击"><a href="#6-外部攻击" class="headerlink" title="6. 外部攻击"></a>6. 外部攻击</h3><p>缓冲溢出</p><h3 id="7-恶意代码"><a href="#7-恶意代码" class="headerlink" title="7. 恶意代码"></a>7. 恶意代码</h3><p>定义：在未被授权的情况下，以破坏软硬件设备、窃取用户信息、扰乱用户心理、干扰用户正常使用为目的编制的软件或代码片段。<br>特征：目的性、传播性、破坏性<br>分类：传统计算机病毒和其他恶意代码（木马、蠕虫）<br>蠕虫是利用系统漏洞自我传播的恶意程序，由引导程序和蠕虫本身组成</p><h3 id="8-可信计算"><a href="#8-可信计算" class="headerlink" title="8. 可信计算"></a>8. 可信计算</h3><p>可信计算：形式上申明了安全要求并满足了这些安全要求<br>可信计算基：包含了实施所有安全规则所必须的硬件和软件</p><h3 id="9-多级安全"><a href="#9-多级安全" class="headerlink" title="9. 多级安全"></a>9. 多级安全</h3><p>Bell-LaPadula 模型：进程既可下读（简易安全规则）又可上写（<em> 规则）。（机密，但不完整）<br>Biba 模型：没有往上写（简单完整性规则），不能向下读（完整性 </em> 规则）</p><h3 id="10-隐蔽信道"><a href="#10-隐蔽信道" class="headerlink" title="10. 隐蔽信道"></a>10. 隐蔽信道</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.i4k.xyz/article/qq_36320285/93219003">https://www.i4k.xyz/article/qq_36320285/93219003</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>神船 TX6 延长 ArchLinux 下的续航</title>
    <link href="/2022/01/17/arch-standby/"/>
    <url>/2022/01/17/arch-standby/</url>
    
    <content type="html"><![CDATA[<h1 id="神船-TX6-延长-ArchLinux-下的续航"><a href="#神船-TX6-延长-ArchLinux-下的续航" class="headerlink" title="神船 TX6 延长 ArchLinux 下的续航"></a>神船 TX6 延长 ArchLinux 下的续航</h1><p>神船 TX6（2020 款，CU5Dx）采用蓝天 NK60SB 模具，搭载 Intel Core i5-10400 这一 6 核心 12 线程，TDP 65W 的 LGA 封装 CPU 和 NVIDIA GeForce GTX1650 （4GB GDDR6）独立显卡，再加上 16.1 寸 60Hz 的 LCD 显示屏，却使用一块只 47Whr 的可拆卸电池，如果运行 Linux 的话，在办公、编码场景下对其续航到底能抱有多大期待呢？经过一番并不足够硬核的调教，又能有怎样的进步呢？</p><h2 id="Part-1-背景"><a href="#Part-1-背景" class="headerlink" title="Part 1 背景"></a>Part 1 背景</h2><p>先前，笔者已经在<a href="https://zhaozihanzzh.github.io/2021/08/10/bios-gpu-switch/">神船 TX6 BIOS 开关独显</a>一文中通过关闭独显获得了明显的续航进步。即使<a href="https://zhaozihanzzh.github.io/2021/02/02/flexicharger/">限制充电上限</a>，在 Windows 10 下，续航也已经差不多能满足本人一上午或一下午的需要了。但是，ArchLinux 的续航相比 Windows 仍然不是很令人满意。我忍不住想动手了。</p><h2 id="Part-2-初次尝试"><a href="#Part-2-初次尝试" class="headerlink" title="Part 2 初次尝试"></a>Part 2 初次尝试</h2><p>起初，我以为影响续航的罪魁祸首是那颗台式机 CPU，在上网查找一番后决定安装 <code>x86_energy_perf_policy</code> 软件包，执行 <code>sudo x86_energy_perf_policy powersave</code> ，但没这个调速器，就改成了 <code>sudo x86_energy_perf_policy power</code>。运行了一段时间，却没发现有什么变化，搞得我一度以为这行命令没有作用。之后，我决定直接关闭 CPU 的睿频，执行 <code>sudo x86_energy_perf_policy --turbo-enable 0</code>。睿频成功地关掉了，但是耗电速度仍然很快。尝试采用 TLP，好像也没有缓解迅速下降的电量。由于当时时间有限，我没有再深入尝试，不过我感觉可能问题在桌面环境上。</p><h2 id="Part-3-再次探索"><a href="#Part-3-再次探索" class="headerlink" title="Part 3 再次探索"></a>Part 3 再次探索</h2><p>后来有一定的时间后，决定花一些时间探讨一下。看到<a href="https://www.zhihu.com/question/61602649/answer/189422293">这条回答</a>，但并没听说过 CPU 的 Package C State 相关的内容，不过还是把 PowerTOP 也给安装了，并没起太大作用，但 PowerTOP 的监控却让我发现可以进行一下更定量化的探索：亮度 25% 左右时，KDE 下这台机器待机耗电在 8W 以上。又看了<a href="https://www.zhihu.com/question/447039478/answer/1758871266">这个回答</a>，怀疑是 Baloo 的错，把它禁止了，仍然没有测得数据下降。我禁止 sddm 的自启动，这样重启后就不会启动图形界面了（这个具体要根据各人的配置），在命令行环境下登录，已经自启 TLP，开启 PowerTOP 的 autotune，结果却另我大吃一惊：不进行任何操作时，功耗仍然在 8W 左右！看来，除了 GUI 外，一定还有其他因素在影响。<br>带着问题，我重启进了 Windows。这次查看的是 HWiNFO64 中的 Battery Charge Rate，结果 Windows 10 待机下电池放电速率仅有 6W 多，足足少了 2W。既然这样，那可能是上面那条回答中所提到的设备问题了。<br>PowerTOP 里面有 WakeUp 一栏，列出了我的 USB 接口、有线网络接口和无线网络接口。想起在 PowerTOP 的 Overview 里还看到过蓝牙有关的东西，我执行了 <code>sudo rfkill block bluetooth</code>，这样似乎有了些提升：空闲时功耗在 7.9W 左右了。<br>但这还不够。在外面场景时，WiFi 往往是需要开启的，因此从无线网络上似乎省不出什么东西。会不会是有线网络呢？我重启进入 Windows，打开 HWiNFO64，等到功耗 6W 多时插上了网线。功耗在波动了一番后竟然升到了 8W 多。拔下网线，功耗又降回了 6W多。难道有线网卡真的耗 2W？我又重启进入 Linux，这次让 PowerTOP 待机连续观测了很长时间，确认这张 Realtek 有线网卡在 Linux 下无论是否连接网线，均有 2W 的功耗。<br><img src="https://zhaozihanzzh.github.io/images/powertop-overview-rfkill.png" alt="block bluetooth 后，亮度 25%"><br><img src="https://zhaozihanzzh.github.io/images/powertop-rfkill.png" alt="block bluetooth 后，亮度 25%"><br>检查发现，有线网卡驱动模块名为 r8169。执行 <code>sudo rmmod r8169</code> 后在 PowerTOP 里显示有线网络接口功耗为 0，但是事实上电池报告的数值并无下降。执行 <code>lspci | grep Ethernet</code> 后得出其 PCI 地址，切换到 su 后执行 <code>echo 1 &gt; /sys/bus/pci/devices/地址/remove</code>，没有进步。执行 <code>sudo ip link set 有线网络接口名 down</code>，也不行。<br><img src="https://zhaozihanzzh.github.io/images/powertop-rmmod-r8169-lowlight.png" alt="rmmod r8169，注意此时亮度为 5%"><br>就在这时，我看到了 <a href="https://wiki.archlinux.org/title/Network_configuration/Ethernet#Realtek_RTL8111/8168B">Wiki</a>，再结合网上其他的讨论，决定更换网卡驱动试一试。按照 Wiki 的做法，用 pacman 安装了 r8168，并在 <code>/etc/modprobe.d/</code> 下新建一个配置文件写入 <code>blacklist r8169</code>，执行 <code>sudo mkinitcpio -P</code>，重启后内核模块成了 r8168，这时不连接有线网时多的 2W 功耗终于消失不见了。顺便说，很多人说 RTL8168 的网卡却用的是 r8169 的内核模块是系统识别错误，我却认为<a href="https://askubuntu.com/questions/1279644/r8168-r8169-which-one-should-i-use">“没有调查就没有发言权”</a>。<br><img src="https://zhaozihanzzh.github.io/images/powertop-r8168-lowlight.png" alt="r8168，注意此时亮度为 5%"><br>经过测试，使用 VSCode，开启 Chromium 并连接 WiFi，关闭 CPU 睿频，此时虽然 VSCode 没那么跟手了，但经过 50min 的使用，电量从 75% 下降到 61%，续航有明显提升。</p><p>滑稽的是，直到撰写本文前我一直以为我的有线网卡是 Realtek RTL8168，可在求证时按照网上说的，用 <code>lspci</code> 命令得到 <code>Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller (rev 12)</code> 后却发现，这块 Device 10ec:8168（从 dmesg 里看到的），<a href="https://pci-ids.ucw.cz/read/PC/10ec/8168">rev 12 的网卡居然是张 Realtek RTL8411B</a>。（后来才看到好像<a href="https://www.zhihu.com/question/377276925/answer/1061623225">确实是这样的</a>）</p><h2 id="Part-4-修复问题"><a href="#Part-4-修复问题" class="headerlink" title="Part 4 修复问题"></a>Part 4 修复问题</h2><p>我以为到这里本帖就应该结束了，可后来在使用中才发现休眠后无法唤醒。经查，只要是 TLP 运行在电池模式下，休眠（到 RAM）后就会出现睡死的情况（显示休眠前的画面，REISUB 有效，无法切换 TTY），并且 journalctl 里面只记录到休眠前的 log。我起初毫无头绪，后来观察发现休眠后唤醒时硬盘活动指示灯不亮，推测可能是 TLP 对硬盘进行的省电设置导致的。于是编辑 /etc/tlp.conf，把 <code>DISK_DEVICES</code> 显式地置为空串，重启后终于可以正常休眠了。在阅读了<a href="https://linrunner.de/tlp/settings/disks.html">官方文档</a>后，把 <code>AHCI_RUNTIME_PM_ON_BAT</code> 从默认的 <code>auto</code> 改成 <code>on</code> 并把 <code>DISK_DEVICE</code> 复原后，睡死不再出现。看来在我的机器上（linux 5.16.3，systemd 250.3-1，tlp 1.5.0-4）上这个选项是要修改的。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RSA 论文翻译：一种实现数字签名和公钥密码系统的方法</title>
    <link href="/2022/01/16/hackermath-rsa/"/>
    <url>/2022/01/16/hackermath-rsa/</url>
    
    <content type="html"><![CDATA[<p>本文是对 R.L. Rivest、A. Shamir 和 L. Adleman 论文 A Method for Obtaining Digital Signatures and Public-Key Cryptosystems 的翻译。需要注意的是，这个翻译只是为了完成任务而已，（本人对密码学了解甚少，按理说是没有能力、不应该进行这样的工作的）未经任何形式的检查，不仅有翻译不恰当的地方，甚至应该也有理解性的错误，但截至 2021 年 11 月时，敝人并未在网上找到现成的其他翻译（也可能是我不懂得如何搜索），故就此发出，权当抛砖引玉。</p><h1 id="一种实现数字签名和公钥密码系统的方法"><a href="#一种实现数字签名和公钥密码系统的方法" class="headerlink" title="一种实现数字签名和公钥密码系统的方法"></a>一种实现数字签名和公钥密码系统的方法</h1><p>R.L. Rivest, A. Shamir, and L. Adleman∗</p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>本文提出一种具有能够在公开加密密钥的同时不泄露相应的解密密钥这一全新性质的加密方法。这一性质有两个重要影响：</p><ol><li><p>传输密钥不需要使用信使或其他安全手段，因为信息可以用接受者公开的加密密钥来加密，而只有接受者知道对应的解密密钥，因此只有他可以解密信息。</p></li><li><p>一条信息可以被私有的解密密钥“签名”，每个人都可以用对应的加密公钥来验证此签名。签名不能被伪造，并且签名者也不能在签名后否认签名的有效性。这在“电子邮件”和“电子转账”中应用效果明显。</p></li></ol><p>一条消息可以通过转换成数字M，计算M的e次幂（e是公开的指定值）并除以两个选定的大素数p和q的积n（n是公开的指定值）取余数，得到加密。解密过程也是类似的；只有在e · d ≡ 1 (mod (p − 1) · (q − 1))中用到了一个不同的私密的幂d。这套系统的安全性部分地依赖于对公开的除数n进行因式分解的难度。</p><p><em>关键词</em>：数字签名，公钥密码系统，私密性，认证，安全，因式分解，素数，电子邮件，信息传送，电子转账，密码学。</p><p>CR Categories: 2.12, 3.15, 3.50, 3.81, 5.25</p><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>“电子邮件” [10]时代可能即将到来；我们必须确保现行“纸质邮件”系统的两个重要特性能得以保留：(a) 信息内容是私密的，(b)能够对信件进行签名。我们将在本文中论证如何在电子邮件系统中实现这些能力。</p><p>此方案以一种新的“公钥密码系统”实现为核心。Diffie 和 Hellman 在论文中提出了公钥密码系统这一优雅的概念，但并未给出具体的公钥密码系统实现，本研究希望填补这一空白。[1] 对[1] 熟悉的读者可以直接跳到第五节来阅读有关本文提出的方法的描述。</p><h2 id="2-公钥密码系统"><a href="#2-公钥密码系统" class="headerlink" title="2 公钥密码系统"></a>2 公钥密码系统</h2><p>在一个“公钥密码系统”中每个用户在一个公共文件中放置一个加密程序E。换言之，公共文件是一个给出了每个用户加密程序E的目录。用户将对应的解密程序D保密。这些程序有以下四个性质：</p><p>(a) 加密M后再解密可以得到M。一般地，<br>$$D(E(M)) = M. \tag{1}$$(b) E 和 D 易于计算。</p><p>(c) 用户公开 E 并不会使得 D 易于被算出，因此实际上只有他自己能解密用 E 加密的信息，或者高效地计算D。</p><p>(d) M 先被解密，再被加密后仍然得到 M。一般地，<br>$$E(D(M)) = M.  \tag{2}$$一套加密（或解密）程序往往由一套通用方法和一个加密密钥组成。受密钥控制的通用方法加密信息M得到信息的加密形式，称之为密文C。每个人可以使用同一套通用方法；给出的程序的安全性将依赖于密钥的安全性。泄露加密算法因此意味着泄露密钥。</p><p>公开 E 相当于公开一种非常低效的计算 D(C) 的方法：穷举信息 M 的所有可能直到找到一个 M 使得 E(M) = C。如果性质 (c) 满足，要穷举的数量将会十分巨大，也就意味着此方法不切实际。</p><p>一个满足 (a)-(c) 的函数 E 是一个“单向陷门函数”；此外还满足 (d) 的 E 称为“单向陷门置换”。Diffie 与 Hellman [1] 引入了单向陷门函数的概念但没有给出任何实例。此类函数是“单向”的，因为这些函数从一个方向上是易于计算的，但（显然）从另一方向计算十分困难；此类函数是“陷门”的，因为一旦已知某些私密的“陷门”信息，反向计算就变得容易了。一个满足 (d) 的单向陷门函数一定是一个置换：每个信息都是其他某条信息的密文，每条密文都是一条可以被接受的信息。（这种映射是“一对一”和“满射”的）。仅在实现“签名”时需要性质 (d) 。</p><p>我们鼓励读者阅读 Diffie 和 Hellman 的杰作[1] 来了解相关背景知识和对公钥密码系统的详尽解释，以及探讨密码学中的其他问题。公钥密码系统保证私密性和实现“签名”（在下面的第三和第四节将会讨论）的原理也在 Diffie 和 Hellman 的论文中有解释。</p><p>在我们的方案中，我们假设 A 和 B （一般是 Alice 和 Bob）是公钥密码系统的两个用户。用下标来区分他们的加密和解密程序：<em>E<sub>A</sub></em>, <em>D<sub>A</sub></em>, <em>E<sub>B</sub></em>, <em>D<sub>B</sub></em>。</p><h2 id="3-私密性"><a href="#3-私密性" class="headerlink" title="3 私密性"></a>3 私密性</h2><p>加密是让通信私密的常规方式。在向接受者发出消息前，发送者需要对信息加密。接收者（除任何未经授权的人）知晓可用于从接收到的消息中获得原本信息的解密函数。在传输信息时收集到信息的窃听者只接收到了不能解密的无意义“垃圾”（密文）。</p><p>在计算机数据库中存储和在电话线中传输的大量私人的和敏感的信息使得加密日益重要。意识到高效的、高质量的加密技术处于急需紧缺的状态，美国国家标准局今日正式通过了一项由 IBM 提出的“数据加密标准” [13, 14]。新的标准并不包括实现公钥密码系统所需的性质 (c)。</p><p>所有的经典加密方法（包括美国国家标准局提出的标准）都受“密钥分发问题”困扰。该问题在于，在私密通信开始之前，为了把对应的加密和解密密钥分发给发送者和接收者，必须建立另一个私密传输。通常需要一个私密信使把密钥从发送者带给接收者，这对于构建高速廉价的电子邮件系统而言是不可行的。而一个公钥密码系统不需要私密信使；密钥可以在不安全的信道上分发。</p><p>在公钥密码系统中，Bob 如何向 Alice 发送一条私密信息呢？首先，他在公共文件中检索E<sub>A</sub>，然后将加密过的信息 E<sub>A</sub>(M) 发送给她。 Alice 通过计算 D<sub>A</sub>(E<sub>A</sub>(M)) = M 解密信息。由公钥密码系统性质 (c) 可知，只有她能解密 E<sub>A</sub>(M)。她用公共文件中的 E<sub>B</sub> 也能加密私密的回复。</p><p>注意到在 Alice 和 Bob 之间建立私密通信不需要私密传输。唯一需要的“设定”是希望接收私密通信的每位用户都把他的加密算法放入公共文件中。</p><p>两位用户也可以在不查询公共文件的情况下通过不安全的信道建立私密通信。每位用户把他的加密密钥发送给对方，之后和公钥系统一样，所有信息便可以用接收者的加密密钥加密。监听信道的入侵者因为不可能从加密密钥中取得解密秘钥而无法解密任何信息（我们假定入侵者不能在信道中修改或者发送信息）。Ralph Merkle 对这个问题已经提出了另一个解决方案 [5]。</p><p>公钥密码系统可以用于“引导”进入如美国国家标准局方案等的常规加密体系。一旦建立了加密通信，就可以将第一条传输的信息作为美国国家标准局方案中的密钥来解密接下来的所有信息。如果我们的方法在加密时比常规方案慢的话，这是可取的。（如果使用专用的硬件加密设备，美国国家标准局方案大概会稍快；在通用计算机上我们的方案可能更快，因为多精度的算术运算比复杂的位控制更易实现。）</p><h2 id="4-签名"><a href="#4-签名" class="headerlink" title="4 签名"></a>4 签名</h2><p>如果电子邮件系统要在商务交易中取代已有的纸质邮件系统，那么必须能够“签署电子信息。收到签名过的信息的人就有了信息是从发出者发出的证据。这个性质比单纯的身份认证（接收者可以验证信息来自发送者）更强有力；接收者能向“法官”证明签名人发送了这条信息。为了实现这个目标，他必须向法官证明他没有伪造这条信息！而在一个身份认证问题中，由于接收者只用让自己相信信息来自发送者，他就不用担心这种可能性了。</p><p>一个电子签名必须是依赖于消息内容和签署人的。否则，接收者可以修改信息后把信息和签名成对地出示给法官，或者利用电子的“剪切、粘贴”难以被发现的特性把签名与任意一条信息拼接起来。</p><p>由于将会对未解密的信息使用解密算法，为了实现签名功能，公钥密码系统必须实现单向陷门置换（例如具有性质 (d)）。</p><p>用户 Bob 如何在公钥密码系统中向 Alice 发送一条“签名”过的消息 M 呢？他首先用 DB 计算他对于消息 M 的“签名” S：<br>$$S = D_B(M).$$（由公钥密码系统的性质 (d) 可知，解密一条未经加密的信息“有意义”：每条信息都是其他一条信息的密文。）他然后用 E<sub>A</sub> 加密 S （为了隐私），然后把结果 E<sub>A</sub>(S) 发送给 Alice 。他不需要将 M 也发送；M 可以从 S 中计算出。</p><p>Alice 首先用 D<sub>A</sub> 解密密文来获得 S。她知道签名的发送者应该是谁（在这个例子中是 Bob）；如果必要的话，这个人可以在 S 上附带的纯文本中给出。之后她用发送者的加密流程，此例中是 E<sub>B</sub> （可以在公共文件中找到），来提取信息：<br>$$M = E_B(S) .$$因此她拥有了一个有着和签名过的纸质文档相似性质的信息-签名对 (M, S)。</p><p>Bob 不能以后否认向 Alice 发送过这条消息，因为没有其他人能创建 S = D<sub>B</sub>(M)。Alice 可以用 E<sub>B</sub>(S) = M作为证据说服“法官” Bob 签署了这份文档。</p><p>显然 Alice 不能把 M 修改为不同的版本 M’，因为那样的话她必须也创建对应的 S’ = D<sub>B</sub>(M’)。因此 Alice 可以证明她收到的 Bob “签名”的邮件是 Bob 发送且她不能修改的。（她也不能在其他的任何邮件中仿造他的签名。）</p><p>一个电子支票系统可以基于像上面一样的签名系统构建。不难想象，你的家庭终端中有一个让你签发能通过电子邮件发往收款人的支票的加密设备。唯一必要的是在每张支票中加入一个唯一的支票号码，这样就算收款人复制这张支票，银行也只会接受它见到的第一个版本。</p><p>如果加密设备足够快速的话，另一种可能将出现：可能将出现说出的每个字在发送前都被加密设备签名的电话通信。</p><p>当上述加密被用作签名时，加密设备不应该被“植入”在终端（或计算机）和信道之间，因为一条信息可能需要用多个密钥依次加密。可能把加密设备看成是可以按需执行的“硬件子程序”更加自然。</p><p>我们已在上面假定每位用户总是能够可靠地访问公共文件。在一个“计算机网络”中这可能是困难的；入侵者可能会把自己的消息伪造成是来自公共文件的。用户将会相信他真的获得了想要通信的用户的加密程序，不会假设是入侵者的加密程序。如果公共文件对发送给用户的消息进行“签名”的话，这种危险将不复存在。用户可以用公共文件的加密算法 E<sub>PF</sub> 来验证签名。通过在用户首次露面（亲自）来加入公钥密码系统并存储他的加密程序时将 E<sub>PF</sub> 的描述递交给他，就可以避免要到公共文件中“查找” E<sub>PF</sub> 自己的问题。用户能够把这个描述存储起来，不用再次查找。每位用户加入系统时与公共文件管理员的一次安全的会面取代了每一对用户之间的信使。另一解决方案是当用户注册时给他一本记录系统中所有用户加密密钥的书（像电话号码簿）。</p><h2 id="5-我们的加密和解密方法"><a href="#5-我们的加密和解密方法" class="headerlink" title="5 我们的加密和解密方法"></a>5 我们的加密和解密方法</h2><p>我们使用公共加密密钥 (e, n) 来加密消息 M 的方法如下。（这里 e 和 n 是一对正整数）</p><p>首先，用 0 到 n - 1 之间的整数表示这条消息。（将长信息分成一系列块，并用这样的这个整数来表示每个块）可以使用任何标准的表示。这一步的目的不是加密信息，只是变形成进行加密所需要的数字形式。</p><p>然后，通过对其 e 次幂取模 n 加密消息。也就是说，结果（密文 C）是 M<sup>e</sup> 被 n 除的余数。</p><p>解密密文需要取其 d 次幂对 n 的模。加密和解密算法 E 和 D 是这样的：<br>$$\text{对消息 M，}C \equiv{E(M)}\equiv{M^e}\pmod{n}.$$$$\text{对密文 C，}D(C)\equiv{C^d}\pmod{n}.$$注意加密不会增大消息的长度；消息和密文都是范围在 0 到 n - 1 之间的整数。</p><p>加密密钥因此是正整数对 (e, n) 。类似地，解密秘钥是正整数对 (d, n)。每位用户公开他的加密密钥，同时把相对应的解密密钥保密。（这些整数应该被正确地脚注为 n<sub>A</sub>，e<sub>A</sub>，d<sub>A</sub>的形式，因为每位用户都有自己的一组。然而，我们只会考虑一组作为代表，因此省略下标。）</p><p>如果你想使用我们的方法的话，应该如何选择加密和解密密钥？</p><p>首先计算两个素数 p 和 q 的乘积 n：<br>$$n = p\cdot{q} .$$这两个素数是非常大的、“任意”的。尽管你会公开 n，但由于因式分解 n 难度巨大，除了你之外的任何人都很难发现隐藏的因子 p 和 q。这也使得从 e 推出 d 的方法难以被找出。</p><p>然后你选出与 (p − 1) · (q − 1) 互素的随机的大整数 d。也就是说，确保 d 满足：<br>$$gcd(d, (p − 1)\cdot{(q − 1)}) = 1$$(“gcd” 意思是“最大公因数”)</p><p>最后用 p，q 和 d 计算出 d 模 (p − 1) · (q − 1) 的逆元 e。因此有<br>$$e\cdot{d}\equiv{1}\pmod{(p − 1)\cdot{(q − 1)}}.$$我们将在下一节证明，这确保了 (1) 和 (2) 成立，即 E 和 D 是逆置换。第 7 节中展示了如何高效完成以上每一步操作。</p><p>上述方法不应与 Diffie 和 Hellman 为解决密钥分发问题提出的“求幂”技术 [1] 混淆。他们的技术使得两位用户能够选定一个可在一般的密码系统中使用的共同的密钥。这一技术并不是建立在单向陷门置换之上的。Pohlig 和 Hellman [8] 研究了一种与我们的方案有关的，对素数取模来计算幂的方案。</p><h2 id="6-数学基础"><a href="#6-数学基础" class="headerlink" title="6 数学基础"></a>6 数学基础</h2><p>通过使用 Euler 和 Fermat 提出的性质 [7]，我们论证了解密算法的正确性：对于任意和 n互素的整数（消息）M，<br>$$M^{\varphi{(n)}}\equiv{1}\pmod{n}.\tag{3}$$这里 φ(n) 是欧拉函数，这个函数给出了小于 n 且与 n 互素的正整数数目。对于素数 p，<br>$$\varphi{(p)} = p − 1 .$$在这里，由欧拉函数的基本性质 [7]，有：<br>$$\begin{align}\varphi{(n)} &= \varphi{(p)}\cdot{\varphi{(q)}}\\&= (p − 1)\cdot{(q − 1)}\tag{4}\\&= n − (p + q) + 1 .\end{align}$$因为 d 与 φ(n) 互素，, d 在模 φ(n) 的整数环中存在一个逆元 e ：<br>$$e\cdot{d}\equiv{1}\pmod{\varphi{(n)}}. \tag{5}$$我们已经证明了等式 (1) 和 (2) 成立（也就是说，按照上述的方法选择 e 和 d 时，解密算法是正确的）。现在有<br>$$D(E(M))\equiv{(E(M))^d}\equiv{(M^e)^d}\pmod{n}=M^{e\cdot{d}}\pmod{n}$$$$E(D(M))\equiv{(D(M))^e}\equiv{(M^d)^e}\pmod{n}=M^{e\cdot{d}}\pmod{n}$$和<br>$$M^{e\cdot{d}}\equiv{M^{k\cdot{}\varphi{(n)}+1}}\pmod{n}\text{（对于某个整数 k）.}$$从 (3) 可知，对于所有不能被 p 整除的 M ，<br>$$M^{p−1}\equiv{1}\pmod{p}$$并且，因为 (p − 1) 整除 φ(n)<br>$$ M^{k\cdot{}\varphi{(n)}+1}\equiv{M}\pmod{p}.$$当 $M\equiv{0}\pmod{p}$ 时上式亦成立，所以以上相等关系实际上对任何 M 都成立。同理可得，对 q，有<br>$$M^{k\cdot{\varphi{(n)}+1}}\equiv{M}\pmod{q}.$$上述的最后两等式表明，对于任意 M，<br>$$M^{e\cdot{d}}\equiv{M^{k\cdot{\varphi{(n)}+1}}}\equiv{M}\pmod{n}.$$这证明对任意M，0 ≤ M &lt; n，(1) 和 (2) 成立。因此 E 和 D 是逆置换。（上面的证明是 Rich Schroeppel 对作者先前证明的改进版本，我们对他的建议表示感谢。）</p><h2 id="7-算法"><a href="#7-算法" class="headerlink" title="7 算法"></a>7 算法</h2><p>为了证明我们的方法是可行的，我们给出一个高效的算法来完成需要的每一步操作。</p><h3 id="A-如何高效地加密和解密"><a href="#A-如何高效地加密和解密" class="headerlink" title="A 如何高效地加密和解密"></a>A 如何高效地加密和解密</h3><p>使用如下的流程时，计算 M<sub>e</sub>(mod n) 需要最多2 · log<sub>2</sub>(e) 次相乘和 2 · log<sub>2</sub>(e) 次相除（解密类似，只需将 e 换成 d ）：</p><p>步骤 1. 将 $e$ 的二进制表示记作 $e_{k} e_{k−1}\ldots e_{1}e_{0}.$</p><p>步骤 2. 令 $C$ 等于 $1$.</p><p>步骤 3. 对于$ i = k, k − 1,\ldots{}, 0$，重复步骤 3a 和 3b:</p><p>​    ​    步骤 3a. 令 $C$ 等于$C^2$ 被 $n$ 除的余数.</p><p>​    ​    步骤 3b. 如果 $e_i = 1$，那么令 $C$ 等于$C\cdot{M}$ 除以 $n$ 的余数.</p><p>步骤 4. 停止。现在 C 是 M 被加密过的形式。</p><p>这一流程叫做“模重复平方法”。这种流程只有最好方法的一半好；还有更高效的流程。 Knuth [3] 详细地研究了这一问题。</p><p>加密和解密的一致性使得算法的实现更简单。（整个操作可以在几块专用的集成电路芯片上实现。）</p><p>一台高速计算机可以在几秒钟内加密一条 200 位的消息 M；专用硬件会快许多。每个块的加密时间的增长不会快于 n 中数字的位数的立方。</p><h3 id="B-如何寻找大素数"><a href="#B-如何寻找大素数" class="headerlink" title="B 如何寻找大素数"></a>B 如何寻找大素数</h3><p>每位用户必须（私密地）选择两个随机大数 p 和 q 来生成自己的加密和解密密钥。这些数字必须很大，这样才能保证因式分解 n = p · q 是计算上不可行的。（记住，公共文件中保存的是 n 而不是 p 或 q。）我们推荐使用 100 位（十进制）素数 p 和 q，这样 n 有 200 位。</p><p>为了寻找一个 100 位“随机”素数，随机地生成 100 位的奇数直到找到素数。根据素数定理[7]，尝试大约 (ln 10100)/2 = 115 个数字后能找到一个数字。</p><p>为了检验一个大数 b 的素数性，我们推荐使用由 Solovay 和 Strassen 提出的优雅的“基于概率的”算法[12]。这一算法从均匀分布 {1, . . . , b − 1} 中选择随机数 a ，并检查是否有<br>$$gcd(a, b) = 1 \text{和} J(a, b) = a^{(b−1)/2}\pmod{b},\tag{6} $$这里 J(a, b) 是雅可比符号[7]。如果 b 是素数，(6) 总成立。如果 b 是合数，(6) 有至少 1/2 的概率不成立。如果对 100 个随机选择的数值 a，(6) 全都成立，那么几乎可以确定 b 是素数；b 有 2100 分之 1 的可能（微不足道的）是合数。即使我们的系统中意外地使用了一个合数，接收者也很可能会注意到解密不正常，从而发现这一点。当 b 是奇数，a ≤ b，且 gcd(a, b) = 1 时，雅可比符号 J(a, b) 在 {−1, 1} 中取值并且可以通过以下程序高效地计算：<br>$$\begin{align}J(a, b) =&\textbf{if}\;a = 1\;\textbf{then}\;1\;\textbf{else}\\&\textbf{if}\;a\;is\;even\;\textbf{then}\;J(a/2, b)\cdot{}(−1)^{(b^2−1)/8}\\&\textbf{else}\;J(b\pmod{a}, a)\cdot{}(−1)^{(a−1)\cdot{}(b−1)/4}\end{align}$$（J(a, b) 和 gcd(a, b) 的计算也可以得到很好的结合。）注意这一算法并不是通过对因式分解的尝试来测试一个数的素数性。其他高效的测试大数的素数性的程序在 [6,9,11] 中给出。</p><p>为了获得对各种巧妙的因式分解算法的额外防护，p 和 q 应该在长度上相差几位， (p - 1) 和 (q - 1) 都应该包含大素数因子，且 gcd(p − 1, q − 1) 应该很小。可以容易地检查后面的条件。</p><p>为了找到使 (p − 1) 有大素数因子的素数 p ，生成一个随机大素数 u，然后让 p 是序列 i · u + 1，i = 2, 4, 6, . . . . 中的第一个素数（这不会花太长时间）。确保 (u - 1) 也有大素因数可以使得算法更加安全。</p><p>一台高速计算机可以在几秒内判定一个 100 位的数字是否是素数，可以在一两分钟内找到在给定数字之后的第一个素数。</p><p>另一种寻找大素数的方法是从已知的因数分解中取一个合数，加一，然后检验它的素数性。如果找到了素数 p ，用 p - 1 的因式分解来证明它确实是素数这一思路是可行的。因为概率方法已经足够，我们略过这一方法的讨论。</p><h3 id="C-如何选择-d"><a href="#C-如何选择-d" class="headerlink" title="C 如何选择 d"></a>C 如何选择 d</h3><p>选取与 φ(n) 互素的数字 d 十分容易。例如，任何比 max(p, q) 大的素数都符合要求。重要的是，要在足够大的集合中选择 d，这样密码分析者就不能通过直接寻找来找出 d。</p><h3 id="D-如何用-d-和-φ-n-计算-e"><a href="#D-如何用-d-和-φ-n-计算-e" class="headerlink" title="D 如何用 d 和 φ(n) 计算 e"></a>D 如何用 d 和 φ(n) 计算 e</h3><p>为了计算 e，使用下面的欧几里得算法变种来计算 φ(n) 和 d 的最大公因数。（见 [3] 中的练习 4.5.2.15。）通过计算序列 x<sub>0</sub>，x<sub>1</sub>，x<sub>2</sub>……，x<sub>0</sub> ≡ φ(n)， x<sub>1</sub> = d，x<sub>i+1</sub> ≡ x<sub>i−1</sub> (mod x<sub>i</sub>) 直到找到 x<sub>k</sub> 等于 0 ，可以计算gcd(φ(n), d)。这样 gcd(x<sub>0</sub>, x<sub>1</sub>) = x<sub>k−1</sub>。对每个 x<sub>i</sub> 求出 a<sub>i</sub>，b<sub>i</sub> 满足 x<sub>i</sub> = a<sub>i</sub> · x<sub>0</sub> + b<sub>i</sub> · x<sub>1</sub>。如果 x<sub>k-1</sub> = 1 那么 b<sub>k-1</sub> 是x<sub>1</sub> (mod x<sub>0</sub>) 的逆元。因为 k 小于 2 log<sub>2</sub>(n)，这个计算将会十分快速。</p><p>如果 e 最终小于 log<sub>2</sub>(n)，那么选择另一个 d 值重新开始。这保证了每条加密过的消息（除了 M = 0 或 1）经过某种“环绕”（模 n）。</p><h2 id="8-一个小例子"><a href="#8-一个小例子" class="headerlink" title="8 一个小例子"></a>8 一个小例子</h2><p>考虑当 p = 47，q = 59，n = p · q = 47 · 59 = 2773，d = 157 的情况。这时 φ(2773) = 46 · 58 = 2668，e 可以如下地计算：<br>$$\begin{aligned}x_0 &= 2668, & a_0 &= 1, & b_0 &= 0,\\x_1 &= 157, & a_1 &= 0, & b_1 &= 1,\\x_2 &= 156, & a_2 &= 1, & b_2 &= −16 (\text{由于}2668 = 157\cdot{}16 + 156),\\x_3 &= 1, & a_3 &= −1, & b_3 &= 17 (\text{由于}157 = 1\cdot{}156 + 1)\end{aligned}$$因此 e = 17，这是 (mod 2668) 下 d = 157 的逆元。</p><p>已知 n =2773，我们可以按每个块两字母来加密，把每个字母替换成一个两位数：空格 = 00，A = 01，B = 02，……，Z = 26。这样消息</p><p><strong>ITS ALL GREEK TO ME</strong> </p><p>（《裘力斯·凯撒》，第一幕，第二场，288行，改写）被编码为：</p><p>0920 1900 0112 1200 0718 0505 1100 2015 0013 0500</p><p>由于 e = 10001 （二进制），第一个块（M = 920）被编码为：<br>$$M^{17} = (((((1)^2\cdot{}M)^2)^2)^2)^2\cdot{}M = 948\pmod{2273}.$$整条消息被编码为：</p><p>0948 2342 1084 1444 2663 2390 0778 0774 0219 1655 .</p><p>读者可以检查解密的有效性：948157 ≡ 920 (mod 2773)，以此类推。</p><h2 id="9-方法的安全性：密码分析方法"><a href="#9-方法的安全性：密码分析方法" class="headerlink" title="9 方法的安全性：密码分析方法"></a>9 方法的安全性：密码分析方法</h2><p>由于现有的技术不能保证一种加密机制是安全的，唯一可行的检验方法是看看是否有人能找出破解方法。美国国家标准局的标准是用此方法“鉴定”的；IBM 花费了 17 人工作年试图攻破这一机制，毫无结果。一旦一种方法成功抵抗这样一场精心筹划的攻击，在实践中便可以认为此方法是安全的。（事实上，关于 NBS 方法的安全性存在争议 [2]。）</p><p>我们将在下面的部分展示，所有攻击我们系统的明显的方法至少不会比因式分解 n 更容易。尽管大数因式分解在结果验证上不困难，近三百年来已有许多知名数学家致力于解决大数因式分解问题本身。费马（1601?-1665）和勒让德（1752-1833）发现了分解算法；如今的某些更高效算法正是基于勒让德的工作的。然而，正如我们将在下一节中看到的，至今无人发现能在可接受的时间内将一个 200 位数分解的算法。我们认为，我们的系统的安全性已经被前人寻找高效的分解算法付出的努力部分地“鉴定”了。</p><p>在下面的部分中，我们将讨论密码分析者在试图从公开的加密密钥中推断出私密的解密密钥时可能采用的方法。我们将不会讨论怎样使解密密钥不被窃取；一般的物理安全措施应当足够了。（例如，独立的加密设备也可以生成加密和解密密钥，这样解密密钥永远不会被打印出来（甚至不用打印给设备的主人）而是仅用于解密信息。设备也可以在遭篡改时清除解密密钥。）</p><h3 id="A-因式分解-n"><a href="#A-因式分解-n" class="headerlink" title="A 因式分解 n"></a>A 因式分解 n</h3><p>因式分解 n 将让敌方密码分析者能够“破解”我们的方法。他可以通过 n 的因数计算 φ(n)，因而算出 d。幸运的是，因式分解一个数似乎比确定它是素数还是合数更加困难。</p><p>已经有了大量的因式分解算法。Knuth [3, 4.5.4 节] 很好地阐明了其中不少算法。Pollard [9] 提出了在时间 O(n<sup>1/4</sup>) 内因式分解数 n 的一种算法。</p><p>作者已知的最快的因式分解算法是 Richard Schroeppel 提出的（尚未发表） ；这种方法可以在大约<br>$$\begin{align}exp\sqrt{\ln{(n)}\cdot\ln{(\ln{(n)})}}&=n^{\sqrt{\ln{\ln{(n)}}/\ln{(n)}}}\\&=(\ln{(n)})^{\sqrt{\ln{(n)}/\ln{(\ln{(n)})}}}\end{align}$$步骤内因式分解 n（这里 ln 表示自然对数函数）。表 1 给出了对于不同长度的数 n（十进制），用 Schroeppel 的方法因式分解 n 所需的操作的数量，以及当每次操作耗费一微秒时所需的时间。</p><p>表1</p><div class="table-container"><table><thead><tr><th>位数</th><th>操作数</th><th>用时</th></tr></thead><tbody><tr><td>50</td><td>1.4 × 10<sup>10</sup></td><td>3.9 小时</td></tr><tr><td>75</td><td>9.0 × 10<sup>12</sup></td><td>104 天</td></tr><tr><td>100</td><td>2.3 × 10<sup>15</sup></td><td>74 年</td></tr><tr><td>200</td><td>1.2 × 10<sup>23</sup></td><td>3.8 × 10<sup>9</sup> 年</td></tr><tr><td>300</td><td>1.5 × 10<sup>29</sup></td><td>4.9 × 10<sup>15</sup> 年</td></tr><tr><td>500</td><td>1.3 × 10<sup>39</sup></td><td>4.2 × 10<sup>25</sup> 年</td></tr></tbody></table></div><p>我们推荐 n 取大概 200 位长。根据具体应用的加密速度和安全性的相对重要关系，可以使用更长或更短的长度。80 位长的 n 在遭受现有技术水平的攻击时能提供中等的安全性；200 位数 n 则为未来攻击技术的发展留有余地。选择密钥长度（从而选择安全级别）以适应具体应用场景的这种灵活性在许多先前的加密机制（例如美国国家标准局的机制）中是不具备的。</p><h3 id="B-计算-φ-n-而不因式分解-n"><a href="#B-计算-φ-n-而不因式分解-n" class="headerlink" title="B 计算 φ(n) 而不因式分解 n"></a>B 计算 φ(n) 而不因式分解 n</h3><p>如果密码分析者能够计算出 φ(n)，那么他就能通过计算模 φ(n) 下 e 的逆元（使用第 7 节 D 的流程）来计算 d 并攻破密码系统。</p><p>我们可以证明此方法不比因式分解 n 更容易。这是因为此方法使得密码分析者能用 φ(n) 容易地因式分解 n，而这种因式分解 n 的方法在实践中还不可行。</p><p>怎么用 φ(n) 得到 n 的因式分解呢？首先，由 n 和 φ(n) = n - (p + q) + 1 可得 (p + q)。之后，求 (p + q)<sup>2</sup> - 4n 的平方根即为 (p - q)。最后，(p + q) 和 (p - q) 之差的一半就是 q。</p><p>因此通过计算 φ(n) 来攻破我们的系统并不比通过因式分解 n 难度更低。（这就是 n 是合数的理由；如果 n 是素数，计算 φ(n) 轻而易举）</p><h3 id="C-得出-d-而不因式分解-n-或计算-φ-n"><a href="#C-得出-d-而不因式分解-n-或计算-φ-n" class="headerlink" title="C 得出 d 而不因式分解 n 或计算 φ(n)"></a>C 得出 d 而不因式分解 n 或计算 φ(n)</h3><p>显然，为了使得直接搜索不可行，应该从足够大的集合中选择 d。</p><p>我们可以证明密码分析者计算 d 并不比因式分解 n 难度低，因为一旦 d 已知，n 可以容易地被因式分解。这一种因式分解的方法也还没有成果。</p><p>已知 d 时可以用如下方法计算 n。一旦密码分析者知道了 d 后便可计算 e · d−1，这个数是 φ(n) 的倍数。Miller [6] 已经阐明，给出 φ(n) 的任一倍数便可以因式分解 n。因此如果 n 很大，密码分析者应当不能比因式分解 n 更容易地求解 d。</p><p>密码分析者可能希望找到一个 d’ ，使得 d’ 与公钥密码系统用户保密的 d 等价。如果这样数值的 d’ 普遍存在，那么暴力搜索就能攻破系统。然而，所有这样的 d’ 相差 (p-1) 和 (q - 1) 的最小公倍数，并且找到一个这样的 d’ 就能因式分解 n。（在 (3) 和 (5) 中，φ(n) 可以用 lcm(p − 1, q − 1) 来替换。）因此，找到任一 d’ 和因式分解 n 同等困难。</p><h3 id="D-通过某种其他方式计算-D"><a href="#D-通过某种其他方式计算-D" class="headerlink" title="D 通过某种其他方式计算 D"></a>D 通过某种其他方式计算 D</h3><p>尽管“不用因式分解 n 来计算 e 次幂模 n”不像因式分解一样是众所周知的困难问题，我们有理由相信该问题是难以计算的。也许能证明，任何破解我们机制的一般性方法都能导出一种高效的因式分解算法。这将证明，任何破解我们机制的方法一定和因式分解具有同等难度。然而，我们现在还不能证明这一猜想。</p><p>应当让人们共同努力看看能否推翻上述关于难度的猜想，这样才能验证我们的方法。欢迎读者寻找一种方法来“攻破”我们的方案。</p><h2 id="10-避免加密一条签名过的消息时的“重新分块”"><a href="#10-避免加密一条签名过的消息时的“重新分块”" class="headerlink" title="10 避免加密一条签名过的消息时的“重新分块”"></a>10 避免加密一条签名过的消息时的“重新分块”</h2><p>一条签名过的消息可能不得不为加密而“重新分块”，因为签名时用的 n 可能比加密用的 n要大（每位用户有自己的 n）。下面的方法可以避免这一问题。为公钥密码系统选取临界值 h（例如 h = 10<sup>199</sup>）。每位用户维护两个公共的 (e, n) 对，一个用于加密，一个用于签名验证，其中每个签名 n 小于 h，每个解密 n 大于 h。这样就不需要重新分块来解密一条签名过的消息；消息根据发送者的签名 n 来分块。</p><p>另一解决方案使用在 [4] 中给出的一项技术。每位用户有单一的 (e, n) 对，这里 n 在h 和2h 之间，h 和先前相同，是临界值。一条消息被编码为一个小于 h 的数字并和先前一样地加密，如果密文比 h 大，这时将会对密文反复加密直到密文比 h 小。解密时类似，密文被反复解密直到获得的值小于 h。如果 n 接近于 h ，那么不会经常需要反复加密。（不可能出现无限循环，因为最差的情况下一条信息加密得到本身。）</p><h2 id="11-结论"><a href="#11-结论" class="headerlink" title="11 结论"></a>11 结论</h2><p>我们提出了一种通过分解大数的困难性保证安全的方法来实现公钥密码系统。如果我们方法的安全性足够，那么此方法不用信使分发密钥就能建立安全通信，同时允许用户“签名”数字文档。</p><p>特别地，因式分解大数的困难程度应当得到非常严格的检验。我们鼓励读者寻找“攻破”系统的方法。一旦这套系统在足够长的时间中经受住了所有的攻击，人们就应当带着一定的信心来应用。</p><p>我们使用的加密函数是作者所知的唯一“单向陷门函数”。更加理想的是找出这种函数的其他范例，一旦某天我们系统变得不够安全时，能提供额外的实现。未来肯定能发现这类函数的许多新应用场景。</p><p><em>致谢。</em> 我们对Martin Hellman，Richard Schroeppel，Abraham Lempel 和 Roger Needham 带来的有帮助的讨论表示感谢，也感谢 Wendy Glasser 在准备初稿时的帮助。施乐帕克研究中心提供了帮助，在准备终稿时提供我们出色的文本编辑设备。</p><p>1977 年 4 月 4 日投稿；1977 年 9 月 1 日修改。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><p>Diffie, W., and Hellman, M. New directions in cryptography. IEEE Trans. Inform. Theory IT-22, (Nov. 1976), 644-654.</p></li><li><p>Diffie, W., and Hellman, M. Exhaustive cryptanalysis of the NBS data encryption standard. Computer 10 (June 1977), 74-84.</p></li><li><p>Knuth, D. E. The Art of Computer Programming, Vol 2: Seminumerical Algorithms. Addison-Wesley, Reading, Mass., 1969.</p></li><li><p>Levine, J., and Brawley, J.V. Some cryptographic applications of permutation polynomials. Cryptologia 1 (Jan. 1977), 76-92.</p></li><li><p>Merkle, R. Secure communications over an insecure channel. Submitted to Comm. ACM.</p></li><li><p>Miller, G.L. Riemann’s hypothesis and tests for primality. Proc. Seventh Annual ACM Symp. on the Theory of Comptng. Albuquerque, New Mex., May 1975, pp. 234-239; extended vers. available as Res. Rep. CS-75-27, Dept. of Comptr. Sci., U. of Waterloo, Waterloo, Ont., Canada, Oct. 1975.</p></li><li><p>Niven, I., and Zuckerman, H.S. An Introduction to the Theory of Numbers. Wiley, New York, 1972.</p></li><li><p>Pohlig, S.C., and Hellman, M.E. An improved algorithm for computing logarithms over GF(p) and its cryptographic significance. To appear in IEEE Trans. Inform. Theory, 1978.</p></li><li><p>Pollard, J.M. Theorems on factorization and primality testing. Proc. Camb. Phil. Soc. 76 (1974), 521-528.</p></li><li><p>Potter, R.J., Electronic mail. Science 195, 4283 (March 1977), 1160-1164.</p></li><li><p>Rabin, M.O., Probabilistic algorithms. In Algorithms and Complexity, J. F. Traub, Ed., Academic Press, New York, 1976, pp. 21-40.</p></li><li><p>Solovay, R., and Strassen, V. A Fast Monte-Carlo test for primality. SIAM J. Comptng. (March 1977), 84-85.</p></li><li><p>Federal Register, Vol. 40, No. 52, March 17, 1975.</p></li><li><p>Federal Register, Vol. 40, No. 149, August 1, 1975.</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>信息安全数学基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理</title>
    <link href="/2021/12/26/computer-organization/"/>
    <url>/2021/12/26/computer-organization/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="一、计算机系统概论"><a href="#一、计算机系统概论" class="headerlink" title="一、计算机系统概论"></a>一、计算机系统概论</h2><h3 id="1-计算机的分类、发展"><a href="#1-计算机的分类、发展" class="headerlink" title="1. 计算机的分类、发展"></a>1. 计算机的分类、发展</h3><p>电子计算机分哪两类？“电脑”指的是？其中<u>&#x2003;&#x2003;&#x2003;</u>又可进一步分成<u>&#x2003;&#x2003;&#x2003;</u>和<u>&#x2003;&#x2003;&#x2003;</u>。计算机已经经历了五代发展。到目前为止，计算机中所有信息仍以二进制方式表示的理由是（由物理器件的性能决定）。现代计算机已经从以运算器为中心发展到以存储器为中心。<br>冯·诺依曼计算机的主要特点是：（存按单使单）<br>  ▪ 存储程序方式，程序控制；<br>  ▪ 按地址访问，指令顺序执行；<br>  ▪ 单元定长的一维线性空间存储器；<br>  ▪ 使用低级机器语言，数据以二进制表示；<br>  ▪ 单处理机结构，以运算器为中心。<br>改进后的冯·诺依曼计算机使其从原来的以运算器为中心演变为以存储器为中心。从系统结构上讲，主要是通过各种并行处理手段提高计算机系统性能。<br>程序和指令存储器分离的结构叫哈佛体系结构。<br>指令流时间上在取指周期被取出，空间上由内存流向指令寄存器；数据流时间上在执行周期被取出，空间上由内存流向数据寄存器。</p><h3 id="2-性能指标"><a href="#2-性能指标" class="headerlink" title="2. 性能指标"></a>2. 性能指标</h3><p>处理机字长是指处理机运算器中一次能完成二进制数运算的位数，总线宽度一般指 CPU 中运算器与存储器之间进行互连的内部总线二进制位数，存储器带宽是指单位时间从存储器读出的二进制数信息量。主频是时钟周期的倒数。CPI 指<u>&#x2003;&#x2003;&#x2003;</u>，MIPS 指 <u>&#x2003;&#x2003;&#x2003;</u>，FLOPS 指 <u>&#x2003;&#x2003;&#x2003;</u>（科学运算常用）。</p><h3 id="3-计算机硬件"><a href="#3-计算机硬件" class="headerlink" title="3. 计算机硬件"></a>3. 计算机硬件</h3><p>冯诺依曼体系结构分为 <u>&#x2003;&#x2003;&#x2003;</u> 五部分，其中 <u>&#x2003;&#x2003;&#x2003;</u>构成了 CPU。<br>存储器分为 <u>&#x2003;&#x2003;&#x2003;</u> 两部分。主存储器包括 MAR（地址寄存器，存放访存地址）、MDR（数据寄存器，位数等于存储字长，等于一个存储单元中二进制代码位数。注意数据字长形容的对象是数据总线，是数据总线一次并行传送的位数，可以与 MDR 位数不等）、存储体、时序控制逻辑组成。地址寄存器（MAR）、数据寄存器（MDR）是存在于 CPU 中的，但并未集成到运算器与控制器之中。辅助存储器中的信息必须调入主存后才能被 CPU 访问。<br>CPU 和 <u>&#x2003;&#x2003;&#x2003;</u> 构成了主机，除主机外的其他硬件设备叫做 <u>&#x2003;&#x2003;&#x2003;</u>。<br>控制器由程序计数器（PC，位数得能实现一次对存储器中指令的访问，一般和 MAR 相同）、指令寄存器（IR，存放欲执行指令，对汇编程序员不可见）、控制单元（CU）组成。<br>运算器以 ALU 为核心，包含累加器（ACC）、乘商寄存器（MQ）、操作数寄存器（X）以及程序状态计数器（PSW）等若干寄存器。<br>从格式上看，指令可分成 <u>&#x2003;&#x2003;&#x2003;</u> 两部分。把指令和数据存放在同一存储器，按地址访问并顺序执行指令，形成冯诺依曼体系结构。冯诺依曼机最根本的特征即“存储程序”原理（将指令以代码的形式事先输入计算机主存储器，然后按其在主存储器中的首地址执行程序的第一条指令，以后按程序的规定顺序执行其他指令），基本工作方式是控制流驱动方式。将指令、数据分开存放，形成更加快速的哈佛结构。一个字节（B）由 8 位（bit）二进制组成，将一个字的二进制位数叫字长。取指周期中指令流流向控制器（PC-&gt;MAR-&gt;M-&gt;MDR-&gt;IR），执行周期中数据流流向运算器。<br>多个系统部件通过<u>&#x2003;&#x2003;&#x2003;</u>进行数据传送。</p><h3 id="4-计算机软件"><a href="#4-计算机软件" class="headerlink" title="4. 计算机软件"></a>4. 计算机软件</h3><p>计算机软件分为<u>&#x2003;&#x2003;&#x2003;</u>（诊断程序、练习程序、汇编程序、编译程序、解释程序、操作系统、数据库管理系统）和<u>&#x2003;&#x2003;&#x2003;</u>。（数据库管理系统不等于数据库系统，数据库系统甚至包括用户）编译程序与运行系统合称为<u>&#x2003;&#x2003;&#x2003;</u>。语言分为机器语言、汇编语言、高级语言三层。</p><h3 id="5-计算机系统"><a href="#5-计算机系统" class="headerlink" title="5. 计算机系统"></a>5. 计算机系统</h3><p>将程序固定在 ROM 中组成的部件称为固件。软件与硬件在逻辑上是等价的，完整计算机系统由硬件设备与软件系统组成。把计算机系统分为<u>&#x2003;&#x2003;&#x2003;</u>五级。<br>兼容性的对象是软件或硬件，不是软件和硬件之间。</p><p>注意错题：CPU 速度提高 50%，不是速度翻一倍。</p><h2 id="二、运算方法和运算器"><a href="#二、运算方法和运算器" class="headerlink" title="二、运算方法和运算器"></a>二、运算方法和运算器</h2><h3 id="1-数字表示格式"><a href="#1-数字表示格式" class="headerlink" title="1. 数字表示格式"></a>1. 数字表示格式</h3><p>约定最低位是第 0 位。<br>定点数常用于表示整数。<br>十进制数串在计算机内可以用字符串形式表示，也可以用压缩的十进制数串表示（BCD 码、ASCII 码的后四位）。<br>可以对真值使用原码表示法、反码表示法（正数不变，负数符号位不变，其余位取反）、补码表示法。同一数的补码和移码（+2^n-1）表示，符号位相反，其余相同。<br>浮点数的基数是指的指数（阶码）的底数，不管基数是多少，尾数、阶码本身还是二进制表示的。<br>浮点数的规格化表示：当尾数的值不为 0 时，尾数域的最高有效位为 1。引入规格化是为了<u>&#x2003;&#x2003;&#x2003;</u>。<br>IEEE754 浮点数格式：32 位浮点数第 31 位为符号位 S，23-30 位为阶码 E（8 位），0-22 位为尾数 M；64 位浮点数第 63 位为符号位 S，52-62 位为阶码E（exponent，11 位），0-51 位为尾数 M（mantissa）。尾数相当于采用原码表示。阶码采用移码表示，对于 32 位浮点数，其阶码要用真值加上 2^(8-1)-1=127 得到；对于 64 位，这个值是 2^(11-1)-1=1023。采用规格化表示时，由于尾数最高位一定为 1，因此规定不显式地保存这一位。对于 32 位浮点数，E = 255，M ≠ 0 时为 NaN（“错误 Error 拉满（不等于 0）”无定义），E = 255 且 M = 0 时表示无穷大（结合符号位），E = 0 且 M = 0 时为正零或负零，E = 0 且 M ≠ 0 时为非规格化数，此时 N=(-1)^S×(0.M)×2^-126，即尾数前面是 0，阶码取最小的正常阶码 (1-127=-126，我想是因为强行表示超大的数误差太大，不如表示小数)。<br>可以看出，不能正好表示时，浮点数的绝对值越大，其精度越低。</p><h3 id="2-汉字表示方法"><a href="#2-汉字表示方法" class="headerlink" title="2. 汉字表示方法"></a>2. 汉字表示方法</h3><p>汉字的输入编码：用西文标准键盘录入汉字的编码。区位码（十进制）是 94 * 94 二维数组的两个下标。国标码是区位码的十六进制 + 2020H。<br>汉字内码：国标码加上 8080H （把两字节的最高位置为 1 以便于和 ASCII 码的最高位为 0 区分）<br>汉字字模码：点阵显示用</p><h3 id="3-校验码"><a href="#3-校验码" class="headerlink" title="3. 校验码"></a>3. 校验码</h3><p>奇偶校验：增加一位使得整个编码中的 1 的个数为奇数个或偶数个。</p><h3 id="4-定点加法与减法"><a href="#4-定点加法与减法" class="headerlink" title="4. 定点加法与减法"></a>4. 定点加法与减法</h3><p>减法通过取反与最低位全加器进位为 1 来实现。判断是否发生溢出，方法一是采用双符号位（变形补码）：运算后符号位为<u>&#x2003;&#x2003;&#x2003;</u>时说明发生溢出，<u>&#x2003;&#x2003;&#x2003;</u>是正溢，<u>&#x2003;&#x2003;&#x2003;</u>是负溢；<u>&#x2003;&#x2003;&#x2003;</u>位是正确的符号。方法二是单符号位，通过<u>&#x2003;&#x2003;&#x2003;</u>判断。<br>构建加法器，有串行加法器和并行加法器。并行加法器又分为串行进位（行波进位）和并行进位（先行进位）。完全采用并行进位造成电路过于复杂，常采用分组并行进位，组内采用并行快速进位，组间可用串行进位（形成所谓“单级先行进位”），也可用并行快速进位（“多级先行进位”）。<br>由于每一级异或门延迟 3T，其余门延迟 T，n 位行波进位加法器（串行进位的并行加法器）的总延迟为 <u>&#x2003;&#x2003;&#x2003;</u>。</p><h3 id="5-定点乘法"><a href="#5-定点乘法" class="headerlink" title="5. 定点乘法"></a>5. 定点乘法</h3><p>通过斜向进位实现阵列乘法器。（先用 n^2 个与门得出 1 * 1 的乘积，再用 n(n-1) 个全加器）延迟为 <u>&#x2003;&#x2003;&#x2003;</u>。<br>带符号的阵列乘法器，需要算前求补、算后求补。<br>手工运算，正常列竖式即可。</p><h3 id="6-定点除法"><a href="#6-定点除法" class="headerlink" title="6. 定点除法"></a>6. 定点除法</h3><p>不够减时，采用恢复余数法或加减交替法（不恢复余数法）。<br>用 n^2 个可控加法减法单元（CAS）实现阵列除法器。<br>手工运算，要注意写成加法的竖式而不是除法的，让每一列的小数点对齐，“右移”不是直接空出前面的，而是采用算术右移。加减交替法运算，最后的余数为负数时需要恢复。</p><h3 id="7-定点运算器"><a href="#7-定点运算器" class="headerlink" title="7. 定点运算器"></a>7. 定点运算器</h3><p>根据总线所处的位置，将总线分为<u>&#x2003;&#x2003;&#x2003;</u>和<u>&#x2003;&#x2003;&#x2003;</u>，其中内部总线是<u>&#x2003;&#x2003;&#x2003;</u>，外部总线就是（前面介绍的）<u>&#x2003;&#x2003;&#x2003;</u>。<br>运算器大体有 <u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>三种结构形式。</p><h3 id="8-浮点加减运算"><a href="#8-浮点加减运算" class="headerlink" title="8. 浮点加减运算"></a>8. 浮点加减运算</h3><p>浮点加减运算大体分为<u>&#x2003;&#x2003;&#x2003;</u>四步。（也可分为五步）<br>对阶的原则是<u>&#x2003;&#x2003;&#x2003;</u>。浮点数加减是否溢出，关键是对阶后的阶码是否溢出，而不是尾数。运算时尾数如果发生正上溢（进位），要应进行向右规格化（“右规”，尾数进行算术右移）；阶码上溢一般看成<u>&#x2003;&#x2003;&#x2003;</u>，阶码下溢（注意和负上溢的区别）看成<u>&#x2003;&#x2003;&#x2003;</u>。<br>当且仅当浮点数在对阶或向右规格化时需要舍入，可以选择<u>&#x2003;&#x2003;&#x2003;</u>四种舍入处理方法。舍入不一定产生误差，如 11.00 向下舍入到 11.0。<br>对阶不会造成阶码上溢，但尾数舍入可能（1.1111…+1.1111… 右规后阶码加一）<br>注意，算术移位时双符号位只有低符号位需要参与移位；补码左移需要原符号位和原最高有效位相同。</p><h3 id="9-浮点乘除运算"><a href="#9-浮点乘除运算" class="headerlink" title="9. 浮点乘除运算"></a>9. 浮点乘除运算</h3><p>浮点乘除运算不存在对阶问题，有符号浮点乘除法运算分为<u>&#x2003;&#x2003;&#x2003;</u>六步。</p><h3 id="10-浮点运算流水线"><a href="#10-浮点运算流水线" class="headerlink" title="10. 浮点运算流水线"></a>10. 浮点运算流水线</h3><p>流水线能经济地实现时间并行性。把具有线性优先关系的流水线称为<u>&#x2003;&#x2003;&#x2003;</u>。<br>定义 k 级线性流水线的加速比为 <u>&#x2003;&#x2003;&#x2003;</u>，绘制其流水时空图。</p><p>错题：Booth 乘法，11.0011 右移是 11.10011；反码符号位不变；补码不恢复余数除法，异号相除时，够减商 0，不够减商 1；引入规格化是为了提高数据表示的精度；已知x= -0.1001，y=0.1101，试用原码加减交替除法求x/y=？写出计算机的运算过程及运算结果。注意！商是正的！</p><h2 id="三、存储系统"><a href="#三、存储系统" class="headerlink" title="三、存储系统"></a>三、存储系统</h2><h3 id="1-存储系统概述"><a href="#1-存储系统概述" class="headerlink" title="1. 存储系统概述"></a>1. 存储系统概述</h3><p>在现代计算机中，主存储器处于全机的中心位置。<br>构成多级存储系统的依据是<u>&#x2003;&#x2003;&#x2003;</u>（具体解释这一名词：<u>&#x2003;&#x2003;&#x2003;</u>）。内存储器（不包括寄存器）是指 CPU <u>&#x2003;&#x2003;&#x2003;</u>，分为<u>&#x2003;&#x2003;&#x2003;</u>和<u>&#x2003;&#x2003;&#x2003;</u>，后者又分为随机存取存储器（RAM）、只读存储器（ROM）。也就是说，CPU 访问主存可以不经过 cache。辅助存储器（外存储器）中的信息必须调入内存储器后才可以被 CPU 访问。操作系统保存在硬盘上时，内存储器必须采用 RAM+ROM（BIOS 等用于引导）。<br>cache - 主存 层次主要解决 CPU 速度与主存不匹配问题，主存 - 辅存主要解决存储系统容量问题。其中，cache / 主存 系统的效率为单次 cache 访问用时除以平均访问用时。cache 与主存的管理是完全借助硬件的，而主存与辅存的管理则借助<u>&#x2003;&#x2003;&#x2003;</u>。<br>按存取方式，可以把存储器分为随机存取存储器、顺序存取存储器、<u>&#x2003;&#x2003;&#x2003;</u>。磁盘是<u>&#x2003;&#x2003;&#x2003;</u>。<br>如果编址的最小单位是字存储单元，称为按字编址；如果编址的最小单位是字节存储单元，称为按字节编址。当存储字的字长高于 8 位（1 字节）时，称一个存储字内部的字节排列方式为端模式，大端模式是将存储字的最高有效字节（MSB）放入存储体的低地址端（“内存的开头”），小端（x86）则是将存储字的低有效字节（LSB）放入存储体的低地址端。（是根据谁在内存的低地址端，即谁更靠前的）</p><h3 id="2-技术指标"><a href="#2-技术指标" class="headerlink" title="2. 技术指标"></a>2. 技术指标</h3><p>存取时间是指<u>&#x2003;&#x2003;&#x2003;</u>，存储周期（存取周期）是指<u>&#x2003;&#x2003;&#x2003;</u>，存取周期 = 存取时间 + 恢复时间（eg. 破坏性读出）。<br>存储器带宽指单位时间（常指 1s）内存取的信息量，若系统总线宽度为 W 位，则存储器带宽为 W*1s/存取周期。<br>位扩展（扩展位数，一次并行读写更多位，数据线位数增加），字扩展（扩展字数，地址高位用来片选），字位扩展。</p><h3 id="3-静态随机存取存储器（SRAM）"><a href="#3-静态随机存取存储器（SRAM）" class="headerlink" title="3. 静态随机存取存储器（SRAM）"></a>3. 静态随机存取存储器（SRAM）</h3><p>高速缓冲存储器常用 SRAM 构成，不需要刷新；RAM 用 DRAM 构成，需要周期性地刷新。<br>SRAM 是触发器实现，相对 DRAM 成本高，功耗高，速度快，存储密度低。<br>为了写入可靠，写使能信号是最先结束的，其余如片选等可能要延长。</p><h3 id="4-动态随机存取存储器（DRAM）"><a href="#4-动态随机存取存储器（DRAM）" class="headerlink" title="4. 动态随机存取存储器（DRAM）"></a>4. 动态随机存取存储器（DRAM）</h3><p>由于 DRAM 容量大，为减少芯片引脚数量，将地址分为行、列两部分分时传送。<br>写使能在地址变化（信号不稳定）时必须是高电平（高电平无效）。<br>DRAM 破坏性读出，读出后要刷新。刷新以行为单位。此外，由于电容漏电，每隔一段时间必须刷新（称这个时间为刷新周期，通常取 2ms），可采用集中式刷新策略（刷新周期中拿出一段来专门用于刷新所有行，不响应读写请求，故存在访存死区时间，但读写时不受刷新影响，存取速度高）或分散式刷新策略（每次存取后拿出一段时间刷新一行，没有死区，但加长了系统的存取周期，降低了整机的速度；事实上刷新间隔是小于刷新周期的，造成浪费）或异步刷新（每隔 刷新周期/行数 这一时间刷新一行，避免 CPU 连续等待过长时间，且减小刷新次数）。若将刷新安排在不需要访问存储器的译码阶段，则既不会加长存取周期，又不会产生死区时间，称为“透明刷新”。<br>在传统异步 DRAM 上增加时钟信号，是同步 DRAM（SDRAM）最主要的改进。</p><h3 id="5-只读存储器"><a href="#5-只读存储器" class="headerlink" title="5. 只读存储器"></a>5. 只读存储器</h3><p>掩模ROM，一次性编程ROM（PROM），光可擦可编程只读存储器（EPROM），电可擦PROM（E²PROM），闪速存储器（Flash）</p><h3 id="6-并行存储器"><a href="#6-并行存储器" class="headerlink" title="6. 并行存储器"></a>6. 并行存储器</h3><p>为了提高 CPU 与主存之间的数据交换速率，可以在<u>&#x2003;&#x2003;&#x2003;</u>层次提高单个芯片的访问速度（突发传输、同步 DRAM），在<u>&#x2003;&#x2003;&#x2003;</u>层次采用多端口存储器、多体交叉存储器，在<u>&#x2003;&#x2003;&#x2003;</u>层次采用分层存储结构（增加 cache、采用虚拟存储器等）。<br>双端口存储器是<u>&#x2003;&#x2003;&#x2003;</u>并行技术的体现，具有两组相互独立的读写控制电路。当两个端口的地址不相同时，读写不冲突。当两个端口同时存取同一地址，且至少有一个端口进行写操作时，发生读写冲突，这时芯片判断逻辑会对一个端口置 BUSY 标志，暂时关闭此端口的读写。仲裁逻辑有<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>两种判断方式。<br>多模块交叉存储器（多体交叉存储器）是<u>&#x2003;&#x2003;&#x2003;</u>并行技术的体现。当寻址采用<u>&#x2003;&#x2003;&#x2003;</u>时，某一模块出现故障时其他模块可以正常工作，且易于通过增添模块来扩充存储器容量，但带宽有限；<u>&#x2003;&#x2003;&#x2003;</u>寻址将连续地址分配在相邻的不同模块内，提高了存储器带宽。为了实现流水线方式存取，假设模块存取一个字的存储周期为 T，总线传送周期为 τ，存储器的交叉模块数为 m，应当满足<u>&#x2003;&#x2003;&#x2003;</u>，称<u>&#x2003;&#x2003;&#x2003;</u>叫做交叉存取度。</p><h3 id="7-cache-存储器"><a href="#7-cache-存储器" class="headerlink" title="7. cache 存储器"></a>7. cache 存储器</h3><p>若 cache 在 CPU 外，则其控制逻辑常常与主存合在一起。<br>cache 与 CPU 间以<u>&#x2003;&#x2003;&#x2003;</u>为单位进行数据交换，但与主存之间以<u>&#x2003;&#x2003;&#x2003;</u>为单位进行数据交换。cache 的数据块大小称为行，主存的数据块大小称为块，行和块是大小<u>&#x2003;&#x2003;&#x2003;</u>的。一个 cache 行中可能包含若干字，因此地址最低几位常常是块内地址（字地址）。<br>当 CPU 读取内存一个字时，发出内存地址到 cache 和主存，如果字在 cache 中，称为 cache <u>&#x2003;&#x2003;&#x2003;</u>；若不在，称为 cache <u>&#x2003;&#x2003;&#x2003;</u>，此时有两种策略，既可以把字复制到 cache，之后再送给 CPU，也可以同时把字送给 CPU 和 cache。cache/主存 系统的平均访问时间就是平均每次访问内存的用时，而 cache/主存 系统的访问效率 e=<u>&#x2003;&#x2003;&#x2003;</u>。（前面已有这一空）<br>把主存地址映射到 cache 时，有<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>三种方式。全相联映射使用昂贵的相联存储器实现对标记的存储；命中率高、利用率高，但高速比较器电路难于设计实现，适合小容量 cache。直接映射截取地址中间的几位（因为最低位是块内地址）作为 cache 地址，成本低，变换地址快速，但命中率低，冲突频繁，且存在空置问题，适合大容量 cache。组相联映射中组内全相联，组间直接映射，将中间部分最<u>&#x2003;&#x2003;&#x2003;</u>（低/高）的几位作为组号（组号往往从 0 开始），高位作为标记用于比较。每组行数一般取值较小，称 <u>&#x2003;&#x2003;&#x2003;</u> 为 v 路组相联 cache。<br>直接映射 cache 遇到冲突，直接把原主存块换出；全相联映射与直接映射可以采用<u>&#x2003;&#x2003;&#x2003;</u>（使用最少的）、<u>&#x2003;&#x2003;&#x2003;</u>（没使用最多的）、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>四种替换算法。<br>为了与主存内容保持一致，可选用<u>&#x2003;&#x2003;&#x2003;</u>（写 cache 未命中时<u>&#x2003;&#x2003;&#x2003;</u>。显著减少写主存策略，存在数据不一致的隐患）、<u>&#x2003;&#x2003;&#x2003;</u>（写 cache 未命中有 WTWA(<u>&#x2003;&#x2003;&#x2003;</u>)、WTNWA(<u>&#x2003;&#x2003;&#x2003;</u>) 两选择，cache 中无须每行设置一个修改位和判断逻辑，但降低了性能）、<u>&#x2003;&#x2003;&#x2003;</u>（<u>&#x2003;&#x2003;&#x2003;</u>，以便维护系统全部 cache 的一致性）三种写操作策略。</p><h3 id="8-虚拟存储器"><a href="#8-虚拟存储器" class="headerlink" title="8. 虚拟存储器"></a>8. 虚拟存储器</h3><p>为了能在编制程序时独立编址，引入地址转换部件，将用户编制程序时使用的地址（编译程序生成）称为<u>&#x2003;&#x2003;&#x2003;</u>或<u>&#x2003;&#x2003;&#x2003;</u>，对应的存储空间称为<u>&#x2003;&#x2003;&#x2003;</u>或<u>&#x2003;&#x2003;&#x2003;</u>，将物理内存的访问地址称为<u>&#x2003;&#x2003;&#x2003;</u>或<u>&#x2003;&#x2003;&#x2003;</u>，其对应的存储空间称为<u>&#x2003;&#x2003;&#x2003;</u>或<u>&#x2003;&#x2003;&#x2003;</u>。称把虚地址变换为主存的物理地址这一过程为<u>&#x2003;&#x2003;&#x2003;</u>，称把虚地址变换为辅存的物理地址的过程为<u>&#x2003;&#x2003;&#x2003;</u>。虚存是个概念模型，不是实际的存储器。程序的虚地址空间可以远大于实地址空间（提高容量），也可以远小于实地址空间（缩短指令中地址长度）。<br>在三级存储体系中，cache-主存和主存-辅存这两个存储层次的共同点包括：①出发点相同：二者都是为了提高存储系统的性能价格比而构造的层次性存储体系，都力图使存储系统的性能接近高速存储器，而价格接近低速存储器；②原理相同：都是利用了程序运行时的局部性原理把最常用的信息块从相对慢速而大容量的存储器调入相对高速而小容量的存储器；不同点包括：①目的不同：cache 主要解决主存与 CPU 的速度差异问题；而虚存就性能价格比的提高而言主要是解决存储容量的问题（另外还包括存储管理、主存分配和存储保护等方面）；②数据通路不同：CPU 与 cache 和主存之间均有直接通路，cache 不命中时可直接访问主存，而虚存的辅存与 CPU 之间不存在直接的数据通路，当主存不命中时，只能通过调页解决，CPU 最终还是要访问主存；③透明性不同：cache 的管理完全由硬件完成，对系统程序与应用程序均透明，而虚存管理由软件（操作系统）和硬件共同完成，对系统程序不透明，对应用程序透明（段式和段页式管理对应用程序“半透明”）；④未命中时的损失不同：由于主存的存取时间是 cache 的存取时间的 5~10 倍，而辅存的存取时间通常是主存的存取时间的上千倍，故虚存未命中时系统的性能损失要远大于 cache 未命中时的损失。</p><h3 id="9-页式虚拟存储器"><a href="#9-页式虚拟存储器" class="headerlink" title="9. 页式虚拟存储器"></a>9. 页式虚拟存储器</h3><p>页式虚拟存储器中，把虚地址空间分成等长的<u>&#x2003;&#x2003;&#x2003;</u>，相应地把虚地址分成<u>&#x2003;&#x2003;&#x2003;</u>（高字段）和<u>&#x2003;&#x2003;&#x2003;</u>（低字段），把实地址空间分成同样长度的<u>&#x2003;&#x2003;&#x2003;</u>，相应地把实存地址分为<u>&#x2003;&#x2003;&#x2003;</u>（高字段）和<u>&#x2003;&#x2003;&#x2003;</u>（低字段）。大多数系统中每个进程对应一个<u>&#x2003;&#x2003;&#x2003;</u>，把逻辑页号作为偏移地址（即数组下标）时，每个逻辑页在这个表中都有一个记录<u>&#x2003;&#x2003;&#x2003;</u>与指示该逻辑页是否已调入主存的有效位。因此，地址变换时用逻辑页号作为页表数组下标找到相应物理页号，把物理页号作为地址高字段与页内地址拼接即可得到完整的<u>&#x2003;&#x2003;&#x2003;</u>。（物理页号并不对应“页表”）<br>称以上虚地址到主存物理地址的变换表为<u>&#x2003;&#x2003;&#x2003;</u>，而虚地址到辅存物理地址的变换表为<u>&#x2003;&#x2003;&#x2003;</u>。（页表往往指内页表）<br>由于页表在主存中访问页表要多访问一次主存，可以通过把页表中最活跃的部分放入专用于页表缓存的高速存储部件<u>&#x2003;&#x2003;&#x2003;</u>（通常由相联存储器实现）中来缓解这一问题。称转换后援缓冲器为 <u>&#x2003;&#x2003;&#x2003;</u>，而主存中的<u>&#x2003;&#x2003;&#x2003;</u>为<u>&#x2003;&#x2003;&#x2003;</u>。<br>操作系统把某一页移到辅存上时，必须从 cache 中删除该页的内容，同时修改页表和 TLB。<br>最坏的情况下，访问存储器会在<u>&#x2003;&#x2003;&#x2003;</u>产生三次缺失。<br>页式虚拟存储器使得主存利用率高，变址速度快，易于辅存管理，但程序模块化性能差。</p><h3 id="10-段式虚拟存储器"><a href="#10-段式虚拟存储器" class="headerlink" title="10. 段式虚拟存储器"></a>10. 段式虚拟存储器</h3><p>段是按照<u>&#x2003;&#x2003;&#x2003;</u>划分并且长度可以<u>&#x2003;&#x2003;&#x2003;</u>的区域，段式虚拟存储系统中虚地址由<u>&#x2003;&#x2003;&#x2003;</u>和<u>&#x2003;&#x2003;&#x2003;</u>（偏移量）组成，虚地址到主存地址的变换通过<u>&#x2003;&#x2003;&#x2003;</u>实现。每个程序设置一个段表，用段号作为段表的“数组下标”访问段表，段表每一个表项对应一个段，一个段至少包括<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>三个字段。<br>地址变换时，对于每个虚地址，先以<u>&#x2003;&#x2003;&#x2003;</u>为索引访问段表的表项，若<u>&#x2003;&#x2003;&#x2003;</u>，则将虚地址的<u>&#x2003;&#x2003;&#x2003;</u>与表项的<u>&#x2003;&#x2003;&#x2003;</u>相比较，如果不越界，那么<u>&#x2003;&#x2003;&#x2003;</u> 求得主存地址；如果缺段，从辅存中调入，并修改段表。（相加不等于拼接，段式虚拟存储器中没有地址的拼接）<br>段式虚拟存储器段的逻辑独立，便于程序、数据共享、动态链接，但易产生碎片，使得主存利用率低，辅存管理难度大，变址慢。</p><h3 id="11-段页式虚拟存储器"><a href="#11-段页式虚拟存储器" class="headerlink" title="11. 段页式虚拟存储器"></a>11. 段页式虚拟存储器</h3><p>每个程序先分<u>&#x2003;&#x2003;&#x2003;</u>，再分<u>&#x2003;&#x2003;&#x2003;</u>；虚地址由<u>&#x2003;&#x2003;&#x2003;</u> 组成。多任务系统中还有<u>&#x2003;&#x2003;&#x2003;</u>，寻址时用它为下标访问<u>&#x2003;&#x2003;&#x2003;</u>并与虚地址中的段号相加，得到访问段表时的偏移量。<br>兼顾了段页式的优点，但地址变换要多次查表，速度慢。<br>从辅存调页到主存时，如果主存已满，需要进行页面替换，可以采用<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>等算法。</p><p>错题：位扩展 32 片 256K×1 位的 SRAM，构成 256K×32 位；当 CPU 与存储器连接时，可以把较多的地址线、数据线合成一条粗线；主存的第 24 块实际上是 23（从 0 开始）。判断：访问存储器的请求是由 CPU 发出的-&gt;错误，访问存储器的请求可以由 CPU 或 I/O 发出</p><h2 id="四、指令系统"><a href="#四、指令系统" class="headerlink" title="四、指令系统"></a>四、指令系统</h2><h3 id="1-指令系统概述"><a href="#1-指令系统概述" class="headerlink" title="1. 指令系统概述"></a>1. 指令系统概述</h3><p><u>&#x2003;&#x2003;&#x2003;</u>简称指令，一台计算机中所有指令的集合称为<u>&#x2003;&#x2003;&#x2003;</u>（指令集），按指令系统功能构造硬件组织。复杂指令系统计算机（CISC）指令系统庞大，产生浪费，根据 8/2 原则提出了精简指令系统计算机（RISC）。RISC 有三要素，即<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>。<br>使用式子表示时，→右边实际上是比左边少一对括号的，即→右侧默认是地址，但→左侧是数据，需要(地址)。</p><h3 id="2-指令格式"><a href="#2-指令格式" class="headerlink" title="2. 指令格式"></a>2. 指令格式</h3><p>表示一条指令的机器字叫 <u>&#x2003;&#x2003;&#x2003;</u>，简称指令，通常用<u>&#x2003;&#x2003;&#x2003;</u>（OP）和<u>&#x2003;&#x2003;&#x2003;</u>（A）表示。根据指令中的操作数地址个数，将指令称为几操作数指令或几地址指令。三地址指令功能是<u>&#x2003;&#x2003;&#x2003;</u>，适用于<u>&#x2003;&#x2003;&#x2003;</u>的场合，为了加快速度常把地址指定为运算器中通用寄存器的地址，但指令码较长。二地址指令的指令功能是<u>&#x2003;&#x2003;&#x2003;</u>，长度适中，使用方便。其中，按操作数的来源又分为<u>&#x2003;&#x2003;&#x2003;</u>型、<u>&#x2003;&#x2003;&#x2003;</u>型、<u>&#x2003;&#x2003;&#x2003;</u>型指令。一地址指令另一个操作数地址是隐含的，对于只需一个地址的指令而言其指令字长度短。零地址指令不需要操作数。<br>由于机器字长通常与主存单元的位数一致，指令字长度等于机器字长度的指令称为单字长指令，指令字长度等于半个机器字长度的指令称为半字长指令，指令字长度等于两个机器字长度的指令称为双字长指令。指令系统中指令字长度相等时，称为等长指令字结构；否则称为变长指令字结构。为了确保指令字长度尽可能统一，可以采用<u>&#x2003;&#x2003;&#x2003;</u>技术（类似前缀码），如预留出 1111 来扩展操作码的长度。可以对频率较高的指令采用较短的操作码。</p><h3 id="3-操作数的寻址方式"><a href="#3-操作数的寻址方式" class="headerlink" title="3. 操作数的寻址方式"></a>3. 操作数的寻址方式</h3><p>形成操作数有效地址的方式称为操作数的寻址方式。在冯·诺依曼体系结构中，指令的寻址和数据的寻址是交替进行的。<br>称指令中给出的地址为<u>&#x2003;&#x2003;&#x2003;</u>（A），操作数的实际访存地址为<u>&#x2003;&#x2003;&#x2003;</u>（EA）。由于指令中的地址码往往由形式地址和寻址方式特征位等组合而成，因此指令中的地址码通常不是操作数的有效地址。形成操作数有效地址的方法称为操作数的寻址方式。<br>立即寻址中，指令中的地址字段给出的不是操作数地址，而是操作数本身，直观速度快，但不便于更改，不够通用灵活，且操作数的寻址范围受限制。<br>直接寻址中，指令中的地址字段给出操作数的内存地址 A，此时形式地址就是有效地址，因此又称形式地址为直接地址。这样速度快，但寻址范围<u>&#x2003;&#x2003;&#x2003;</u>，且不易修改。有效地址 E=D，操作数 S=(E)=(D)。<br>间接寻址中地址字段给出的是操作数地址的地址，指令格式为 <u>&#x2003;&#x2003;&#x2003;</u> | <u>&#x2003;&#x2003;&#x2003;</u> | <u>&#x2003;&#x2003;&#x2003;</u>。若寻址特征位 I = 0，D 为<u>&#x2003;&#x2003;&#x2003;</u>；I=1，D 为<u>&#x2003;&#x2003;&#x2003;</u>。可以多次间址，一次间址 E=<u>&#x2003;&#x2003;&#x2003;</u>，S=<u>&#x2003;&#x2003;&#x2003;</u>；二次间址 E=<u>&#x2003;&#x2003;&#x2003;</u>，S=<u>&#x2003;&#x2003;&#x2003;</u>。这样扩大了寻址范围，但访存次数多，效率较低，且可能出现无穷间址（死循环）。一般更常用寄存器间址实现扩大寻址范围。<br>寄存器寻址指令中的地址字段给出的是<u>&#x2003;&#x2003;&#x2003;</u>，这样压缩了指令字的长度，有效解决指令码长度短与内存容量大的矛盾，同时加快指令执行速度，能扩大寻址范围，但寄存器有限。此时 S=(R<sub>n</sub>)。<br>寄存器间接寻址与寄存器寻址相似，但此时寄存器中存放的不是<u>&#x2003;&#x2003;&#x2003;</u>，而是<u>&#x2003;&#x2003;&#x2003;</u>。真正的操作数在内存中，E=(R<sub>n</sub>)。<br>偏移寻址是直接寻址与寄存器间接寻址的结合，地址 E=A+(R)，指令中的两个地址字段至少有一个是显式的。具体来说，相对寻址中 EA=<u>&#x2003;&#x2003;&#x2003;</u>，称 A 为相对偏移量，A 可以正可以负；基址寻址中 EA=<u>&#x2003;&#x2003;&#x2003;</u>，在不更改指令内容的情况下，基址是<u>&#x2003;&#x2003;&#x2003;</u>（变/不变）的，而偏移量是<u>&#x2003;&#x2003;&#x2003;</u>（变/不变）的，偏移量的位数相对较短；变址寻址 EA=<u>&#x2003;&#x2003;&#x2003;</u>，形式地址不变，可以用同一条指令来访问数组。变址寻址可以实现程序块的规律变化，而基址寻址可以扩大寻址范围。<br>段寻址实质是一种基址寻址，将段寄存器的基地址<u>&#x2003;&#x2003;&#x2003;</u>后与偏移量<u>&#x2003;&#x2003;&#x2003;</u>得到有效地址。<br>堆栈寻址，将寄存器 Ri 内容压入堆栈时， PUSH Ri 具体执行 <u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u> 操作；POP Ri 具体执行<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>操作。注意堆栈的生长方向与主存地址的关系。<br>隐含寻址的操作数地址是隐含的，如单地址指令。有利于缩短指令字长。</p><h3 id="4-指令的寻址方式"><a href="#4-指令的寻址方式" class="headerlink" title="4. 指令的寻址方式"></a>4. 指令的寻址方式</h3><p>指令的寻址方式有顺序寻址（PC 值 + 1）、跳跃寻址。</p><p>给出一条指令格式，试分析指令格式的特点：①几字长几地址指令②操作码可指定多少指令③二地址的话是 RR 型、RS 型、SS 型。<br>如果问寻址方式的话，需要根据寻址特征位算出可以有几种寻址方式。（2^n）</p><p>错题：注意指令中的地址码划分为几段和几地址指令没有直接关系，偏移寻址也可能是单地址指令（用两个地址字段描述一个地址），最终要看操作数的个数。<br>没有提“寄存器寻址，寄存器间址寻址”这种的，不考虑寻址特征位。<br>题 4-9 CPU 中有 16 个 32 位通用寄存器，设计一种能容纳 64 种操作的指令系统。如果采用通用寄存器作基址寄存器，则 RS 型指令的最大存储空间是多少？</p><h2 id="五、中央处理器"><a href="#五、中央处理器" class="headerlink" title="五、中央处理器"></a>五、中央处理器</h2><h3 id="1-CPU-的功能和组成"><a href="#1-CPU-的功能和组成" class="headerlink" title="1. CPU 的功能和组成"></a>1. CPU 的功能和组成</h3><p>用来使计算机在程序被装入内存储器后能自动地完成取指令、执行指令的任务的部件叫做中央处理器。其基本功能有<u>&#x2003;&#x2003;&#x2003;</u>（保证机器按顺序执行程序）、<u>&#x2003;&#x2003;&#x2003;</u>（产生、管理指令的操作信号）、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>（CPU 的根本任务）。<br>CPU 的核心部件为<u>&#x2003;&#x2003;&#x2003;</u>（又分为<u>&#x2003;&#x2003;&#x2003;</u>部件、<u>&#x2003;&#x2003;&#x2003;</u>部件、<u>&#x2003;&#x2003;&#x2003;</u>部件，具体主要有五个部件，实现了取指令、分析指令、执行指令、中断处理和响应特殊请求）、<u>&#x2003;&#x2003;&#x2003;</u>（ALU、通用寄存器、DR、PSWR，接受 <u>&#x2003;&#x2003;&#x2003;</u> 的命令），基本部分由<u>&#x2003;&#x2003;&#x2003;</u>三大部分组成。<br>CPU 中至少有六类寄存器：<u>&#x2003;&#x2003;&#x2003;</u>（暂时存放由内存读出的一条指令或一个数据字，或向内存存入一条指令或一个数据字时将其暂时放在这里；可以作为 CPU 与内存、外部设备之间信息传送的中转站，或补偿 CPU 和内存、外围设备之间在操作速度上的差别，还可在单累加器结构运算器中作操作数寄存器），<u>&#x2003;&#x2003;&#x2003;</u>（保存<u>&#x2003;&#x2003;&#x2003;</u>的一条指令）、<u>&#x2003;&#x2003;&#x2003;</u>（名字上看起来不像个寄存器）、<u>&#x2003;&#x2003;&#x2003;</u>（保持当前 CPU 访问的地址信息，保证读写操作进行时地址稳定）、<u>&#x2003;&#x2003;&#x2003;</u>（为 ALU 提供工作区，有多个时要进行编址并使通用寄存器堆结构）、<u>&#x2003;&#x2003;&#x2003;</u>（由各种状态条件标志拼凑而成）。<br>把许多寄存器之间传送信息的通路称为数据通路。<u>&#x2003;&#x2003;&#x2003;</u>负责产生取指令和执行指令所需的各种操作控制信号，从而建立数据通路，这种部件可分为时序逻辑型（<u>&#x2003;&#x2003;&#x2003;</u> ）和存储逻辑型（<u>&#x2003;&#x2003;&#x2003;</u>）实现的。时序产生器负责对其产生的操作信号进行时间上的控制，负责控制时钟脉冲的送出与封锁，从而实现启停。<br>当取出一条指令时，指令从 cache 送到 <u>&#x2003;&#x2003;&#x2003;</u>，接下来指令的操作码送入<u>&#x2003;&#x2003;&#x2003;</u>，再送入<u>&#x2003;&#x2003;&#x2003;</u>。</p><h3 id="2-指令周期"><a href="#2-指令周期" class="headerlink" title="2. 指令周期"></a>2. 指令周期</h3><p><u>&#x2003;&#x2003;&#x2003;</u>是取出一条指令并执行这条指令的时间，常常用若干<u>&#x2003;&#x2003;&#x2003;</u>周期（又称<u>&#x2003;&#x2003;&#x2003;</u>周期，通常用<u>&#x2003;&#x2003;&#x2003;</u>规定，也就是说一条指令的取出阶段需要一个<u>&#x2003;&#x2003;&#x2003;</u>周期）数表示。一个 CPU 周期又包含若干<u>&#x2003;&#x2003;&#x2003;</u>（又称 T 周期或节拍脉冲，是<u>&#x2003;&#x2003;&#x2003;</u>）。CPU 执行一个微操作命令（即控制信号）的最小时间单位就是时钟周期。<br>单周期 CPU 在一个时钟周期内完成从取指到执行的所有操作，因此指令执行时间以最长时间的指令为准，效率低；多周期 CPU 在一个时钟周期完成一个阶段的指令执行，不同指令所用周期数可以<u>&#x2003;&#x2003;&#x2003;</u>。<br>机器周期可以是定长或变化的。<br>可以用方框图语言来表示一条指令的指令周期。一个方框花费一个<u>&#x2003;&#x2003;&#x2003;</u>，表示数据通路的操作或某种控制操作，菱形符号不占用单独的 CPU 周期，而是在时间上依附于它前面的一个方框，表示某种判别或测试。末尾的折线符号表示指令执行完后转入<u>&#x2003;&#x2003;&#x2003;</u>。</p><h3 id="3-时序产生器和控制方式"><a href="#3-时序产生器和控制方式" class="headerlink" title="3. 时序产生器和控制方式"></a>3. 时序产生器和控制方式</h3><p>计算机时序采用多级时序体制。时序体制最基本的体制是电位-脉冲制，硬布线控制器中时序信号往往采用主状态周期-节拍电位-节拍脉冲三级体制，微程序控制器中时序信号比较简单，一般采用节拍电位-节拍脉冲两级体制，节拍电位表示一个 CPU 周期的时间。<br>控制器的控制方式常用的有同步控制方式、异步控制方式、联合控制方式三种，同步控制方式中每条指令所需的机器周期数和时钟周期数都是事先固定的（不同的指令可以有统一的机器周期，也可以对某些时间紧张的操作延长机器周期，或采用中央控制与局部控制结合：大部分指令固定机器周期，少数复杂指令采用另外的时序进行计时），异步控制方式中每个操作控制信号需要占用多少时间就占用多少时间，联合控制方式是前两种方式的结合（可以把大部分操作序列安排在固定的机器周期中，对某些时间难以确定的操作则以执行部件的“回答”信号作为结束标志）。</p><h3 id="4-微程序控制器"><a href="#4-微程序控制器" class="headerlink" title="4. 微程序控制器"></a>4. 微程序控制器</h3><p>控制部件通过控制线向执行部件发出的控制命令叫做<u>&#x2003;&#x2003;&#x2003;</u>（如下令打开某个门），执行部件收到后进行的动作叫<u>&#x2003;&#x2003;&#x2003;</u>。受限于数据通路的结构，在同时或同一个<u>&#x2003;&#x2003;&#x2003;</u>周期中可以并行执行的微操作叫做<u>&#x2003;&#x2003;&#x2003;</u> ，而不能在同时或同一个<u>&#x2003;&#x2003;&#x2003;</u>内并行执行的微操作叫<u>&#x2003;&#x2003;&#x2003;</u> 。<br>一组实现一定操作功能的微命令的组合构成一条<u>&#x2003;&#x2003;&#x2003;</u>。微指令可以用二进制代码来表示，微指令分为<u>&#x2003;&#x2003;&#x2003;</u>字段（用于产生微命令）和<u>&#x2003;&#x2003;&#x2003;</u>字段（用于确定下一条<u>&#x2003;&#x2003;&#x2003;</u>的地址，分为<u>&#x2003;&#x2003;&#x2003;</u>字段（确定是否修改下址字段）和<u>&#x2003;&#x2003;&#x2003;</u>字段）。实现机器指令功能的微指令序列叫做<u>&#x2003;&#x2003;&#x2003;</u>。微程序设计技术是用软件方法来设计硬件的一门技术。<br>为了保证机器控制信号的同步，可以把微指令周期时间设计得和 CPU 周期时间相等。一条机器指令对应一个微程序。<br>微程序控制器主要由<u>&#x2003;&#x2003;&#x2003;</u>（只读，存放实现全部指令系统的微程序）、<u>&#x2003;&#x2003;&#x2003;</u> （其中<u>&#x2003;&#x2003;&#x2003;</u>存放将要访问的下一条微指令的地址，<u>&#x2003;&#x2003;&#x2003;</u> 保存微指令的操作控制字段和判别测试字段，不保存下址字段是因为下址字段已经进了微地址寄存器）、<u>&#x2003;&#x2003;&#x2003;</u> （条件转移时修改微地址）三大部分组成。<br>设计微指令结构时，应该追求①有利于缩短微指令字长度；②有利于减小控制存储器的容量；③有利于提高微程序的执行速度；④有利于对微指令的修改；⑤有利于提高微程序设计的灵活性。<br>微命令编码是微指令中的操作控制字段采用的表示方法，通常有<u>&#x2003;&#x2003;&#x2003;</u>（操作控制字段中的每一位代表一个微命令，简单直观，但微指令字较长，使得控制存储器容量较大）、<u>&#x2003;&#x2003;&#x2003;</u> （我想其名字应该是来自译码的逆操作。又叫字段编译法，把 <u>&#x2003;&#x2003;&#x2003;</u> 的微命令信号组成一个小组（字段），通过小组（字段）译码器对每一个微命令信号进行译码，译码输出作为操作控制信号，使得微指令字大大缩短，稍稍减慢微程序的执行速度。注意译码输出要留出一组来表示都没有以上信号，如某一相斥性微命令组包括 8 个微命令，则需要 log<sub>2</sub>8 + 1 = 4 位）、<u>&#x2003;&#x2003;&#x2003;</u>（前两种混合使用）三种方法表示。<br>为了确定下一条微指令的地址，微地址的形成方法中可以采用计数器方式（顺序执行的微指令序列安排在控存的连续单元内，非顺序执行时通过转移方式转去指定地址；顺序控制字段较短，但多路并行转移功能弱）、多路转移方式（在出现分支时按顺序控制字段的判别测试标志和当前的状态条件来选择一个微地址，灵活性好，但需要用组合逻辑方法设计）。<br>微指令的格式分为水平型微指令和垂直型微指令两大类。水平型微指令即为一次定义并执行多个并行操作微命令的微指令，垂直型微指令在微指令中有微操作码字段，由微操作码规定微指令的功能，一条微指令中只有一到两个微操作命令，故同一条机器指令对应的微程序要比水平型微指令中的长。水平型微指令并行操作能力强，效率高，但用户难以掌握；垂直型微指令要经过译码，影响速度，但易于掌握。<br>静态微程序设计中，一条机器指令对应的微程序是不改变的；动态微程序设计采用 EEPROM 作为控制存储器，可以改变微程序。<br>微程序设计步骤：①根据数据通路，写出每条指令的执行过程，画出微程序流程图；②写出每条微指令所发出的微操作控制信号；③按照微指令格式，编写每条微指令的代码；④对照指令的执行流程图，分配微指令的地址；⑤将写好的微指令按分配好的微地址装入控制存储器。</p><p>错题：要多加一个机器周期，实现M-&gt;DR，这一步的微命令是 R/W拔=R。最后记得公操作。</p><h3 id="5-硬布线控制器"><a href="#5-硬布线控制器" class="headerlink" title="5. 硬布线控制器"></a>5. 硬布线控制器</h3><p>把控制部件看作产生专门固定时序控制信号的逻辑电路，形成的由门电路和触发器构成的复杂树形逻辑网络称为硬布线控制器。其速度高于微程序控制器，但设计、调试非常复杂。 </p><h3 id="6-流水-CPU"><a href="#6-流水-CPU" class="headerlink" title="6. 流水 CPU"></a>6. 流水 CPU</h3><p>广义上的并行性既包括同时性，又包括并发性。计算机的并行处理技术主要有时间并行（流水部件，多体交叉存储器）、空间并行（多处理器，双端口存储器）、时间并行加空间并行（超标量流水）。<br>CPU 按流水方式，组织为指令部件、指令队列、执行部件。为了使存储器的存取时间与流水线的其他各过程段的速度匹配，可采用多体交叉存储器；为了解决执行段速度匹配的问题，可以把执行部件分为定点执行部件、浮点执行部件两个可以并行执行的部分，在浮点执行部件中的浮点加法部件和浮点乘除部件并行，同时浮点运算部件以流水线方式工作。<br>只有一条指令流水线的计算机称为标量流水计算机，具有两条以上指令流水线的计算机称为超标量流水计算机。<br>流水线加速比与前面浮点运算相似，为<u>&#x2003;&#x2003;&#x2003;</u>。<br>在流水线运行中，相邻指令间存在某些关系导致不能同时被流水操作，发生断流的现象称为<u>&#x2003;&#x2003;&#x2003;</u>，分为<u>&#x2003;&#x2003;&#x2003;</u>（指令重叠执行时不同指令争用同一功能部件。如取指和取操作数争用内存时，可以将取指操作推迟一周期，或采用双端口存储器，或把数据和指令分开存放）、<u>&#x2003;&#x2003;&#x2003;</u> （必须等前一条指令执行完毕才能执行后一条指令，可以推迟下一指令，或采用数据旁路（内部向前）技术直接把结果传送给下一指令）和 <u>&#x2003;&#x2003;&#x2003;</u> （由转移指令、中断引起，可以采用 <u>&#x2003;&#x2003;&#x2003;</u> （让紧跟在转移指令之后，已进入流水线的少数几条指令 <u>&#x2003;&#x2003;&#x2003;</u> ，而不是排空流水线，这样如果这些指令是与转移指令结果无关的有用指令，则有效地利用了时间）、<u>&#x2003;&#x2003;&#x2003;</u> （依据指令过去的行为，硬件实现选择出现概率高的分支））。其中局部性相关有<u>&#x2003;&#x2003;&#x2003;</u>，全局性相关有<u>&#x2003;&#x2003;&#x2003;</u>。<br>数据相关又可以分为 RAW、WAW、WAR，在相邻的两条指令中，可能同时存在多种数据相关，如 M(B)-&gt;R<sub>6</sub>，(R<sub>6</sub>)*(R<sub>7</sub>)-&gt;R<sub>6</sub>。</p><h2 id="六、总线"><a href="#六、总线" class="headerlink" title="六、总线"></a>六、总线</h2><h3 id="1-总线的基本概念"><a href="#1-总线的基本概念" class="headerlink" title="1. 总线的基本概念"></a>1. 总线的基本概念</h3><p><u>&#x2003;&#x2003;&#x2003;</u>是构成计算机系统的互联机构，是多个系统功能部件之间进行数据传送的公共通路。单处理器系统中的总线大致分为<u>&#x2003;&#x2003;&#x2003;</u>（片内总线，CPU 内部连接各寄存器和运算器等部件之间的总线）、<u>&#x2003;&#x2003;&#x2003;</u>（CPU 同其他高速部件如存储器、通道等互联的总线）、<u>&#x2003;&#x2003;&#x2003;</u>（低速 I/O 设备之间互联的总线）。<br>总线的特性有<u>&#x2003;&#x2003;&#x2003;</u>（总线的物理连接方式，包括根数、插头、引脚排列等）、<u>&#x2003;&#x2003;&#x2003;</u>（描述每根线的功能）、<u>&#x2003;&#x2003;&#x2003;</u>（信号传递方向、电平范围）、<u>&#x2003;&#x2003;&#x2003;</u>（时序关系）。<br>系统总线的<u>&#x2003;&#x2003;&#x2003;</u>使得各厂家不同方法实现的相同功能部件可互换使用。总线带宽指总线本身能达到的最高传输速率，单位 MB/s。</p><h3 id="2-总线的连接方式"><a href="#2-总线的连接方式" class="headerlink" title="2. 总线的连接方式"></a>2. 总线的连接方式</h3><p>通过适配器（简称接口）可以实现高速 CPU 与低速外设之间工作速度上的匹配和同步，并完成计算机和外设之间的所有数据传送和控制。根据连接方式不同，单机系统中总线结构分为<u>&#x2003;&#x2003;&#x2003;</u>（每个设备被指定一个总线地址，外围设备译码器按地址字段决定是否响应；扩展性强，利于扩展成多 CPU 系统，但高速设备和低速设备挂同一总线，且只能一对一对工作，速度受限制，且所有设备与总线接口必须统一）、<u>&#x2003;&#x2003;&#x2003;</u>（高中低速设备连接到不同总线上同时工作，提高效率和吞吐量，且处理器结构的变化不影响高速总线）。<br><u>&#x2003;&#x2003;&#x2003;</u>是具有缓冲、转换、控制功能的逻辑电路。</p><h3 id="3-早期总线内部结构"><a href="#3-早期总线内部结构" class="headerlink" title="3. 早期总线内部结构"></a>3. 早期总线内部结构</h3><p>早期总线是处理器芯片引脚的延伸，由按功能分为<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>三类的信号线组成，其不足之处有<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>。</p><h3 id="4-当代流行的总线结构"><a href="#4-当代流行的总线结构" class="headerlink" title="4. 当代流行的总线结构"></a>4. 当代流行的总线结构</h3><p>当代总线追求与结构、CPU、技术无关的标准。总线控制器完成多个总线请求者之间的协调与仲裁。整个总线分为<u>&#x2003;&#x2003;&#x2003;</u>（由地址线、数据线、控制线组成）、<u>&#x2003;&#x2003;&#x2003;</u>（包括总线请求线和总线授权线）、<u>&#x2003;&#x2003;&#x2003;</u>（包括中断请求线、中断认可线）、<u>&#x2003;&#x2003;&#x2003;</u>（时钟信号线、电源线、地线等）四部分。</p><h3 id="5-总线的信息传送"><a href="#5-总线的信息传送" class="headerlink" title="5. 总线的信息传送"></a>5. 总线的信息传送</h3><p>串行传送通常以第一个脉冲信号表示数码的<u>&#x2003;&#x2003;&#x2003;</u>，每次一位，最后一个脉冲信号表示数码的<u>&#x2003;&#x2003;&#x2003;</u>。可以指定位时间来指定一个二进制位占用的时间长度。串行传送只需一根传输线，成本低，适合远距离传送，但速度慢。<br>并行传送同时传送多位，速度快，但需要更多传输线，适用于近距离部件。出于速度和效率考虑，系统总线上传送的信息必须采用并行传送方式。</p><h3 id="6-总线仲裁"><a href="#6-总线仲裁" class="headerlink" title="6. 总线仲裁"></a>6. 总线仲裁</h3><p>主方（主设备）可以启动一个总线周期，而从方只能响应主方的请求，为了解决多个主设备同时竞争总线控制权的问题，必须有总线仲裁部件，按总线仲裁电路的位置不同，仲裁方式分为<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>两类。<br>集中式仲裁由中央仲裁器对主方的总线请求信号进行裁决，并送出总线授权信号，可采用<u>&#x2003;&#x2003;&#x2003;</u>（总线授权信号串行地在 I/O 接口间传送，直到到达的接口有总线请求；<u>&#x2003;&#x2003;&#x2003;</u>的设备有最高优先级；所需传输线少，便于更改扩充，但对电路故障很敏感，且优先级低的设备可能长期不能使用总线）、<u>&#x2003;&#x2003;&#x2003;</u>（请求总线的设备发送自己的地址，若地址与计数器计数值一致时即获得总线使用权，优先次序可根据计数器的起点来变动（固定优先级、循环优先级），但线数较多）、<u>&#x2003;&#x2003;&#x2003;</u>（响应速度快，不需要一个一个地查询，且优先级灵活，但控制线数目多）三种方式实现，当代总线普遍采用独立请求方式。总线仲裁器又称总线控制器。<br>分布式总裁不需要集中的总线仲裁器，而是每个潜在的主方有仲裁器，请求总线时把仲裁号发送到仲裁总线上后把总线上的号与自己的相比，如果大于自己的，那么请求不予响应。</p><h3 id="7-总线的定时"><a href="#7-总线的定时" class="headerlink" title="7. 总线的定时"></a>7. 总线的定时</h3><p>总线上信息传送大致可分为请求总线、总线仲裁、寻址、信息传送、状态返回五个阶段。为了同步主方、从方的操作，需要制定定时协定。<u>&#x2003;&#x2003;&#x2003;</u>中总线中包含时钟信号线，事件出现在总线上的时间由总线时钟信号决定，大多数事件只占据单一时钟周期。这种方式传输频率较高，但必须按慢的模块来设计公共时钟，各模块存取时间相差很大时会大大损失效率。<u>&#x2003;&#x2003;&#x2003;</u>中后一事件出现在总线上的时刻取决于前一事件的出现时刻，不需要统一的公共时钟信号，建立在应答式或互锁机制之上，总线周期长度可变，但更加复杂。</p><h3 id="8-总线的数据传送模式"><a href="#8-总线的数据传送模式" class="headerlink" title="8. 总线的数据传送模式"></a>8. 总线的数据传送模式</h3><p>常见的有读、写操作，块传送操作，写后读、读修改写操作，广播、广集操作。</p><h3 id="9-PCI-总线"><a href="#9-PCI-总线" class="headerlink" title="9. PCI 总线"></a>9. PCI 总线</h3><p>典型的多总线结构中有<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>三种桥，分别连接<u>&#x2003;&#x2003;&#x2003;</u>总线与<u>&#x2003;&#x2003;&#x2003;</u>总线、<u>&#x2003;&#x2003;&#x2003;</u>总线与<u>&#x2003;&#x2003;&#x2003;</u>总线、<u>&#x2003;&#x2003;&#x2003;</u>总线与<u>&#x2003;&#x2003;&#x2003;</u>总线。HOST 桥又称北桥，HOST 总线是连接北桥和 CPU 之间的数据通路，连接内存控制器、cache 等。PCI 总线是与处理器无关的高速外围总线，是至关重要的层间总线，采用<u>&#x2003;&#x2003;&#x2003;</u>总线定时协定、<u>&#x2003;&#x2003;&#x2003;</u>仲裁策略，基本传输机制是猝发式数据传送机制。<u>&#x2003;&#x2003;&#x2003;</u>是 PCI 总线控制器。<br>读操作时，桥可早于上层总线进行预读；写操作时，桥可以把上层写周期缓存下来进行延迟写。</p><p>错题：计算总线带宽时没有使用 MB/s。</p><h2 id="七、外存与-I-O-设备"><a href="#七、外存与-I-O-设备" class="headerlink" title="七、外存与 I/O 设备"></a>七、外存与 I/O 设备</h2><h3 id="1-外围设备概述"><a href="#1-外围设备概述" class="headerlink" title="1. 外围设备概述"></a>1. 外围设备概述</h3><p>一般来说，外围设备由<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>组成（可以以磁盘为例记忆），外围设备可以分为<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>。</p><h3 id="2-磁盘存储设备"><a href="#2-磁盘存储设备" class="headerlink" title="2. 磁盘存储设备"></a>2. 磁盘存储设备</h3><p>磁盘存储器、磁带存储器均属于磁表面存储器，容量大，位价格低，记录介质可重复使用，断电后可保存信息（“永久性存储器”），一般为顺序存取存储器，但存取速度较慢，机械结构复杂，对工作环境要求高。<br>温彻斯特磁盘机（温盘）是可移动磁头固定盘片的磁盘机，高速旋转的气垫将磁头平稳浮起，防尘性能好，可靠性高，对使用环境要求不高，是最有代表性的硬磁盘存储器。<br>把磁盘片表面称为<u>&#x2003;&#x2003;&#x2003;</u>（最上面盘的上表面和最底下盘的下表面不算，其余两面都是），每个记录面上都有一个磁头，所有记录面上的磁头固定在步进电机上，记录面上一系列同心圆称为<u>&#x2003;&#x2003;&#x2003;</u>（最外面一个称为 <u>&#x2003;&#x2003;&#x2003;</u>），每个磁道又分为若干<u>&#x2003;&#x2003;&#x2003;</u>（虽然外面弧长更长，但仍然按最里面的算），每个区存放相同数量的字或字节。称<u>&#x2003;&#x2003;&#x2003;</u>为磁盘的柱面。磁盘可编址为<u>&#x2003;&#x2003;&#x2003;</u> 。<br>磁盘存储器的存储密度分为道密度、位密度、面密度。道密度是<u>&#x2003;&#x2003;&#x2003;</u>，单位为道/英寸；位密度是磁盘<u>&#x2003;&#x2003;&#x2003;</u>，单位是位/英寸；面密度是<u>&#x2003;&#x2003;&#x2003;</u>，单位为位/英寸²。磁盘存储器的存储容量是其能存储的字节总数，分为非格式化容量（磁表面可以利用的磁化单元总数，注意不同道可以存储的字节数按内圈磁道周长×位密度得出）、格式化容量（计算机系统中按特定格式记录所能存储的容量）。<br>磁盘的寻址时间是<u>&#x2003;&#x2003;&#x2003;</u>，包括<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>，这两个时间往往是变化的，因此常用其平均值表示，平均寻道时间是<u>&#x2003;&#x2003;&#x2003;</u>，平均等待时间是<u>&#x2003;&#x2003;&#x2003;</u>。磁盘的存取时间是从读写命令发出开始到第一笔数据读写所用的时间，包括寻道时间、等待时间、内务操作时间（一般很短，计算时可忽略不计）。故平均存取时间近似等于<u>&#x2003;&#x2003;&#x2003;</u>。总的平均读写时间在平均存取时间上还加上传输时间，即随着盘片的转动把要传送的字节写入花的时间。<br>如果某文件长度超过了一个磁道的容量，应将其记录在同一个<u>&#x2003;&#x2003;&#x2003;</u>，因为不需要重新找道。<br>数据传输率指磁盘存储器在单位时间内向主机传送数据的字节数。外部数据传输率指<u>&#x2003;&#x2003;&#x2003;</u>。内部数据传输率指<u>&#x2003;&#x2003;&#x2003;</u>。</p><h3 id="3-显示设备"><a href="#3-显示设备" class="headerlink" title="3. 显示设备"></a>3. 显示设备</h3><p>分辨率指显示器能表示的像素个数，<u>&#x2003;&#x2003;&#x2003;</u>指黑白显示器中所显示的像素点的亮暗差别，或彩色显示器表示的颜色的不同，如用 8 位表示一个像素，则有 256 级灰度。为了人眼能看到稳定的图像显示，CRT 显示器必须使电子束不断地重复扫描整个屏幕，这一过程称为<u>&#x2003;&#x2003;&#x2003;</u>。按人的视觉生理，刷新频率大于<u>&#x2003;&#x2003;&#x2003;</u>时才不会感到闪烁；一般采用电视的标准，即<u>&#x2003;&#x2003;&#x2003;</u>。把一帧图像存储在<u>&#x2003;&#x2003;&#x2003;</u>（视频存储器或显存）中来提供刷新图像的信号，其存储容量由分辨率与灰度级共同决定。<br>显示字符的方法以<u>&#x2003;&#x2003;&#x2003;</u>为基础。将点阵存入由 ROM 构成的字符发生器中（二进制 0 为空白，1 为填充；二进制高位填入存储器一个字的高位，低位填入低位），构成点阵表示。</p><p>错题：计算盘组容量时直接拿总的磁道数目乘了位密度。</p><h2 id="八、输入输出系统"><a href="#八、输入输出系统" class="headerlink" title="八、输入输出系统"></a>八、输入输出系统</h2><h3 id="1-CPU-与外设之间的信息交换方式"><a href="#1-CPU-与外设之间的信息交换方式" class="headerlink" title="1. CPU 与外设之间的信息交换方式"></a>1. CPU 与外设之间的信息交换方式</h3><p>为了保证高速的主机和不同速度的外设之间的高效和可靠的交互，CPU 必须通过 I/O 接口与外设连接，因此 CPU 的输入输出操作实际上分 I/O 接口与外设间的数据传送，以及 CPU 与 I/O 接口之间的数据传送。为了与 CPU 交互信息的方便，在接口内部一般要设置一些能被 CPU 直接访问的寄存器，称为端口。端口通常有统一编址方式（和内存单元联合在一起编址，不需要专门的 I/O 指令组）、I/O 独立编址方式（内存地址和 I/O 设备地址分开，用专门的 I/O 指令组访问 I/O 设备）。<br>根据外设工作速度的不同，I/O 接口与外设之间数据传送有无条件传送方式（机械开关、发光二极管等速度极慢或简单的外围设备）、应答方式（异步传送方式）（慢速或中速的外围设备，如键盘；如双线握手方式，设置一信号线让发方指示数据是否有效，另一信号线指示收方是否已取走数据）、同步传送方式（高速的外围设备）。<br>CPU 管理外围设备（CPU 对接口）可以采用<u>&#x2003;&#x2003;&#x2003;</u>（只有当接口与外设之间采用无条件传送方式时才能采用）、<u>&#x2003;&#x2003;&#x2003;</u>（CPU 希望接收一个字时，通过接口对目标设备的状态进行查询，如果未准备好，则不断地查询并等待，直到目标设备准备好；CPU 发送数据时类似，不过外设先通过接口发出请求输出信号，CPU 再查询。软硬件结构简单，但 CPU 被外设独占，效率低下，适用于连接低速外设或 CPU 任务不繁忙时）、<u>&#x2003;&#x2003;&#x2003;</u> （外围设备主动通知 CPU 自己准备好了，CPU 暂停现行程序，转向<u>&#x2003;&#x2003;&#x2003;</u>，处理完后返回原来的任务；节省了 CPU 时间，适用于随机出现的服务请求，适合于计算机工作量十分饱满而对 I/O 的实时性要求又较高的系统；但软硬件复杂，服务开销时间大）、<u>&#x2003;&#x2003;&#x2003;</u> （<u>&#x2003;&#x2003;&#x2003;</u>从 CPU 那里接管对总线的控制，数据交换不经过 CPU，直接在内存和外围设备之间进行；传输速度高，但与中断相比需要更多的硬件，适用于内存和高速外围设备之间大批数据交换的场合）、<u>&#x2003;&#x2003;&#x2003;</u>（CPU 将部分权力下放给通道，常用于服务器；高性能处理器配置专门的输入输出处理器（IOP）；与 DMA 相仿，大大提高 CPU 工作效率，但耗费更多硬件，适用于数据传输率高的设备）。<br>综上所述，外围设备的输入/输出方式中，主要由程序实现的有<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>，主要由硬件实现的有<u>&#x2003;&#x2003;&#x2003;</u>、<u>&#x2003;&#x2003;&#x2003;</u>。</p><h3 id="2-程序查询方式"><a href="#2-程序查询方式" class="headerlink" title="2. 程序查询方式"></a>2. 程序查询方式</h3><p>程序查询方式的接口是最简单的，包括设备选择电路（实际上是设备地址的译码器）、数据缓冲寄存器、设备状态标志。程序查询时，先向 I/O 设备发出命令字，请求进行数据交换，再从 I/O 接口读入状态字，如果没有就绪，就继续重复前面的步骤，直至设备准备好后 CPU 从 I/O 接口的数据缓冲寄存器中输入或输出数据并将接口中的状态标志复位。</p><h3 id="3-程序中断方式"><a href="#3-程序中断方式" class="headerlink" title="3. 程序中断方式"></a>3. 程序中断方式</h3><p>中断是一种程序随时切换的方式，分为内中断（机器内部原因导致出错引起的中断，也叫异常）、外中断（外部设备请求服务）。中断的典型应用包括实现 CPU 与外界进行信息交换的握手联络（在速度较慢的外围设备准备自己的数据时 CPU 执行主程序，实现并行工作）、故障处理（硬件故障如掉电、校验错、运算出错，软件故障如溢出、地址越界、非法指令）、实时调度、程序调度（操作系统进行多任务调度的手段）、软中断（程序自愿中断，和子程序调用功能相似）。<br>响应中断需要满足：一条指令执行完毕，转入公操作、中断开放（CPU 内“中断屏蔽”触发器为 0）、外设向 CPU 发出中断请求信号（外设“中断请求”触发器为 1，接口“中断允许”触发器为 1）。<br>当满足响应中断的条件时，CPU 发出中断响应信号并关闭中断（“中断屏蔽”触发器置 1），进入中断响应周期，接着获取中断源对应的中断服务程序入口地址：可以采用<u>&#x2003;&#x2003;&#x2003;</u>方式和<u>&#x2003;&#x2003;&#x2003;</u>方式。在向量中断方式中，中断向量是<u>&#x2003;&#x2003;&#x2003;</u>（有的系统还包括中断服务程序开始执行时的 PSW 初始值），将中断向量保存在<u>&#x2003;&#x2003;&#x2003;</u>，中断向量地址指<u>&#x2003;&#x2003;&#x2003;</u>；当 CPU 识别出某中断源时，硬件直接产生与之对应的<u>&#x2003;&#x2003;&#x2003;</u>并送入 CPU。中断向量方式的优点是中断处理程序可以放在内存任意可放的位置，且便于修改，但需要<u>&#x2003;&#x2003;&#x2003;</u>次访问内存。在查询中断方式中，所有中断服务程序安排一个公共的中断服务程序，在中断响应时由公共的中断服务程序查询中断源，并跳转到相应的中断服务程序人口；利于更灵活地调整优先级。<br>单级中断系统是中断结构中最基本的形式，所有中断源属于同一级，当响应某一中断请求时，<u>&#x2003;&#x2003;&#x2003;</u>（允许/不允许）其他中断源打断中断服务程序，此时中断服务程序分为<u>&#x2003;&#x2003;&#x2003;</u>步骤。（中断周期由硬件实现，响应中断、关中断是在中断服务程序中看不见的，称为“中断处理的隐操作”）<br>多级中断系统中中断源按中断事件轻重缓急分成若干级别，其中在一维多级中断中每一级中断中只有一个中断源，在二维多级中断中每一级中断中有多个中断源。多级中断之间可以实现中断嵌套，但同一级内不同中断源的中断不能嵌套。n 级中断中有 n 个中断屏蔽触发器，总称为中断屏蔽寄存器，是多级中断中重要的程序现场，在响应中断时要把中断屏蔽寄存器中的内容保存起来并设置新的中断屏蔽状态，在某一级中断被响应时要置“1”（关）本级和优先权低于本级的中断屏蔽触发器，清“0”（开放）优先权高于本级的中断屏蔽触发器。和单级中断相似，多级中断中也使用中断堆栈保存现场信息。</p><h3 id="4-DMA-方式"><a href="#4-DMA-方式" class="headerlink" title="4. DMA 方式"></a>4. DMA 方式</h3><p>DMA 方式中<u>&#x2003;&#x2003;&#x2003;</u>从 CPU 接管对<u>&#x2003;&#x2003;&#x2003;</u>的控制，使得数据交换不经过 CPU，但数据传送前的准备工作、传送后的处理工作均由 CPU 程序完成。DMA 方式速度快，CPU 效率高，适用于高速外设与内存交换信息，但功能单一，硬件复杂；可用于磁带、磁盘、光盘等外存储设备接口、网络通信接口、动态存储器刷新、高速数据采集接口。<br>根据每次 DMA 请求时 DMA 控制器将占用多少个总线周期，将 DMA 传送分为<u>&#x2003;&#x2003;&#x2003;</u>（停止 CPU 访存；控制简单，适用于数据传输率高的设备连续传送，但由于外设传送两个数据之间间隔大于内存存储周期，在 DMA 控制器访问内存阶段内存效能不能充分发挥）、<u>&#x2003;&#x2003;&#x2003;</u>（DMA 传送数据时若 CPU 不需要访存，则挪用一两个周期无影响；若 CPU 需要访存，此时<u>&#x2003;&#x2003;&#x2003;</u>优先；较好地发挥内存和 CPU 的性能，但每次 DMA 传送都伴随申请总线控制权、建立总线控制权、归还总线控制权的过程，时间较长，适用于 I/O 设备读写周期大于内存存储周期的情况）、<u>&#x2003;&#x2003;&#x2003;</u>（CPU 周期大于主存存储周期时，把 CPU 周期分为两个分周期，一个专供 DMA 访问主存，一个专供 CPU 访问，提高了 DMA 效率，但 CPU 需要连续访存时需要等待双倍时间，不利于 CPU 效率提高，且外设工作周期是主存工作周期的数十倍，分配给 DMA 访问内存的周期大部分用不上，造成浪费）。<br>当 I/O 设备准备好发送接收数据时，发出 DMA 请求，DMA 控制器向 CPU 发出总线使用权请求，CPU 响应该请求后与总线脱离，DMA 控制器接管总线，发送出内存地址，开始数据交换，每传送一个字都修改发送的内存地址和 DMA 控制器中的字计数器，直至结束。DMA 操作结束后，DMA 控制器向 CPU 发送中断，CPU 进行校验传入的数据、检查是否出错等工作。<br>DMA 与程序中断相比，程序中断实际上是 CPU 的程序切换，而 DMA 则由 DMA 控制器进行数据交换，CPU 让出存储周期；程序中断可完成复杂操作如处理异常事件，而 DMA 只能实现简单的数据加工；程序中断开销大，DMA 以硬件换 CPU 时间；DMA 和程序中断的响应时间不同，CPU 对中断的响应是在执行完一条指令之后，而对 DMA 的响应可以在指令执行过程中的任何两个存储周期之间（因为 DMA 中 CPU 只需要一个存取周期就可以实现 I/O 和主存的通信，所以在一个机器周期结束就可以；但是中断方式需要存储程序断点，所以只能在一个指令的结束才能响应<br>）；DMA 的优先级高于一般的程序中断。</p><p>错题：一次中断处理过程中，最多可有几次关中断和开中断，它们分别是基于什么目的？<br>答：各两次<br>第一次关中断：保证在保存断点和现场的一段时间内，CPU不能响应其他的中断<br>第一次开中断：允许中断嵌套，可以响应优先级更高的中断请求<br>第二次关中断：确保在恢复现场的过程中不响应其他的中断。<br>第二次开中断：现场恢复结束后开中断便于响应新的中断请求。</p><p>部分参考了王道考研《计算机组成原理》。</p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>群、环、域、椭圆曲线</title>
    <link href="/2021/12/15/hackermath-modernalgebraecc/"/>
    <url>/2021/12/15/hackermath-modernalgebraecc/</url>
    
    <content type="html"><![CDATA[<h1 id="群、环、域、椭圆曲线"><a href="#群、环、域、椭圆曲线" class="headerlink" title="群、环、域、椭圆曲线"></a>群、环、域、椭圆曲线</h1><h2 id="一、运算与群"><a href="#一、运算与群" class="headerlink" title="一、运算与群"></a>一、运算与群</h2><ol><li><p>映射？笛卡尔积？<br>设 A 和 B 是两个集合，R 是 A 和 B 之间的元素的对应关系，如果 R 满足：对于 A 中的每一个元素，通过 R 在 B 中都存在唯一一个元素与之对应，则称对应关系 R 为从集合 A 到 B 的映射，其中 A 称为原像集，B 称为像集。集合 A、B 的笛卡尔积为集合 A×B={(x, y)|x∈A, y∈B}。</p></li><li><p>一元运算（本身映射到本身）；二元运算（笛卡尔积到本身的映射）；运算是一元运算还是二元运算的简称？定义域非空 P232</p></li><li><p>什么是运算满足结合律？（要指出是对定义域中任意元素）什么是单位元？零元？什么是可逆元和逆元？（前提是要有单位元）负元？交换律？如何证明单位元是唯一的？ P232<br>（假设存在两个单位元）</p></li><li><p>群的定义（G 本质上是个集合吗）？乘群？加群？群 G 的阶 |G|？有限群和无限群？阿贝尔群？P233<br>（非空集合中的运算满足结合律，单位元，可逆性）</p></li><li><p>半群？交换半群？P232 半群中若有可逆元，则其逆元是唯一的。P233</p></li><li><p>证明：(a<sub>1</sub>…a<sub>i<span style="vertical-align: text-bottom">1</span></sub>)…(a<sub>i<span style="vertical-align: text-bottom">k</span>+1</sub>…a<sub>n</sub>)=a<sub>1</sub>a<sub>2</sub>…a<sub>n-1</sub>a<sub>n</sub> P238<br>（涉及元素个数而且元素最少的时候容易证，可以对元素个数用数学归纳法和分类讨论）</p></li><li><p>如何定义 a<sup>n</sup>？如何定义 a<sup>0</sup> 和 a<sup>-n</sup>？P239</p></li><li><p>什么是子群？符号？什么是平凡子群？（VS：显然因数）什么是真子群？P241<br>（从定义域的子集出发）</p></li><li><p>什么是 G=&lt;a&gt;？什么是 G 的生成元？什么是某元素在群中的阶？（元素的阶和群的阶符号不同）<br>（某元素生成的循环子群的阶称为该元素在群中的阶）</p></li></ol><h2 id="二、环与域"><a href="#二、环与域" class="headerlink" title="二、环与域"></a>二、环与域</h2><ol><li><p>什么叫做环？什么叫做交换环？什么叫有单位元环？P267<br>（环：有加法和乘法运算，对于加法构成交换群，对于乘法满足结合律，乘法对加法满足左右分配律，一个定义涵盖了交换、结合、分配三个词汇）（交换环、有单位元环都是针对乘法运算来说的，毕竟集合对于加法运算已经构成交换群了）</p></li><li><p>什么是域？P271<br>（交换环，有单位元环，非零元均为可逆元，即：对加法构成交换群，非零元对乘法构成交换群）</p></li><li>域的详细定义？P271<br>（即：从运算上展开说对于加法运算构成交换群，非零元对于乘法运算构成交换群，乘法对加法运算满足分配律）</li><li>环的特征？P272<br>（最小；不存在则为 0）<br>群：加减 -&gt; 环：乘 （整数环）-&gt; 域：除（非零元）（有理数、实数、复数域）</li></ol><h2 id="三、椭圆曲线"><a href="#三、椭圆曲线" class="headerlink" title="三、椭圆曲线"></a>三、椭圆曲线</h2><ol><li><p>椭圆曲线的定义？P340<br>（最高的两个三次方系数都是 1；左边有个 xy 混合，除此之外 y 在等号左边，x 在等号右边；奇数项在等号左边，偶数项在等号右边）（本质上是一系列点的集合，注意无穷远点的集合，注意定义域）</p></li><li><p>有限域上的椭圆曲线上的加法运算满足结合律、单位元、可逆性、交换律，即椭圆曲线对于运算“⊕”构成一个交换群。</p></li><li><p>椭圆曲线的离散对数问题：P、Q 为有限域上椭圆曲线点集 E<sub>p</sub>(a, b) 中的元素，且 Q=kP，k 为正整数，对于给定的 k、P，计算 Q 比较容易，而对于给定的 P、Q，计算 k 比较困难。（参考<a href="https://zhuanlan.zhihu.com/p/26029199">这个回答</a>中的动图以形象理解）</p></li><li><p>有限域上椭圆曲线密码体制（ECC）的执行步骤：<br>Alice（或 Bob）选择一个有限域上的椭圆曲线 E<sub>p</sub>(a, b)；<br>Bob 选择 E<sub>p</sub>(a, b) 的元素 G 使得 G 的阶 m 是一个大素数，秘密选择整数 k。计算 P=kG，公开 (p, a, b, G, P)，保密 k。其中 k<sub>b</sub>=P=kG 为 Bob 的公钥，k<sub>b</sub>‘=k为 Bob 的私钥，Bob 将其公钥 k<sub>b</sub> 发送给 Alice。<br>Alice 加密：Alice 将消息 m 编码为 (x, y) 形式的点 P<sub>m</sub>。随机选择一个正整数 r，对 P<sub>m</sub> 产生密文 {rG, C<sub>m</sub>=P<sub>m</sub>+rK<sub>b</sub>}。<br>Bob 解密 C<sub>m</sub>-k<sub>b</sub>‘(rG)=P<sub>m</sub>+rk<sub>b</sub>-krG=P<sub>m</sub>+r(kG)-rkG=P<sub>m</sub>。<br>（Bob 取椭圆曲线，计算公钥 k<sub>b</sub> 为 G 的 k 次连加，Alice 计算公钥的 r 次连加和 G 的 r 次连加并把 G 的 r 次连加累加到明文上得到密文；Bob 把 Alice 发送的公钥的 r 次连加再连加 k 次，从密文中减去得出明文）（G K P P<sub>m</sub> r C<sub>m</sub>）</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>信息安全数学基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>同余与同余式</title>
    <link href="/2021/12/14/hackermath-congruence-modulo/"/>
    <url>/2021/12/14/hackermath-congruence-modulo/</url>
    
    <content type="html"><![CDATA[<h1 id="同余与同余式"><a href="#同余与同余式" class="headerlink" title="同余与同余式"></a>同余与同余式</h1><h2 id="一、概念及性质"><a href="#一、概念及性质" class="headerlink" title="一、概念及性质"></a>一、概念及性质</h2><ol><li>同余的定义？“定义域”？P54 模 m 同余是等价关系吗？P55<br>同余的定义并不直接是其字面意义 ，而是“跨度”为模的整数倍。</li><li>$a_1\equiv{b_1}\pmod{m}$，$a_2\equiv{b_2}\pmod{m}$，则 a<sub>1</sub>+a<sub>2</sub>，b<sub>1</sub>+b<sub>2</sub> 和 a<sub>1</sub>a<sub>2</sub>，b<sub>1</sub>b<sub>2</sub> 之间存在怎样的关系？P56<br>由此，某天是星期三，这天后的 2<sup>2008</sup> 天是星期几？</li><li><p>怎样快速判断某数是否能被 3 或 9 整除？如何借助同余来证明？P57 怎样利用 7×11×13=1001 判断某数是否能被 7，11，13 整除？</p></li><li><p>$d\cdot{a}\equiv{d\cdot{b}}\pmod{m}$，什么条件下 $a\equiv{b}\pmod{m}$？怎么证明？P59<br>“可以直接除去与模互素的公因数”</p></li><li><p>$a\equiv{b}\pmod{m}$，d&gt;0，那么 da 与 db 满足什么关系？P59 反过来，如果 $a\equiv{b}\pmod{m}$，且 a，b，m 有公因数 d，那么能得到怎样的关系？<br>“同余关系可以整体放大和缩小。换言之，在模和被取模的数中都含有的因数无影响”</p></li><li><p>模 m 同余可以推出模 m 的因数同余。模一组数同余可以推出模这一组数的最小公倍数同余。怎么证明？P60 因此，模一组素数同余相当于模这些素数的积同余。<br>证明利用作差可证，因为模谁同余实际上是说的两数之差的性质。</p></li><li><p>$a\equiv{b}\pmod{m}$，那么(a, m) 和 (b, m) 有何关系？证明。<br>（欧几里得除法计算最大公因数）</p></li><li><p>设 m，n，a 都是正整数，如果 $n^{a}\not\equiv{0, 1}\pmod{m}$，那么对于 n 的素因数 p 有何要求？P61</p></li></ol><h2 id="二、模运算"><a href="#二、模运算" class="headerlink" title="二、模运算"></a>二、模运算</h2><p>（笔记补充）</p><ol><li><p>模运算的定义？P61</p></li><li><p>$a+b\pmod{n}=(a\pmod{n}+b\pmod{n})\pmod{n}$。</p></li></ol><h2 id="三、剩余类与完全剩余系"><a href="#三、剩余类与完全剩余系" class="headerlink" title="三、剩余类与完全剩余系"></a>三、剩余类与完全剩余系</h2><ol><li>模 m 的 a 的剩余类 C<sub>a</sub> 的定义？模 m 共有几个<strong>不同</strong>的剩余类？剩余类的剩余（代表元）？任一整数必包含在一个剩余类中吗？所有剩余类的集合怎么用符号表示？模为素数时这个符号还可以怎样表示？P62<br>（由 mZ 诱导的对 Z 的划分）（是<strong>模</strong> m，不要缺字）剩余类实际上是集合。</li><li>什么是 $(\pmb{Z}/m\pmb{Z})^{*}$？对于$C_a, C_b\in(\pmb{Z}/m\pmb{Z})^*$，有$C_{a\cdot{b}}\in{(\pmb{Z}/m\pmb{Z})^*}$。P64<br>（简化剩余类集合）P69</li><li><p>什么是完全剩余系？一个完全剩余系中有几个数？ P63 最小非负完全剩余系、最小正完全剩余系、最大非正完全剩余系、最大负完全剩余系？绝对值最小完全剩余系？P64</p></li><li><p>k 遍历模 m 的完全剩余系，(a, m)=1，经过怎样变换还能得到完全剩余系？证明。P65<br>“一个与模互素的数遍历相乘整个完全剩余系，得到的仍然是完全剩余系”。直接反证作差证明。</p></li><li><p>若 k<sub>1</sub>，k<sub>2</sub> 分别遍历模 m<sub>1</sub>，m<sub>2</sub> 的完全剩余系，且 m<sub>1</sub>，m<sub>2</sub> 满足<u>&#x2003;&#x2003;&#x2003;</u>，则<u>&#x2003;&#x2003;&#x2003;</u>遍历模<u>&#x2003;&#x2003;&#x2003;</u>的完全剩余系。证明？P65<br>（肯定是遍历模 m<sub>1</sub>m<sub>2</sub> 的完全剩余系，因为 k<sub>1</sub> 有 m<sub>1</sub> 个候选项，k<sub>2</sub> 有 m<sub>2</sub> 个候选项。）<br>想证遍历完全剩余系，只需要任取两个数，推导出这两个数不同余即可。<br>“对于互素的m<sub>1</sub>m<sub>2</sub>，m<sub>2</sub> 的完全剩余系中的数与 m<sub>1</sub> 之积和 m<sub>1</sub> 完全剩余系中的数与 m<sub>2</sub> 之积的和遍历 m<sub>1</sub>m<sub>2</sub> 的完全剩余系。”<br>推论：p，q 是两个不同的素数，对任意整数 c，能找出唯一的一对 x，y 使得$q\cdot{x}+p\cdot{y}\equiv{c}\pmod{p\cdot{q}}$。（任意小于两素数之积的整数都可以被这两个素数线性表出）P66</p></li></ol><h2 id="四、简化剩余类、简化剩余系与逆元"><a href="#四、简化剩余类、简化剩余系与逆元" class="headerlink" title="四、简化剩余类、简化剩余系与逆元"></a>四、简化剩余类、简化剩余系与逆元</h2><ol><li><p>简化剩余类、简化剩余的定义？P68 模 m 的简化剩余类的全体组成的集合怎么用符号表示？m 为素数时符号怎么表示？P69</p></li><li><p>若剩余类中的一个剩余与 m 互素，是不是整个剩余类中的剩余均与 m 互素？P68<br>（用欧几里得除法计算最大公因数证明）</p></li><li><p>简化剩余系的定义？P69</p></li><li><p>k 遍历模 m 的某个简化剩余系时，(a, m)=1，ak 也遍历模 m 的一个简化剩余系吗？（和完全剩余系中类似的性质作比较）证明。P70</p></li><li><p>设 m<sub>1</sub>，m<sub>2</sub> 是互素的两个正整数，如果 k<sub>1</sub>，k<sub>2</sub> 分别遍历模 m<sub>1</sub>，模 m<sub>2</sub> 的简化剩余系，则 m<sub>2</sub>k<sub>1</sub>+m<sub>1</sub>k<sub>2</sub> 遍历模 m<sub>1</sub>m<sub>2</sub> 的简化剩余系吗？P72（类似完全剩余系中的性质）证明。（P73引理）</p></li><li><p>逆元的定义？（逆元其实不是在这里定义的）“定义域”？具有唯一性吗？证明？（两种方法，一种是用简化剩余系证其存在性，再证其唯一性；另一种是构造性证明，即用广义欧几里得除法求 a 和 m 的最大公因数，在这个过程中就可以具体地求出逆元的值）</p></li></ol><h2 id="五、欧拉函数、欧拉定理、费马小定理与-Wilson-定理"><a href="#五、欧拉函数、欧拉定理、费马小定理与-Wilson-定理" class="headerlink" title="五、欧拉函数、欧拉定理、费马小定理与 Wilson 定理"></a>五、欧拉函数、欧拉定理、费马小定理与 Wilson 定理</h2><ol><li><p>欧拉函数的定义？p 为素数时 $\varphi(p^\alpha)$ 如何计算？P68</p></li><li><p>模 m 的简化剩余系的元素个数为？P69 简化剩余系判别法？P70</p></li><li><p>欧拉函数的可乘性？证明？P73<br>（利用欧拉函数的值等于简化剩余系中元素的个数这一性质，把两个因数 m，n 的简化剩余系之积转化为类似两组简化剩余系“笛卡尔积”的形式作为 mn 的简化剩余系元素；需要证明这一关系是双射的，上面简化剩余系也要注意双射）</p></li><li><p>已知正整数 m 的标准分解式，如何求其欧拉函数？证明。P73<br>利用可乘性。“一个数的欧拉函数等于其本身连续乘上 1 减去素因子的倒数”。</p></li><li><p>欧拉定理的内容？证明。P77<br>（利用欧拉函数值等于简化剩余系中元素个数的性质，a 乘上最小正简化剩余系得一组简化剩余系，这组简化剩余系中所有元素乘积（构造出 $a^{\varphi(m)}$）与最小正简化剩余系是同余的，移项后把最小正简化剩余系去掉（和 m 互素）即可证明）</p></li><li><p>费马小定理内容，证明。P78<br>有点类似欧拉定理的素数情况。</p></li><li><p>Wilson 定理内容？证明。P79<br>“素数减一的阶乘加一能被素数整除。”（[1, p-1]两两配对，使得其互为逆元）</p></li></ol><h2 id="六、RSA-公钥密码算法"><a href="#六、RSA-公钥密码算法" class="headerlink" title="六、RSA 公钥密码算法"></a>六、RSA 公钥密码算法</h2><p>执行步骤：</p><ol><li>选取两个不同的大素数 p，q；</li><li>计算 n=pq，$\varphi(n)=(p-1)(q-1)$；</li><li>随机选取正整数 e，$1&lt;e&lt;\varphi(n)$，满足$(e, \varphi(n))=1$；</li><li>计算 d，满足 $de\equiv{1}\pmod{\varphi(n)}$；p、q、$\varphi(n)$、d 是保密的，丢弃 p、q、$\varphi(n)$，只保留 n、e、d，(n, e) 公开，(n, d) 为私钥，(n, e) 为公钥。</li><li>加密变换：对明文 a，1&lt;$a$&lt;$n$，加密后的密文为 $c\equiv{a^e}\pmod{n}$；</li><li>解密变换：对密文 c，1&lt;$c$&lt;$n$，解密后的明文为 $a\equiv{c^d}\pmod{n}$。<br>（依次求解 p，q，n，e，d，c，a；注意公钥是 K<sub>e</sub>=(n, e)，私钥是 K<sub>d</sub>=(n, d)）<br>如何证明？P77（a 与 n 互素好说，不互素时 a 只能是其中一个数 q 的倍数而不可能是公倍数，证出 a<sup>q-1</sup>=kq+1，则 a<sup>(p-1)(q-1)</sup>=k’q+1，同乘 a=bp 得证。）</li></ol><p>书写：设 RSA 公钥密码算法使用 26 字符集 {a, b, c …, x, y, z} = {0, 1, 2, …, 23, 24, 25}，明文信息空间是由 2 字符构成的集合 {aa, ab, ac, …,  zx, zy, zz}，以两字符一组对 “de” 进行编码。</p><h2 id="七、模重复平方计算法"><a href="#七、模重复平方计算法" class="headerlink" title="七、模重复平方计算法"></a>七、模重复平方计算法</h2><p>可以用于计算大底数、相对小指数的模运算，例如 $12996^{227}\pmod{37909}$。<br>把指数 n 展开成 2 的幂之和，令 a<sub>i</sub> 表示已经取模乘到 b<sup>2<span style="vertical-align: text-top">i</span></sup> 的积；b<sub>i</sub> 表示 $b^{2^i}\pmod{m}$；a<sub>0</sub>=0，如果 2<sup>i</sup> 在 n 展开为 2 的幂的和的式子里系数为 0，那么 a<sub>i</sub>=a<sub>i-1</sub>，如果系数为 1 则 $a_i=a_{i-1}\cdot{b_i}\pmod{m}$；计算 $b_{i+1}=b_i^2\pmod{m}$，如此循环。<br>查看<a href="https://github.com/zhaozihanzzh/Mathematical-Fundamentals-for-Information-Security/blob/master/FastModularExponentiation.py">参考代码</a>。</p><p>但是，如果计算的是 $2^{20046118}\pmod{7}$ 此类小底数、大指数的模运算，那么直接应用 $2^3\pmod{7}=1$ 更加合适。</p><h2 id="八、同余式与中国剩余定理"><a href="#八、同余式与中国剩余定理" class="headerlink" title="八、同余式与中国剩余定理"></a>八、同余式与中国剩余定理</h2><ol><li>同余式的定义？什么是次数 deg<em>f</em>（要满足什么条件）？什么是同余式的一个解？为什么同余式的解 a 常写成 $x\equiv{a}\pmod{m}$ ？什么是同余式的解数？P91<br>（模 m 同余于 0 的 n 多项式；之所以要同余于 0 是因为这个多项式已经自带常数项了）</li><li><p>模 m 的可逆元和逆元有何不同？P92</p></li><li><p>设 m<sub>1</sub>，m<sub>2</sub>，…，m<sub>k</sub> 是两两互素的正整数，那么同余式组<br>$$\begin{cases} \begin{align} x &\equiv{b_1}\pmod{m_1} \\ &\vdots \\ x &\equiv{b_k}\pmod{m_k} \end{align} \end{cases}$$一定有唯一解吗？将其解用构造和递归两种方法表示。（背不过递归的话，可以从它的推导入手，现场推导）P97<br>给出其构造证明（先证明其是唯一的，即解必然位于同一剩余类中；再把已知的解代入方程组中，验证这个解是满足所有方程的）（P99）和递归证明（即“归纳构造”）（从 k=2 入手，关键是借助逆元求出 y<sub>1</sub>；然后假设 i-1 时命题成立，像对待 k=2 一样地求解，即可证明；每次把新一代的式子用上一代求出来的解和这次式子里已知的表示，这才起到递归的作用；注意 x≠x<sub>n-1</sub>，但 x=x<sub>n</sub>）（P101）。<br>查看<a href="https://github.com/zhaozihanzzh/Mathematical-Fundamentals-for-Information-Security/blob/master/ChineseRemainderTheorem.py">参考代码</a>。</p></li></ol><h2 id="九、二次同余式与平方剩余"><a href="#九、二次同余式与平方剩余" class="headerlink" title="九、二次同余式与平方剩余"></a>九、二次同余式与平方剩余</h2><ol><li><p>二次同余式的一般形式？P125</p></li><li><p>a 是模 m 的平方剩余（二次剩余）是什么意思？a 是模 m 的平方非剩余呢（也要满足前式的“定义域”条件）？P125</p></li><li><p>什么是欧拉判别条件？要求 m 是什么样的数？P129</p></li><li><p>什么是勒让得符号？“定义域”？P131 欧拉判别法则可以用勒让得符号怎么改写？P132</p></li></ol><h2 id="十、离散对数与-Diffie-Hellman-密钥共享算法"><a href="#十、离散对数与-Diffie-Hellman-密钥共享算法" class="headerlink" title="十、离散对数与 Diffie-Hellman 密钥共享算法"></a>十、离散对数与 Diffie-Hellman 密钥共享算法</h2><ol><li>离散对数是什么？P79，P191<br>（为了实现在 [1, $\varphi(m)$]内唯一，需要满足原根和互素 ）</li><li>Diffie-Hellman 密钥共享算法步骤：P79<br>Alice 选取素数 p 和正整数 g，1≤g≤p 且 (g, p)=1，公开 p 和 g。<br>Alice 选取 x∈{1, 2, …, p-1}，计算 $R_1=g^x\pmod{p}$，并将 R<sub>1</sub> 发送给 Bob。<br>Bob 选取 y∈{1, 2, …, p-1}，计算 $R_2=g^y\pmod{p}$ 并将 R<sub>2</sub> 发送给 Alice。<br>Eve 可以获得 R<sub>1</sub> 和 R<sub>2</sub>，但很难计算出 x 或 y （离散对数求解困难）。<br>Alice 计算密钥 $k=R_2^x\pmod{p}=(g^y)^x\pmod{p}=g^{xy}\pmod{p}$，Bob 计算密钥 $k=R_1^y\pmod{p}=(g^x)^y\pmod{p}=g^{xy}\pmod{p}$。<br>（分别把 g<sup>x</sup>，g<sup>y</sup> 发送给对方，结合对方手里掌握的另一半信息，双方都能得到一样的密钥）<br>查看<a href="https://github.com/zhaozihanzzh/Mathematical-Fundamentals-for-Information-Security/blob/master/Diffie-Hellman.py">参考代码</a>。</li></ol>]]></content>
    
    
    <categories>
      
      <category>信息安全数学基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>整数的可除性</title>
    <link href="/2021/12/06/hackermath-int-divisibility/"/>
    <url>/2021/12/06/hackermath-int-divisibility/</url>
    
    <content type="html"><![CDATA[<h1 id="整数的可除性"><a href="#整数的可除性" class="headerlink" title="整数的可除性"></a>整数的可除性</h1><h2 id="一、整除的概念"><a href="#一、整除的概念" class="headerlink" title="一、整除的概念"></a>一、整除的概念</h2><ol><li><p>什么是 b 整除 a 或 a 被 b 整除？因数、倍数的定义？对“定义域”有什么要求？什么是不整除？</p></li><li><p>若 c|a，c|b，那么 c|(sa+tb)吗？</p></li><li><p>对于一个数而言，什么是显然因数？素数和合数的定义？没有特别声明时素数总是指正整数。什么是安全素数？什么是索菲热尔曼素数？</p></li><li><p>n 为正合数，p 是大于 1 的 n 的最小正因数，那么 p 有怎样的性质？怎么证明？</p></li><li><p>爱拉托斯散筛法是怎么筛出素数的？什么是素数的平凡判别？<br>查看<a href="https://github.com/zhaozihanzzh/Mathematical-Fundamentals-for-Information-Security/blob/master/Eratoshenes.py">参考代码</a>。</p></li><li><p>证明素数有无穷多个？</p></li><li><p>欧几里得除法（对于最小非负余数）、不完全商、余数定义？怎么证明（存在性，唯一性）？怎么证明一般余数形式的欧几里得除法？注意最小非负余数和最小正余数。<br>查看求商、余数<a href="https://github.com/zhaozihanzzh/Mathematical-Fundamentals-for-Information-Security/blob/master/P49T16.py">参考代码</a>。</p></li><li><p>什么是 x 的整数部分？</p></li></ol><h2 id="二、最大公因数"><a href="#二、最大公因数" class="headerlink" title="二、最大公因数"></a>二、最大公因数</h2><ol><li><p>公因数、最大公因数、互质的定义。(0, b) 是多少？a = qb + c 和最大公因数有什么关系，以及这一关系有什么定义域要求？如何证明这一关系？<br>如果素数不是另一整数的因数，那么这两数互素。</p></li><li><p>有哪个算法是用来求解最大公因数的？证明此算法。P23。可以用哪种余数来简化计算？P24<br>查看<a href="https://github.com/zhaozihanzzh/Mathematical-Fundamentals-for-Information-Security/blob/master/EuclideanAlgorithmGCD.py">参考代码</a>。</p></li><li><p>什么是贝祖等式？贝祖等式怎么用来判断互素？怎么证明贝祖等式？（个人认为可以参考百度百科）怎么求其中的 s，t？P25 ad-bc=1 时 a，b，c，d 满足什么关系？P33<br>查看<a href="https://github.com/zhaozihanzzh/Mathematical-Fundamentals-for-Information-Security/blob/master/P28Principle137.py">参考代码求 s、t</a>。</p></li><li><p>当正整数 d 满足：(i) d|a，d|b (ii) 若 e|a，e|b，则 e|d ；那么 d =(a, b) 是充要的吗？如何证明？P33</p></li><li><p>m 是正整数时，(m·a, m·b) 等于？<script type="math/tex">(\frac{a}{d},\frac{b}{d})</script> 在<u>&#x2003;&#x2003;&#x2003;</u>条件下可以进行哪种变形？怎么证明？P33</p></li><li><p>当 (a, c) = 1 时 (ab, c) 等于？如何证明？P34<br>“加入互素成分不影响最大公因数”</p></li><li><p>如果 (a<sub>i</sub>, c) = 1，那么 (a<sub>1</sub>a<sub>2</sub>…a<sub>n</sub>, c) 等于多少？证明。P35（我觉得可以用标准分解式）</p></li><li><p>a=qu+rv，b=su+tv，qt-rs=1 时 (a, b) 和 (u, v) 有什么关系？P35</p></li><li><p>如何递归计算多个整数的最大公因数？P36</p></li><li><p>当 a 和 b 是两个正整数时，2<sup>a</sup>-1 和 2<sup>b</sup>-1 的最大公因数是多少？证明。（提示：往指数的对应关系+广义欧几里得算法上靠）P37</p></li><li><p>c|ab，(a, c)=1，那么 c 和 b 存在什么关系？证明。P37<br>“扣去互素成分不影响是否是因数”</p></li><li><p>p 是素数，p|a<sub>1</sub>a<sub>2</sub>，能得什么？扩展到 a<sub>n</sub> 呢？证明。P38<br>“两数之积能被素数整除，则这两数必有一个能被素数整除。”<br>上面部分证明主要用 d|a，a|d → a=d，存在 s，t 使得 sa+tb=(a,b)</p></li></ol><h2 id="三、最小公倍数"><a href="#三、最小公倍数" class="headerlink" title="三、最小公倍数"></a>三、最小公倍数</h2><ol><li>公倍数的定义？最小公倍数的定义？P38<br>“最小公倍数是其他公倍数的因数，最大公因数是其他公因数的倍数”</li><li>[ma, mb] 在什么时候等于 m[a, b]？怎么证明？P39，P50T39<br>证明，利用最小公倍数的定义。</li><li>[a, b]，ab 和 (a, b) 有什么关系？怎么证明？<br>（共有的成分在最小公倍数里只计算入一次，即要从乘积里面扣除去最大公因数）</li></ol><h2 id="四、算术基本定理"><a href="#四、算术基本定理" class="headerlink" title="四、算术基本定理"></a>四、算术基本定理</h2><ol><li><p>什么是算术基本定理？怎样证明？P42</p></li><li><p>什么是 n &gt; 1 整数的标准分解式？P43；d 是 n 的正因数，则其标准分解式之间存在什么关系？是充要的吗？证明。P44；某个数的正因数个数和其标准分解式之间存在什么关系？P44；两数的最大公因数和最小公倍数与其标准分解式有什么关系？怎么证明？P45；多个数呢？</p></li><li><p>是否能找出 a 的因数 a’，b 的因数 b’ 且 a’，b’ 互素，使得 [a, b]=a’b’？证明。P46<br>（对于两数都有的成分，要删去一边）</p></li></ol><h2 id="五、整数的表示"><a href="#五、整数的表示" class="headerlink" title="五、整数的表示"></a>五、整数的表示</h2><ol><li>正整数 n 在什么条件下能用 b 的 0 到 k-1 次幂线性表出？这种表示具有怎样的性质？怎样证明？P9<br>（证明和欧几里得除法有些类似）</li><li><p>什么是整数 n 的 b 进制表示？</p></li><li><p>怎样进行进制转换？</p></li><li><p>怎样进行 b 进制加、减、乘法运算？</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>信息安全数学基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>十大常见的内部排序算法</title>
    <link href="/2021/10/06/algo-ten-internalsort/"/>
    <url>/2021/10/06/algo-ten-internalsort/</url>
    
    <content type="html"><![CDATA[<h1 id="十大常见的内部排序算法"><a href="#十大常见的内部排序算法" class="headerlink" title="十大常见的内部排序算法"></a>十大常见的内部排序算法</h1><p>所谓内部 (Internal) 排序，是指在计算机的主存而非外存中进行的排序。<br>所谓稳定 (Stable) 的排序算法，是指排序完后大小相等的元素的相对位置能保持不变。在以某一键值进行排序时（如基数排序），稳定性是十分重要的。<br>所谓原地排序算法 (In-place Sorting Algorithm)，是指除了函数调用所需的栈和固定数目的实例变量之外无序额外内存的排序算法。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="《算法（第 4 版）》P154">[1]</span></a></sup></p><h2 id="Part-1-排序算法介绍"><a href="#Part-1-排序算法介绍" class="headerlink" title="Part 1 排序算法介绍"></a>Part 1 排序算法介绍</h2><p>在这里，我们以从小到大排序为例介绍这些算法，所有的排序都在数组中进行：</p><h3 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1. 选择排序"></a>1. 选择排序</h3><p>选择排序 (Selection Sort) 思路是每次选择最小的元素交换到已经排好的部分的末尾。实现起来较为简易。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selection_sort</span><span class="hljs-params">(T* start, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> scale)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; scale - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-type">int</span> min_index = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; scale; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (start[j] &lt; start[min_index]) &#123;<br>                min_index = j;<br>            &#125;<br>        &#125;<br>        T exchange = start[i];<br>        start[i] = start[min_index];<br>        start[min_index] = exchange;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>选择排序是不稳定的排序算法：1 2 <strong>7</strong> <em>7</em> 3 -&gt; 1 2 3 <em>7</em> <strong>7</strong><br>选择排序的时间复杂度在一般情况下为 O(n<sup>2</sup>)，不存在更好或更差的情况。<br>空间复杂度为 O(1)，是原地排序算法。</p><h3 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h3><p>插入排序 (Insertion Sort) 思路类似按高矮排队时新来了一个人的情况，这个人站到队尾后便开始与前面比他高的人不停地交换位置。元素越有序，对插入排序就越有利。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertion_sort</span><span class="hljs-params">(T* start, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> scale)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; scale; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &gt; <span class="hljs-number">0</span> &amp;&amp; start[j] &lt; start[j - <span class="hljs-number">1</span>]; --j) &#123;<br>            T temp = start[j];<br>            start[j] = start[j - <span class="hljs-number">1</span>];<br>            start[j - <span class="hljs-number">1</span>] = temp;<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><br>交换元素时不会改变相同元素的相对顺序，故插入排序是稳定的排序算法。<br>插入排序平均时间复杂度为 O(n<sup>2</sup>)，最好情况下（元素全部有序）时间复杂度为 O(n)，这是内层循环条件不满足；最坏情况是完全逆序时，这时需要把每次遍历到的元素交换到最开头。<br>空间复杂度为 O(1)，是原地排序。</p><h3 id="3-冒泡排序及其改进"><a href="#3-冒泡排序及其改进" class="headerlink" title="3. 冒泡排序及其改进"></a>3. 冒泡排序及其改进</h3><p>冒泡排序 (Bubble Sort) 的思路是每次将未排序元素中最小或最大的交换到一端，形似因密度不同而不断冒出的气泡。由于每次都挑出最值，因此每挑出一次，下一次的最值就是上次的次最值，排在上次挑出值的后面。要注意挑出的最值位于遍历方向的末尾。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">original_bubble_sort</span><span class="hljs-params">(T *data, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; len - i; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (data[j] &gt; data[j - <span class="hljs-number">1</span>]) &#123;<br>                std::<span class="hljs-built_in">swap</span>(data[j], data[j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>冒泡排序是稳定的排序算法，由于交换的是相邻的元素，不会有相等的元素越过对方。<br>冒泡排序时间复杂度为 O(n<sup>2</sup>)，空间复杂度为 O(1)，属于原地排序。</p><p>但这还没完，冒泡排序显然还有优化的空间：</p><h4 id="1-有序时停止"><a href="#1-有序时停止" class="headerlink" title="1. 有序时停止"></a>1. 有序时停止</h4><p>在已经有序（即一轮比较后不发生任何交换）的情况下，可以停止排序了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">timelystop_bubble_sort</span><span class="hljs-params">(T *data, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-type">bool</span> has_exchange = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; len - i; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (data[j] &gt; data[j - <span class="hljs-number">1</span>]) &#123;<br>                std::<span class="hljs-built_in">swap</span>(data[j], data[j - <span class="hljs-number">1</span>]);<br>                has_exchange = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!has_exchange) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>此时，最好情况下（已有序）时间复杂度为 O(n)。</p><h4 id="2-确定有序边界"><a href="#2-确定有序边界" class="headerlink" title="2. 确定有序边界"></a>2. 确定有序边界</h4><p>从全部有序的情况出发，进一步地，如果数组只是末尾有序，虽然不能直接退出排序，但可以省掉末尾的部分（开头有序没法省去，因为要从里面挑元素往后移动，即使开头的元素有序了，那也不是它们最终的位置）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">skipsorted_bubble_sort</span><span class="hljs-params">(T *data, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    <span class="hljs-type">int</span> border = len;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-type">int</span> last_exchange = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; border; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (data[j] &lt; data[j - <span class="hljs-number">1</span>]) &#123;<br>                std::<span class="hljs-built_in">swap</span>(data[j], data[j - <span class="hljs-number">1</span>]);<br>                last_exchange = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (last_exchange == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        border = last_exchange;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时最好的时间复杂度为 O(n)。</p><h4 id="3-鸡尾酒排序"><a href="#3-鸡尾酒排序" class="headerlink" title="3. 鸡尾酒排序"></a>3. 鸡尾酒排序</h4><p>鸡尾酒排序 (Cocktail Sort) 是“来回”的冒泡排序。传统的冒泡排序在升序时，最小元素在数组末尾会一点一点往上冒，而最大元素在起始却一趟就冒过去了。为了更好地平衡，可以在顺序冒一趟后倒序再来。这里我们直接在上面确定有序边界版本的冒泡排序上作修改：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">skipsorted_cocktail_sort</span><span class="hljs-params">(T *data, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    <span class="hljs-type">int</span> last_exchange = <span class="hljs-number">0</span>, first_exchange = len;<br>    <span class="hljs-type">int</span> max_border = len, min_border = <span class="hljs-number">0</span>; <span class="hljs-comment">// 两个都取不到</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = min_border + <span class="hljs-number">1</span>; j &lt; max_border; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (data[j] &lt; data[j - <span class="hljs-number">1</span>]) &#123;<br>                std::<span class="hljs-built_in">swap</span>(data[j], data[j - <span class="hljs-number">1</span>]);<br>                last_exchange = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (last_exchange == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = last_exchange - <span class="hljs-number">1</span>; j &gt; min_border; --j) &#123;<br>            <span class="hljs-keyword">if</span> (data[j] &lt; data[j - <span class="hljs-number">1</span>]) &#123;<br>                std::<span class="hljs-built_in">swap</span>(data[j], data[j - <span class="hljs-number">1</span>]);<br>                first_exchange = j - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (first_exchange == len) <span class="hljs-keyword">break</span>;<br>        max_border = last_exchange;<br>        min_border = first_exchange;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h3><p>希尔排序 (Shell Sort，以发明者的名字命名) 又称递减增量排序 (Diminishing Increment Sort)，它使用插入排序先使数组中任意间隔 h 的元素有序，然后按照一定的序列减小 h （要求 h 最后要以 1 结尾）并按减小的 h 排序。这里，我们使用 1/2(3<sup>k</sup>-1) 作为希尔排序的递增序列，递增到小于数组长度的最大值，然后每次除以 3，直到等于 1：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shell_sort</span><span class="hljs-params">(T* start, <span class="hljs-type">int</span> scale)</span> </span>&#123;<br>    <span class="hljs-type">int</span> span = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (span &lt; scale / <span class="hljs-number">3</span>) span = <span class="hljs-number">3</span> * span + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (span &gt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = span; i &lt; scale; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &gt;= span &amp;&amp; start[j] &lt; start[j - span]; j-= span) &#123;<br>                T temp = start[j];<br>                start[j] = start[j - span];<br>                start[j - span] = temp;<br>            &#125;<br>        &#125;<br>        span = span / <span class="hljs-number">3</span>;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><br>希尔排序交换元素时会跨越一部分元素，因此可能改变相等元素的相对位置，是不稳定的排序算法：<strong>3</strong> <em>3</em> 1 -&gt; 1 <em>3</em> <strong>3</strong><br>希尔排序的时间复杂度似乎是无法准确描述的。这里给出的算法在最坏情况下的时间复杂度为 O(1.5)，空间复杂度为 O(1)，是原地排序。</p><h3 id="5-归并排序及其改进"><a href="#5-归并排序及其改进" class="headerlink" title="5. 归并排序及其改进"></a>5. 归并排序及其改进</h3><p>归并排序 (Merge Sort) 是通过将已经排序好的两个小的子数组合并成大的数组实现的，传统上，归并排序需要一个辅助数组，在排序通过双指针时判断是把哪个小数组中的元素加入。这里我们用自顶向下的方法，先分割，直到无法再分割，然后通过函数栈的顺序调用来合并。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MergeSorts</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> T* auxiliary;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(T* start, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left_cursor = low,<br>            right_cursor = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 指向第一个没加入的元素</span><br>        <span class="hljs-keyword">if</span> (start[mid] &lt;= start[mid + <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果已经满足有序，直接返回</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = low; i &lt;= high; ++i) &#123;<br>            auxiliary[i] = start[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = low; i &lt;= high; ++i) &#123;  <span class="hljs-comment">// 设计好循环的次数，保证不越界</span><br>            <span class="hljs-keyword">if</span> (left_cursor &gt; mid)<br>                start[i] = auxiliary[right_cursor++];  <span class="hljs-comment">// 左边全加进去了加右边</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right_cursor &gt; high)<br>                start[i] = auxiliary[left_cursor++];  <span class="hljs-comment">// 右边全加进去了加左边</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (auxiliary[left_cursor] &gt; auxiliary[right_cursor])<br>                start[i] = auxiliary[right_cursor++]; <span class="hljs-comment">// 否则就比左右大小决定</span><br>            <span class="hljs-keyword">else</span><br>                start[i] = auxiliary[left_cursor++];  <span class="hljs-comment">// 注意排序稳定性（元素相等时）</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 注意 low 和 high 能不能取到：这里都能取到</span><br>    <span class="hljs-comment">// 如果 low 和 high 相等，直接返回，保证 merge 函数 low 和 high 差至少为 2；</span><br>    <span class="hljs-comment">// 差 1 的时候 mid 与 low 相等，mid + 1 与</span><br>    <span class="hljs-comment">// high 相等，不重叠</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">merge_sort_TD</span><span class="hljs-params">(T* start, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (high &lt;= low)<br>            <span class="hljs-keyword">return</span>;                        <span class="hljs-comment">// Only one in selection.</span><br>        <span class="hljs-type">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// Ensure mid &lt;= high</span><br>        <span class="hljs-built_in">merge_sort_TD</span>(start, low, mid);<br>        <span class="hljs-built_in">merge_sort_TD</span>(start, mid + <span class="hljs-number">1</span>, high);<br>        <span class="hljs-built_in">merge</span>(start, low, mid, high);<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">merge_sort_TopDown</span><span class="hljs-params">(T* start, <span class="hljs-type">int</span> scale)</span> </span>&#123;<br>        auxiliary = <span class="hljs-keyword">new</span> T[scale];<br>        <span class="hljs-built_in">merge_sort_TD</span>(start, <span class="hljs-number">0</span>, scale - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">delete</span>[] auxiliary;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; T* MergeSorts&lt;T&gt;::auxiliary;<br></code></pre></td></tr></table></figure><p>类似地，还有自底向上的归并排序，从最小单元开始逐步增大小数组的长度来合并：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">merge_sort_UpBottom</span><span class="hljs-params">(T* start, <span class="hljs-type">int</span> scale)</span> </span>&#123;<br>    auxiliary = <span class="hljs-keyword">new</span> T[scale];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> sub_length = <span class="hljs-number">1</span>; sub_length &lt; scale; sub_length *= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> left_cursor = <span class="hljs-number">0</span>; left_cursor &lt; scale - sub_length; left_cursor+= <span class="hljs-number">2</span> * sub_length) &#123;<br>            <span class="hljs-built_in">merge</span>(start, left_cursor, left_cursor + sub_length - <span class="hljs-number">1</span>, std::<span class="hljs-built_in">mi</span>(left_cursor + <span class="hljs-number">2</span> * sub_length - <span class="hljs-number">1</span>, (scale - <span class="hljs-number">1</span>)));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] auxiliary;<br>&#125;<br></code></pre></td></tr></table></figure><br>这样看，归并排序是稳定的排序算法，归并时子数组的相对位置不改变，相等的元素也可以按照先后顺序并入最后的答案中。<br>如果采用树形结构描述归并排序的递归流程，由于每“层”中各次操作加起来（例如调用前 1/4，上 1/4，下 1/4，末 1/4）都得比较整个数组一遍，而有大约 log<sub>2</sub>n 层（递归深度），故一般的时间复杂度为 O(nlogn)。考虑到针对有序子数组的优化，最好的情况下比较是 O(n) 的。<br>需要额外数组，空间复杂度为 O(n)。<br>但归并排序也有优化空间，可以通过在每层遍历时交换输入原数据的数组和辅助数组来减少归并时的数组复制：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// std::swap 会交换指针指向的对象，需要自己的交换函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap_ptr</span><span class="hljs-params">(T *&amp; a, T *&amp; b)</span> </span>&#123;<br>    T *temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(T* start, T* auxiliary, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left_cursor = low,<br>        right_cursor = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 指向第一个没加入的元素</span><br>    <span class="hljs-comment">//if (start[mid] &lt;= start[mid + 1])</span><br>    <span class="hljs-comment">//    return;  //  不能使用这样的优化，因为在 auxiliary 和 start 交换优化时这两个数组根本不相等，没法把 auxiliary 写回</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = low; i &lt;= high; ++i) &#123;  <span class="hljs-comment">// 设计好循环的次数，保证不越界</span><br>        <span class="hljs-keyword">if</span> (left_cursor &gt; mid)<br>            start[i] = auxiliary[right_cursor++];  <span class="hljs-comment">// 左边全加进去了加右边</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right_cursor &gt; high)<br>            start[i] = auxiliary[left_cursor++];  <span class="hljs-comment">// 右边全加进去了加左边</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (auxiliary[left_cursor] &gt; auxiliary[right_cursor])<br>            start[i] = auxiliary[right_cursor++];<br>        <span class="hljs-keyword">else</span><br>            start[i] = auxiliary[left_cursor++];  <span class="hljs-comment">// 否则就比左右大小决定</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort_TD</span><span class="hljs-params">(T* start, T* auxiliary, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (high &lt;= low)<br>        <span class="hljs-keyword">return</span>;                        <span class="hljs-comment">// Only one in selection.</span><br>    <span class="hljs-type">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// Ensure mid &lt;= high</span><br>    <span class="hljs-built_in">merge_sort_TD</span>(auxiliary, start, low, mid);<br>    <span class="hljs-built_in">merge_sort_TD</span>(auxiliary, start, mid + <span class="hljs-number">1</span>, high);<br>    <span class="hljs-built_in">merge</span>(start, auxiliary, low, mid, high);<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort_TopDown</span><span class="hljs-params">(T* start, <span class="hljs-type">int</span> scale)</span> </span>&#123;<br>    T *auxiliary = <span class="hljs-keyword">new</span> T[scale];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; scale; ++i) &#123;<br>        auxiliary[i] = start[i];<br>    &#125;<br>    <span class="hljs-built_in">merge_sort_TD</span>(start, auxiliary, <span class="hljs-number">0</span>, scale - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">delete</span>[] auxiliary;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h3><p>快速排序 (Quick Sort) 被誉为是“20世纪对科学和工程领域的发展产生最大影响力的十大算法”<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.sciencenet.cn/blog-83029-468247.html">[2]</span></a></sup>，在快速排序中对给定的范围需要选定一个切分元素（“轴”元素 pivot），接下来保证比它大的元素在切分元素后面，比它小的在前面，不断缩小范围，直到完成排序。这就好像给 N 个班混在一起的考试卷分开一样，先大体上分成几小堆，再继续分（先忽略那个 <code>move_pivot_to_first</code> 函数）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">part</span><span class="hljs-params">(T* start, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-built_in">move_pivot_to_first</span>(start, left, right);<br>    <span class="hljs-type">int</span> l_cursor = left, r_cursor = right + <span class="hljs-number">1</span>;<br>    T partition = start[left];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">while</span> (start[++l_cursor] &lt; partition) <span class="hljs-keyword">if</span> (l_cursor == right) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">while</span> (start[--r_cursor] &gt; partition) ;<span class="hljs-comment">/*if (r_cursor == left) break;*/</span><br>        <span class="hljs-keyword">if</span> (l_cursor &gt;= r_cursor) <span class="hljs-keyword">break</span>;<br>        std::<span class="hljs-built_in">swap</span>(start[l_cursor], start[r_cursor]);<br>    &#125;<br>    std::<span class="hljs-built_in">swap</span>(start[left], start[r_cursor]);<br>    <span class="hljs-keyword">return</span> r_cursor;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(T* start, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> <span class="hljs-comment">/* 闭区间 */</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (right &lt;= left) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> partition = <span class="hljs-built_in">part</span>(start, left, right);<br>    <span class="hljs-built_in">quick_sort</span>(start, left, partition - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quick_sort</span>(start, partition + <span class="hljs-number">1</span>, right);<br>&#125;<br></code></pre></td></tr></table></figure><br>每次进行切分的步骤是：规定切分元素是某段数组的首个元素，略过数组首个元素，向右移动左指针，直到它不小于切分元素大小或达到右边界，这时左指针以左全是小于切分元素的值；向左移动右指针，直到它不大于切分元素（不用检查是不是到了左边界，左边最前面就是切分元素，最坏情况会停在切分元素上），这时它右边的值全部大于切分元素；检查左右指针相对位置，如果有重叠，说明已经完成切分，此时把首个元素和右指针指向元素进行交换即可（为什么交换右指针指向元素？因为首个元素在左侧，交换后必须保证它小于等于切分元素，而此时左指针已经移出小于切分元素值的区域了，可能指向的是第一个大于切分元素值的元素）；如果不重叠，直接交换左右指针指向的元素，再继续进行这一步骤。<br>完成切分之后，返回切分元素的位置（右指针），这样就把数组切成两小段，再继续切分。<br>由此可见，如果选择的切分元素大小处在待排序元素的中位数附近，那么两个子数组长度接近，可以使得递归的深度更小（接近 log N），每层合计需要遍历所有元素，则其时间复杂度为 O(nlog n)。然而，如果每次切分所选择的都是最大或者最小的元素——如这个数组本来就是有序的，那么递归的深度为 N，此时整个排序过程成为 O(N<sup>2</sup>) 的时间复杂度，这显然是我们不希望的。因此，一味地选取数组首个元素作为切分元素是不合适的，在这里我们采用三取样切分，取首个元素下一位，中间，末尾三个值的中位数与数组首个元素交换以减少最坏情况的发生（这里参考了 gcc 11.1.0 的 <code>std::__move_median_to_first</code> 函数）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move_pivot_to_first</span><span class="hljs-params">(T *array, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-type">int</span> middle = (right - left) / <span class="hljs-number">2</span> + left; <span class="hljs-comment">// 防 int 溢出</span><br>    <span class="hljs-keyword">if</span> (array[left + <span class="hljs-number">1</span>] &lt; array[right]) &#123;<br>        <span class="hljs-keyword">if</span> (array[right] &lt; array[middle])  &#123;<br>            std::<span class="hljs-built_in">swap</span>(array[left], array[right]);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (array[middle] &lt; array[left + <span class="hljs-number">1</span>]) &#123;<br>            std::<span class="hljs-built_in">swap</span>(array[left], array[left + <span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        std::<span class="hljs-built_in">swap</span>(array[left], array[middle]);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (array[left + <span class="hljs-number">1</span>] &lt; array[middle]) &#123;<br>        std::<span class="hljs-built_in">swap</span>(array[left + <span class="hljs-number">1</span>], array[left]);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (array[middle] &lt; array[right]) &#123;<br>        std::<span class="hljs-built_in">swap</span>(array[right], array[left]);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    std::<span class="hljs-built_in">swap</span>(array[middle], array[left]);<br>&#125;<br></code></pre></td></tr></table></figure><br>可以看出，快速排序对于随机性强的数据更有优势，而对于已经部分有序的数据，则不能利用这种有序性。快速排序是原地排序算法，但我们的实现版本需要递归，当每次切分元素都较为均匀时，递归深度接近 log<sub>2</sub>N，此时空间复杂度为 O(log N)（由于栈是先入后出的，此时递归二叉树的另一半还没有长出来，另一半生长出来时左边已经释放了，而我们只考虑同一时间占用的最大内存）；当每次切分元素都是两端的元素时，空间复杂度达到了 O(n)。此外，快速排序是不稳定的排序算法，如果左右指针指向的元素大小相同，并且他们被分别切到了左右两边，那么这对元素仍然会被交换位置。</p><h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h3><p>堆排序 (Heap Sort) 的一种实现方法是为元素创建最大堆，每次取出堆顶最大元素并移动到数组的最后，从而得到有序数组。在建堆过程中，由上而下进行有序化，保证节点大于其儿子节点的过程成为下沉 (sink)；由下而上进行有序化，保证节点小于其父亲的过程称为上浮 (swim)。在输入数组中构造堆时，可以自顶向下推进，依次把末尾的新节点上浮，也可以自底向上，依次把新节点下沉。自底向上建堆时，可以把后一半的节点（叶子节点）省掉，且插入大量底部节点时树高较小，插入少量顶部节点时树高较大，更加合理，但判断与哪个儿子交换时会略微复杂。我们采用自底向上建堆的方法建立最大堆。之后，我们将堆顶的元素与最后一个元素交换，这时最后一个元素是最大元素，我们把它排除在堆外，即令堆的大小减 1，再从堆顶进行下沉操作，得到新的最大堆，再取堆顶与倒数第二个元素交换，这样一直进行下去：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* Make sure that the pointer start points at the top of the heap, </span><br><span class="hljs-comment">otherwise we can&#x27;t access the children by 2 * start_position + 1/ + 2 */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sink</span><span class="hljs-params">(T *start, <span class="hljs-type">int</span> start_position,  <span class="hljs-type">int</span> scale)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span> &gt;= scale) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * start_position + <span class="hljs-number">2</span> &gt;= scale) &#123; <span class="hljs-comment">/* only left child */</span><br>            <span class="hljs-keyword">if</span> (start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span>] &gt; start[start_position]) &#123;<br>                T temp = start[start_position];<br>                start[start_position] = start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span>];<br>                start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span>] = temp;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span>] &gt; start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">2</span>]) &#123; <span class="hljs-comment">/* left child bigger than right*/</span>          <br>            <span class="hljs-keyword">if</span> (start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span>] &gt; start[start_position]) &#123; <span class="hljs-comment">/* left bigger than father */</span><br>                T temp = start[start_position];<br>                start[start_position] = start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span>];<br>                start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span>] = temp;<br>                start_position = <span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">/* right child bigger than left */</span><br>        <span class="hljs-keyword">if</span> (start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">2</span>] &gt; start[start_position] <span class="hljs-comment">/* right child bigger than father*/</span>) &#123;<br>            T temp = start[start_position];<br>            start[start_position] = start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">2</span>];<br>            start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">2</span>] = temp;<br>            start_position = <span class="hljs-number">2</span> * start_position + <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">(T *start, <span class="hljs-type">int</span> length)</span> </span>&#123;<br>    <span class="hljs-comment">// firstly build heap</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> sink_start = length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; sink_start &gt;= <span class="hljs-number">0</span>; --sink_start) &#123;<br>        <span class="hljs-built_in">sink</span>(start, sink_start, length);<br>    &#125;<br>    <span class="hljs-comment">// secondly swap the top elem with the last and sink the top again</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; length; ++i) &#123;<br>        T top = *start;<br>        *start = *(start + length - i);<br>        *(start + length - i) = top;<br><br>        <span class="hljs-built_in">sink</span>(start, <span class="hljs-number">0</span>, length - i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>建堆时我们自底向上地建堆，假设这个堆有 N = 2<sup>k</sup>-1 个元素，建立自底向上第 i 层时共有 $\frac{N+1}{2^i}$ 个元素，每个元素下沉时最多比较 2(i-1) 次，总比较次数 $\sum_{i-1}^{\log_{2}(N+1)}{\frac{N+1}{2^i}\cdot{}{2(i-1)}}$ ，经错位相减求和可知，建堆需要 O(n) 时间复杂度；每次删除最大元素后的调整是 log n 级别的，全部删除元素需要 O(nlog n) 时间复杂度，故整个堆排序的时间复杂度为 O(nlog n)。但是，堆排序比较大小的数据（儿子节点、父亲节点）在内存中常常不连续，而快速排序访问连续的数据的比重更大，根据局部性原理，快速排序对 cache 等利用效率更高，要更快一些。<br>堆排序是原地排序，空间复杂度为 O(1)。堆排序也不是稳定的排序算法：9 <em>4</em> <strong>4</strong> -&gt; <strong>4</strong> <em>4</em>  9<br>R.W. Floyd 提出<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="《算法（第 4 版）》P208">[3]</span></a></sup>，由于建堆后数组末尾的元素均是较小的元素，它们在交换到堆顶后大概率还会下沉到很靠近堆底的部分，在每次取出最大元素后可以先另外暂存占用的数组末尾的那个元素，然后从堆顶开始，把较大的儿子节点覆盖到堆顶，再把大儿子的大儿子节点覆盖大儿子，一直到堆底，这时再把暂存的元素放到停下来的位置，从这里开始做上浮操作，这样能避免传统方法（从堆顶下沉）中不必要的比较大小（不用把堆顶和左右节点比较了），虽然看起来额外增加了一段路程，但总体上是减少了比较次数的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swim</span><span class="hljs-params">(T *start, <span class="hljs-type">int</span> node_pos)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (node_pos) &#123;<br>        <span class="hljs-keyword">if</span> (start[(node_pos - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>] &lt; start[node_pos]) &#123;<br>            T temp = start[node_pos];<br>            start[node_pos] = start[(node_pos - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>];<br>            node_pos = (node_pos - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            start[node_pos] = temp;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_sort_floyd</span><span class="hljs-params">(T *start, <span class="hljs-type">int</span> length)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> sink_start = length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; sink_start &gt;= <span class="hljs-number">0</span>; --sink_start) &#123;<br>        <span class="hljs-built_in">sink</span>(start, sink_start, length);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; length; ++i) &#123;<br>        T end = *(start + length - i);<br>        *(start + length - i) = *start;<br>        <span class="hljs-type">int</span> new_pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &gt;= length - i) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">2</span> &gt;= length - i) &#123; <span class="hljs-comment">// only left child</span><br>                <span class="hljs-comment">//if (start[new_pos * 2 + 1] &gt; start[new_pos]) &#123;</span><br>                    start[new_pos] = start[new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>                    new_pos = new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//&#125;</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (start[new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &gt; start[new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>]) &#123;<br>                start[new_pos] = start[new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>                new_pos = new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                start[new_pos] = start[new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>];<br>                new_pos = new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        start[new_pos] = end;<br>        <span class="hljs-built_in">swim</span>(start, new_pos);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8. 计数排序"></a>8. 计数排序</h3><p>计数排序（Counting Sort）可以通过用元素值直接访问数组来统计比某个元素小的元素的个数，从而得出元素排序后的数组下标来实现排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">counting_sort</span><span class="hljs-params">(T *start, <span class="hljs-type">int</span> elem_num, <span class="hljs-type">int</span> array_size)</span> </span>&#123;<br>    <span class="hljs-type">int</span> *times = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[array_size];<br>    <span class="hljs-built_in">memset</span>(times, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * array_size);<br>    <span class="hljs-type">int</span> *offset = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[elem_num];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; elem_num; ++i) &#123;<br>        ++times[start[i]];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; array_size; ++i) &#123;<br>        times[i] += times[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = elem_num - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        offset[i] = --times[start[i]];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; elem_num; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (offset[i] != i) &#123;<br>            T temp = start[i];<br>            start[i] = start[offset[i]];<br>            start[offset[i]] = temp;<br>            std::<span class="hljs-built_in">swap</span>(offset[i], offset[offset[i]]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] times;<br>    <span class="hljs-keyword">delete</span>[] offset;<br>&#125;<br></code></pre></td></tr></table></figure><br>此排序算法要求待排序元素的键值必须能作为数组下标，且要求我们知道待排序元素的取值范围。我们申请一个与取值范围相同的数组并赋初值为 0，之后通过元素的键值直接访问该数组，将对应值加 1，直到遍历全部元素。之后，从前到后地，把取值范围数组中（从第二个元素开始）每个位置上的元素与前一个位置上的元素相加并赋值给这个位置，这样这个位置下标的值就是从小到大访问到这个元素时，总共已经有了多少元素。遍历完后，可以新建一个临时数组以保存排序结果，从后往前遍历源数组，把源数组元素值作为下标访问取值范围数组，得到的值就是其在临时数组中的下标，之后再把刚刚用源数组元素值访问范围数组得到的值 - 1 后写回。通过倒序遍历、减一写回，我们实现了排序的稳定性。但是不同版本计数排序实现不同，代码中的版本是不开辅助数组的版本，仍然保证了排序的稳定性。<br>计数排序正是一种不基于比较的排序算法。以上代码排序 int 时的时间复杂度为 O(n+k)，空间复杂度为 O(k)，其中 k 为数字的范围。当 n+k &lt; nlog n 时，计数排序可以实现对快速排序等基于比较的排序算法的超越。然而如果数据过于稀疏，n+k 甚至会远大于 nlog n。</p><h3 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9. 桶排序"></a>9. 桶排序</h3><p>我曾经突发奇想，能不能直接利用自然数作为数组下标来访问数组的方式实现排序呢？于是我写下了类似的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Due to the lack of memory, we only allow [0, 2147483646] here.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pigeonhole_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> *start, <span class="hljs-type">int</span> elem_num, <span class="hljs-type">int</span> max_value)</span> </span>&#123;<br>    <span class="hljs-type">int</span> *array = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[max_value + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">memset</span>(array, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * (max_value + <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; elem_num; ++i) &#123;<br>        ++array[start[i]];<br>    &#125;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; max_value + <span class="hljs-number">1</span>; ++j) &#123;<br>        <span class="hljs-keyword">while</span> (~array[j]) &#123;<br>            start[i++] = j;<br>            --array[j];<br>            <span class="hljs-keyword">if</span> (i == elem_num) &#123;<br>                j = max_value;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] array;<br>&#125;<br></code></pre></td></tr></table></figure><br>虽然开一个 2147483647 长度的整型数组需要大概 8GB 的内存（而且大多数情况下不会有 2147483647 个重复的元素，也就用不到 int 来存放相同元素的个数），但这种朴素的排序算法（鸽巢排序，Pigeonhole Sort）其实正是桶排序 (Bucket Sort) 的雏形。桶排序先用某些键值将元素装进不同的桶里以缩小问题规模，然后常常通过其他排序方式继续对同一个桶中的元素进行排序，最后将桶中的元素依次拿出按顺序放在一起。比如说要对某些日期排序时，先按月份排好，再在每个月份中按日期进行排序。下面的代码通过将 [0, 1) 之间的数据分成 10 个“桶”，然后对每个桶中的链表进行插入排序实现桶排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// [0, 1)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bucket_sort_0to1</span><span class="hljs-params">(<span class="hljs-type">double</span>* src, <span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>    Node** list = <span class="hljs-keyword">new</span> Node*[<span class="hljs-number">10</span>];<br>    <span class="hljs-built_in">memset</span>(list, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(Node*) * <span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        Node** ptr = &amp;list[(<span class="hljs-type">int</span>)(src[i] * <span class="hljs-number">10</span>)];<br>        <span class="hljs-keyword">while</span> (*ptr) &#123;<br>            <span class="hljs-keyword">if</span> ((*ptr)-&gt;val &lt;= src[i])<br>                ptr = &amp;(*ptr)-&gt;next;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        *ptr = <span class="hljs-keyword">new</span> Node&#123;src[i], *ptr&#125;;<br>    &#125;<br>    <span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i != len) &#123;<br>        Node* ptr = list[j++];<br>        <span class="hljs-keyword">while</span> (ptr) &#123;<br>            src[i] = ptr-&gt;val;<br>            ptr = ptr-&gt;next;<br>            ++i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        <span class="hljs-keyword">delete</span> list[i];<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] list;<br>&#125;<br></code></pre></td></tr></table></figure><br>在这段代码中，当元素均匀分布在 [0, 1) 中时，将元素分为 k 桶需要 O(n) 时间复杂度，而对每一桶元素使用插入排序时间复杂度为 $O(\frac{n^2}{k^2})$，因此总时间复杂度为 $O(n+\frac{n^2}{k})$。当 k 接近于 n 时（接近鸽巢排序），此时总时间复杂度接近 O(n)。然而，最坏情况下，所有元素集中在同一个桶，此时桶排序退化为插入排序，时间复杂度为 O(n<sup>2</sup>)。此外，如果桶的个数 k 远多于 n 时，此时桶排序效率也不够理想。<br>桶排序空间复杂度为 O(n+k)，是稳定的排序算法。</p><h3 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10. 基数排序"></a>10. 基数排序</h3><p>当我们比较整数时，常常是由高到低按位比较的，能否依照此思想设计一种排序算法呢？基数排序（Radix Sort）正是一种对各元素从低位到高位先放入个数等于进制数的桶中，再将各桶中的元素按顺序取出，直到整个数组中的元素均有序的排序算法。可以看出，该算法的实现依赖于桶排序的稳定性：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">radix_sort_linkedlist</span><span class="hljs-params">(T *src, <span class="hljs-type">int</span> base, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;Node * next; T elem;&#125;;<br>    Node **list = <span class="hljs-keyword">new</span> Node*[base];<br>    T *sorted = <span class="hljs-keyword">new</span> T[len];<br>    <span class="hljs-built_in">memset</span>(list, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(Node*) * base);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        sorted[i] = src[i];<br>    &#125;<br>    <span class="hljs-type">int</span> i = base, k = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len ; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (!list[sorted[j] % i / k]) &#123;<br>                list[sorted[j] % i / k] = <span class="hljs-keyword">new</span> Node&#123;<span class="hljs-literal">nullptr</span>, sorted[j]&#125;;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list[sorted[j] % i / k]-&gt;elem &gt; sorted[j]) &#123;<br>                list[sorted[j] % i / k] = <span class="hljs-keyword">new</span> Node&#123;list[sorted[j] % i / k], sorted[j]&#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Node *now = list[sorted[j] % i / k];<br>                <span class="hljs-keyword">while</span> (now-&gt;next &amp;&amp; now-&gt;next-&gt;elem &lt; sorted[j]) now = now-&gt;next;<br>                now-&gt;next = <span class="hljs-keyword">new</span> Node&#123;now-&gt;next, sorted[j]&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> sorted_elem_num = <span class="hljs-number">0</span>, curr_base = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (sorted_elem_num &lt; len) &#123;<br>            Node *curr_node = list[curr_base++];<br>            <span class="hljs-keyword">while</span> (curr_node) &#123;<br>                sorted[sorted_elem_num++] = curr_node-&gt;elem;<br>                curr_node = curr_node-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; base; ++j) &#123;<br>            Node *curr_del = list[j];<br>            <span class="hljs-keyword">while</span> (curr_del) &#123;<br>                Node *temp = curr_del-&gt;next;<br>                <span class="hljs-keyword">delete</span> curr_del;<br>                curr_del = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">memset</span>(list, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(Node*) * base);<br>        <span class="hljs-keyword">if</span> (curr_base == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>        i = i * base;<br>        k = k * base;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        src[i] = sorted[i];<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] list;<br>    <span class="hljs-keyword">delete</span>[] sorted;<br>&#125;<br></code></pre></td></tr></table></figure><br>在这里，我们对每一位进行桶排序时，实际上可以利用计数排序的思想直接计算出每个元素在拼接出新数组的位置，从而摆脱有形的“桶”：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">radix_sort</span><span class="hljs-params">(T *src, <span class="hljs-type">int</span> len, <span class="hljs-type">long</span> base)</span> </span>&#123;<br>    T * <span class="hljs-type">const</span> initial_src = src;<br>    T *copy = <span class="hljs-keyword">new</span> T[len];<br>    <span class="hljs-type">long</span> curr_base = base, last_base = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> *count = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[base];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-built_in">memset</span>(count, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * base);<br>        <span class="hljs-type">bool</span> has_nonzero_group = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (src[i] / last_base) has_nonzero_group = <span class="hljs-literal">true</span>;<br>            ++count[src[i] % curr_base / last_base];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!has_nonzero_group) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; base; ++i) &#123;<br>            count[i] += count[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            copy[--count[src[i] % curr_base / last_base]] = src[i];<br>        &#125;<br>        T *temp = src;<br>        src = copy;<br>        copy = temp;<br>        last_base = curr_base;<br>        curr_base *= base;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (initial_src != src) &#123;<br>        T *temp = copy;<br>        copy = src;<br>        src = temp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            src[i] = copy[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] copy;<br>    <span class="hljs-keyword">delete</span>[] count;<br>&#125;<br></code></pre></td></tr></table></figure><br>这里我们每次的模 <code>curr_base</code> 都会与进制数 <code>base</code> 相乘，相当于元素中进行比较的位每次都会左移，实现从低位到高位的比较，同时除以 <code>last_base</code> 舍弃掉末尾已经比较过的位上的数字，同时使得数在 [0, base) 范围内；用 <code>src</code> 和 <code>copy</code> 两个数组来回交换，省去了部分的元素复制操作。<br>基数排序是稳定的排序算法，由于从桶中“拿出”到 <code>copy</code> 是按顺序的，相同大小元素的相对位置不变。<br>基数排序时间复杂度看起来是 O(d(n+k)) ，其中 n 是元素数目，k 是桶的个数，d 是元素的位数，但是 d 与 n 并不是完全无关的：重复元素越少，d 与 n 就越相关，当所有元素均不重复时，$d\geq\log_kn$，此时时间复杂度达到 O(nlog n)级别；当所有元素均大小相等时，时间复杂度为 O(n+k)。不过，我们可以利用计算机多位数比较的硬件能力，将多位数合成一次比较，减少比较次数（认为 CPU 每次比较是等时的，那不妨一次多比较几位）。<br>基数排序空间复杂度为 O(n+k)。（这里采用了类似计数排序的处理方式）<br>显然上面的代码在元素能转为非负整型值时可以排序，但元素是浮点数呢？查阅互联网后，我了解到，IEEE 754 标准下的浮点数，在不考虑符号位时，具有和整型相似的性质：自低位到高位，各位对结果大小的影响越来越大，且高位有“压倒性”优势，那么我们也可以写出如下的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">radix_sort_double</span><span class="hljs-params">(<span class="hljs-type">double</span> *src, <span class="hljs-type">const</span> <span class="hljs-type">int</span> len, <span class="hljs-type">const</span> <span class="hljs-type">int</span> base = <span class="hljs-number">256</span>)</span> </span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> *src_l = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> *)src;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> * <span class="hljs-type">const</span> initial_src = src_l;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> *copy = <span class="hljs-keyword">new</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>[len];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *count = <span class="hljs-keyword">new</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>[base];<br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> FLIP_MSB = (<span class="hljs-number">1ull</span> &lt;&lt; <span class="hljs-number">63</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (src_l[i] &gt;= FLIP_MSB) src_l[i] = ~src_l[i];<br>        <span class="hljs-keyword">else</span> src_l[i] ^= FLIP_MSB;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> eightbit = <span class="hljs-number">0</span>; eightbit &lt; <span class="hljs-number">8</span>; ++eightbit) &#123;<br>        <span class="hljs-built_in">memset</span>(count, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * base);<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *bit = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *&gt;(src_l) + eightbit; <span class="hljs-comment">// src_l 和 copy 交换，导致只能使用 src_l 不能用 src</span><br><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            ++count[(<span class="hljs-type">unsigned</span>)*(bit + <span class="hljs-number">8</span> * i)];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; base; ++i) &#123;<br>            count[i] += count[i - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> (count[(<span class="hljs-type">unsigned</span>)*(bit + <span class="hljs-number">8</span> * i)] == <span class="hljs-number">0</span>) <span class="hljs-built_in">abort</span>();<br>            copy[--count[(<span class="hljs-type">unsigned</span>)*(bit + <span class="hljs-number">8</span> * i)]] = src_l[i];<br>        &#125;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> *temp = src_l;<br>        src_l = copy;<br>        copy = temp;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (initial_src != src_l) &#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> *temp = copy;<br>        copy = src_l;<br>        src_l = temp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            src_l[i] = copy[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (src_l[i] &gt;= FLIP_MSB)<br>        src_l[i] ^= FLIP_MSB;<br>        <span class="hljs-keyword">else</span> src_l[i] = ~src_l[i];<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] copy;<br>    <span class="hljs-keyword">delete</span>[] count;<br>&#125;<br></code></pre></td></tr></table></figure><br>这里我们先把负数取反，因为去掉符号位后绝对值大的负数取反后绝对值小，这样稍后排序时就把小的负数排在大的负数前面；同时对整数只对最高位取反，这样负数的符号位（最高为）实际上成了 0，正数的符号位成了 1，这样稍后排序时负数始终在正数前面。之后，我们由低位向高位 一个字节一个字节地排序（x86 采用小端模式，多字节数据，如这里的 double，的低字节在小的地址端，所以指针递增时实际上是由低字节指向高字节，也就是基数排序从低位向高位转移），最后就能得出结果。</p><h2 id="Part-2-总结"><a href="#Part-2-总结" class="headerlink" title="Part 2 总结"></a>Part 2 总结</h2><p>排序算法多种多样，且一种排序算法常有许多不同的实现，本文只是粗浅地谈到了其中的几种。可以看出，基于比较的排序算法平均时间复杂度不可能低于 nlog n 级别，这是因为一般地，要想将 n 个元素排序完毕，必须确定这 n 个元素之间的相对大小关系。n 个元素相对大小关系共有 n! 种可能（相等被合并进大于或者小于里），而我们每进行一次比较，就把可能的大小关系数减少一半，而 n! 总共需要这样“折半”的次数，是计算 log(n!) = nlog n 级别的。在基于比较的排序算法里，当给出的数据是“随机”的时，快速排序似乎是最快的，但它不是稳定的。如果想要稳定的话，可以考虑归并排序。而当数据总体上是有序时，插入排序则常常是最快的。需要实现优先队列时，可能选择的是堆排序。<br>实际上，C++ STL (g++ 11.1.0, Linux x86_64) 上 std::sort 使用的是“内省式排序” (Introspective Sort)，在元素个数大于 16 时先进行快速排序（三取样切分），快速排序时发现递归深度超过 2log n 时启动堆排序，最后使用插入排序收尾。而 Java JDK 1.8 排序整型数组时，长度小于等于 47 时采用插入排序，长度大于 47 小于等于 286 ，或是长度大于 286 且相同元素或乱序组过多时根据数据相等的情况，决定是采用双轴快速排序 (Dual Pivot Quicksort) 还是单轴快速排序，长度大于 286 且有序情况好的整型数组采用归并排序<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://cloud.tencent.com/developer/article/1690708?from=article.detail.1394343">[4]</span></a></sup>；排序 char、byte 时，数组足够大时将启用计数排序<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.csdn.net/qq_45557225/article/details/105956950">[5]</span></a></sup>。此外，Python 还使用了 TimSort，这一排序算法被认为在现实数据（有一定的有序片段）的排序中性能超过快速排序。就算是对于我们已经简单介绍过的这些算法，也仍然有许多值得尝试的思路，如使用迭代而非递归实现快速排序。不幸的是，笔者水平有限，也没有如此的精力。我们必须结尾了。</p><h2 id="Part-3-性能测试（娱乐）"><a href="#Part-3-性能测试（娱乐）" class="headerlink" title="Part 3 性能测试（娱乐）"></a>Part 3 性能测试（娱乐）</h2><p>下面的代码在 Intel Core i5-10400 的笔记本上编译运行，Linux 内核版本 5.15.2-arch1-1，glibc 版本 2.33-5，g++ 版本 11.1.0：（g++ 开启 O2 优化）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::random_device rd;<br>    <span class="hljs-function">std::default_random_engine <span class="hljs-title">eng</span><span class="hljs-params">(rd())</span></span>;<br>    std::uniform_real_distribution&lt;&gt; <span class="hljs-built_in">distr</span>(下界, 上界);<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> LENGTH = 数组长度;<br>    <span class="hljs-type">double</span> test_input_double[LENGTH], test_src[LENGTH], standard_answer[LENGTH];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(test_input_double) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>); ++i) &#123;<br>        standard_answer[i] = test_input_double[i] = <span class="hljs-built_in">distr</span>(eng);<br>    &#125;<br>    <span class="hljs-type">clock_t</span> start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">sort</span>(standard_answer, standard_answer + <span class="hljs-built_in">sizeof</span>(standard_answer) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>));<br>    cout &lt;&lt; <span class="hljs-string">&quot;std::sort &quot;</span> &lt;&lt;(<span class="hljs-type">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in">sizeof</span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">qsort</span>(test_src, LENGTH, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>), double_cmp);<br>    cout &lt;&lt; <span class="hljs-string">&quot;qsort &quot;</span> &lt;&lt;(<span class="hljs-type">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(test_input_double) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) &#123;cout&lt;&lt;<span class="hljs-string">&quot;qsort dead!&quot;</span>&lt;&lt;endl;<span class="hljs-built_in">abort</span>();&#125;<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in">sizeof</span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">selection_sort</span>(test_src, <span class="hljs-built_in">sizeof</span>(test_input_double) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>));<br>    cout &lt;&lt; <span class="hljs-string">&quot;Selection Sort &quot;</span> &lt;&lt;(<span class="hljs-type">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(test_input_double) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in">sizeof</span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">insertion_sort</span>(test_src, <span class="hljs-built_in">sizeof</span>(test_input_double) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>));<br>    cout &lt;&lt; <span class="hljs-string">&quot;Insertion Sort &quot;</span> &lt;&lt;(<span class="hljs-type">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(test_input_double) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in">sizeof</span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">skipsorted_cocktail_sort</span>(test_src, <span class="hljs-built_in">sizeof</span>(test_input_double) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>));<br>    cout &lt;&lt; <span class="hljs-string">&quot;Cocktail Sort(Skip Sorted) &quot;</span> &lt;&lt;(<span class="hljs-type">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(test_input_double) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in">sizeof</span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">shell_sort</span>(test_src, <span class="hljs-built_in">sizeof</span>(test_input_double) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>));<br>    cout &lt;&lt; <span class="hljs-string">&quot;Shell Sort &quot;</span> &lt;&lt;(<span class="hljs-type">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(test_input_double) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in">sizeof</span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">merge_sort_TopDown</span>(test_src, <span class="hljs-built_in">sizeof</span>(test_input_double) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>));<br>    cout &lt;&lt; <span class="hljs-string">&quot;Merge Sort(Top Down) &quot;</span> &lt;&lt;(<span class="hljs-type">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(test_input_double) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in">sizeof</span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">quick_sort</span>(test_src, <span class="hljs-number">0</span>,  <span class="hljs-built_in">sizeof</span>(test_input_double) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>) - <span class="hljs-number">1</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Quick Sort &quot;</span> &lt;&lt;(<span class="hljs-type">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(test_input_double) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in">sizeof</span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">heap_sort_floyd</span>(test_src, <span class="hljs-built_in">sizeof</span>(test_input_double) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>));<br>    cout &lt;&lt; <span class="hljs-string">&quot;Heap Sort (Floyd) &quot;</span> &lt;&lt;(<span class="hljs-type">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(test_input_double) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in">sizeof</span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">radix_sort_double</span>(test_src, <span class="hljs-built_in">int</span>(<span class="hljs-built_in">sizeof</span>(test_input_double) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>)));<br>    cout &lt;&lt; <span class="hljs-string">&quot;Radix Sort &quot;</span> &lt;&lt;(<span class="hljs-type">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(test_input_double) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) <span class="hljs-built_in">abort</span>();<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><br>改变数组的长度，下界，上界，每次运行 3 次取平均时间，对随机序列浮点数排序：<br>当上下界为 <code>(-1000, 1000)</code> 时：</p><div class="table-container"><table><thead><tr><th>数组长度</th><th>100</th><th>1000</th></tr></thead><tbody><tr><td>std::sort</td><td>7.66667E-06</td><td>0.000111667</td></tr><tr><td>qsort</td><td>1.33333E-05</td><td>0.000197</td></tr><tr><td>选择排序</td><td>1.36667E-05</td><td>0.001195667</td></tr><tr><td>插入排序</td><td>1.03333E-05</td><td>0.000722333</td></tr><tr><td>跳过有序部分的鸡尾酒排序</td><td>0.000024</td><td>0.001728667</td></tr><tr><td>希尔排序</td><td>0.000007</td><td>9.73333E-05</td></tr><tr><td>自顶向下归并排序</td><td>1.03333E-05</td><td>0.000105667</td></tr><tr><td>快速排序</td><td>0.000008</td><td>9.93333E-05</td></tr><tr><td>Floyd 优化堆排序</td><td>0.000009</td><td>0.000113333</td></tr><tr><td>基数排序</td><td>1.33333E-05</td><td>0.000046</td></tr></tbody></table></div><p>当上下界为 <code>(-1000000, 1000000)</code> 时：</p><div class="table-container"><table><thead><tr><th>数组长度</th><th>100</th><th>1000</th></tr></thead><tbody><tr><td>std::sort</td><td>1.30E-05</td><td>0.000147333</td></tr><tr><td>qsort</td><td>2.20E-05</td><td>0.000278</td></tr><tr><td>选择排序</td><td>2.30E-05</td><td>0.001250333</td></tr><tr><td>插入排序</td><td>1.63E-05</td><td>0.001108</td></tr><tr><td>跳过有序部分的鸡尾酒排序</td><td>3.83E-05</td><td>0.002401667</td></tr><tr><td>希尔排序</td><td>1.07E-05</td><td>0.000148667</td></tr><tr><td>自顶向下归并排序</td><td>1.67E-05</td><td>0.000158</td></tr><tr><td>快速排序</td><td>1.37E-05</td><td>0.000148</td></tr><tr><td>Floyd 优化堆排序</td><td>1.37E-05</td><td>0.000170333</td></tr><tr><td>基数排序</td><td>2.33E-05</td><td>6.53333E-05</td></tr></tbody></table></div><p>总的来说，数据范围小时，排序似乎更快，以下几组都在 <code>(-1000, 1000)</code> 中测出（这几组由于长度比较长，没有重复实验）：</p><div class="table-container"><table><thead><tr><th>数组长度</th><th>10000</th><th>100000</th><th>1000000</th></tr></thead><tbody><tr><td>std::sort</td><td>0.000936333</td><td>0.012468</td><td>0.071469</td></tr><tr><td>qsort</td><td>0.001347</td><td>0.012289333</td><td>0.111367</td></tr><tr><td>选择排序</td><td>0.033825</td><td>2.86037</td><td>333.48</td></tr><tr><td>插入排序</td><td>0.033676</td><td>3.161943333</td><td>341.91</td></tr><tr><td>跳过有序部分的鸡尾酒排序</td><td>0.091149667</td><td>9.482406667</td><td>1009.35</td></tr><tr><td>希尔排序</td><td>0.000645333</td><td>0.008864</td><td>0.12158</td></tr><tr><td>自顶向下归并排序</td><td>0.000623333</td><td>0.008097667</td><td>0.097622</td></tr><tr><td>快速排序</td><td>0.000550333</td><td>0.006777</td><td>0.080969</td></tr><tr><td>Floyd 优化堆排序</td><td>0.000673333</td><td>0.009133667</td><td>0.128802</td></tr><tr><td>基数排序</td><td>0.000163</td><td>0.002073333</td><td>0.028749</td></tr></tbody></table></div><p>仅仅是为了好玩，我又测量了 200000，300000，…，900000 的情况，得到：<br><img src="https://zhaozihanzzh.github.io/images/sort_time.png" alt="总用时"><br><img src="https://zhaozihanzzh.github.io/images/sort_withoutn2.png" alt="去除 O(n^2) 后的用时"><br>为了考察有序性对性能的影响，当数组长度为 10000，范围 <code>(-1000，1000)</code> 时，测量出完全升序、（第 0，10000，20000，30000，40000，…，90000）随机，其余位置升序、完全降序的情况：</p><div class="table-container"><table><thead><tr><th>有序性</th><th>完全升序</th><th>接近升序</th><th>完全降序</th></tr></thead><tbody><tr><td>std::sort</td><td>0.001059</td><td>0.005846</td><td>0.001357</td></tr><tr><td>qsort</td><td>0.002488</td><td>0.002918</td><td>0.004248</td></tr><tr><td>选择排序</td><td>2.84899</td><td>3.72152</td><td>2.87279</td></tr><tr><td>插入排序</td><td>8.6e-05</td><td>0.000498</td><td>6.33238</td></tr><tr><td>跳过有序部分的鸡尾酒排序</td><td>0.000123</td><td>1.48579</td><td>6.57123</td></tr><tr><td>希尔排序</td><td>0.000667</td><td>0.00176</td><td>0.001462</td></tr><tr><td>自顶向下归并排序</td><td>0.001812</td><td>0.001958</td><td>0.002136</td></tr><tr><td>快速排序</td><td>0.001385</td><td>0.115653</td><td>0.001515</td></tr><tr><td>Floyd 优化堆排序</td><td>0.004723</td><td>0.004694</td><td>0.005258</td></tr><tr><td>基数排序</td><td>0.002475</td><td>0.002295</td><td>0.002025</td></tr></tbody></table></div><p>为了了解整型的情况，我又对 <code>(0, 1000000)</code> 的正整数排序进行测试，这次将基数排序替换为整型版本，并加入了计数排序：</p><div class="table-container"><table><thead><tr><th>数组长度</th><th>10000</th><th>100000</th><th>1000000</th></tr></thead><tbody><tr><td>std::sort</td><td>0.001190667</td><td>0.005622667</td><td>0.068292</td></tr><tr><td>qsort</td><td>0.002274667</td><td>0.009722333</td><td>0.104763</td></tr><tr><td>选择排序</td><td>0.046129</td><td>2.66948</td><td>308.974</td></tr><tr><td>插入排序</td><td>0.031989</td><td>2.98289</td><td>311.727</td></tr><tr><td>跳过有序部分的鸡尾酒排序</td><td>0.077564667</td><td>8.208996667</td><td>857.231</td></tr><tr><td>希尔排序</td><td>0.000599</td><td>0.00847</td><td>0.110247</td></tr><tr><td>自顶向下归并排序</td><td>0.000569667</td><td>0.007658667</td><td>0.095276</td></tr><tr><td>快速排序</td><td>0.000516333</td><td>0.006403333</td><td>0.071781</td></tr><tr><td>Floyd 优化堆排序</td><td>0.000665667</td><td>0.00898</td><td>0.131631</td></tr><tr><td>基数排序</td><td>0.001474</td><td>0.014975667</td><td>0.134972</td></tr><tr><td>计数排序</td><td>0.0004</td><td>0.002697667</td><td>0.062725</td></tr></tbody></table></div><p>由于 O2 优化等因素的影响，实际得到的结果与预想有些出入。<br>总之，尽管排序算法性能差距悬殊，可有时人和人之间的差别比这还大呢！</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>《算法（第 4 版）》P154<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="http://blog.sciencenet.cn/blog-83029-468247.html">http://blog.sciencenet.cn/blog-83029-468247.html</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>《算法（第 4 版）》P208<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://cloud.tencent.com/developer/article/1690708?from=article.detail.1394343">https://cloud.tencent.com/developer/article/1690708?from=article.detail.1394343</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://blog.csdn.net/qq_45557225/article/details/105956950">https://blog.csdn.net/qq_45557225/article/details/105956950</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>神船 TX6 修复 ArchLinux 下触摸板问题</title>
    <link href="/2021/09/25/touchpad-clevo-arch/"/>
    <url>/2021/09/25/touchpad-clevo-arch/</url>
    
    <content type="html"><![CDATA[<h1 id="神船-TX6-修复-ArchLinux-下触摸板问题"><a href="#神船-TX6-修复-ArchLinux-下触摸板问题" class="headerlink" title="神船 TX6 修复 ArchLinux 下触摸板问题"></a>神船 TX6 修复 ArchLinux 下触摸板问题</h1><h2 id="Part-1-背景"><a href="#Part-1-背景" class="headerlink" title="Part 1 背景"></a>Part 1 背景</h2><p>在 Arch Linux 刚刚<a href="https://zhaozihanzzh.github.io/2020/12/25/arch-install/">安装好</a>时，这台神船 TX6（蓝天 NK60SB 模具）的触摸板是正常的。然而，2021 年 2 月 26 日系统更新之后的重启改变了这一切——触摸板不能用了。我按照 wiki 上的各种方法，安装了 <code>xf86-input-synaptics</code>，调整了 <code>/etc/X11/xorg.conf.d/70-synaptics.conf</code>、<code>/usr/share/X11/xorg.conf.d/70-synaptics.conf</code>等配置文件 ，查了 <code>journalctl</code>、<code>/var/log/Xorg.0.log</code> 等各种日志，追踪了 <code>/proc/bus/input/devices</code>等，甚至安装了 GNOME、切换 wayland，无果。求助了一些大佬，仍然没有解决问题。由于当时更新了 nvidia 驱动，切换 nvidia 驱动仍然无果。后来，尝试<a href="https://zhaozihanzzh.github.io/2021/08/10/bios-gpu-switch/">禁用独显</a>，仍然没用，说明可能不是 nvidia 的原因……</p><h2 id="Part-2-解决"><a href="#Part-2-解决" class="headerlink" title="Part 2 解决"></a>Part 2 解决</h2><p>事发 6 个月后，通过在 Bing 上搜索 “dev/input/mouse touchpad” ，成功找到 <a href="https://bbs.archlinux.org/viewtopic.php?pid=1927097#p1927097">archlinux 的 bbs</a>，在 <code>/etc/default/grub</code> 中 <code>GRUB_CMDLINE_LINUX_DEFAULT</code> 条目加入 <code>pci=nocrs</code>，之后执行<code>sudo grub-mkconfig -o /boot/grub/grub.cfg</code>（根据自己 grub 安装情况调整，这里我在 <code>/etc/default/grub</code> 里加入了 <code>GRUB_DISABLE_OS_PROBER=false</code> 来检测到 Windows），重启，触摸板可以用了，并且执行 <code>sudo dmesg | grep i2c</code> 可以看到这样的输出：<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">[    3.028457] input: ELAN0413:00 04F3:3161 Mouse as /devices/pci0000:00/0000:00:15.0/i2c_designware.0/i2c-0/i2c-ELAN0413:00/0018:04F3:3161.0001/input/input11<br>[    3.028517] input: ELAN0413:00 04F3:3161 Touchpad as /devices/pci0000:00/0000:00:15.0/i2c_designware.0/i2c-0/i2c-ELAN0413:00/0018:04F3:3161.0001/input/input13<br>[    3.028561] hid-generic 0018:04F3:3161.0001: input,hidraw0: I2C HID v1.00 Mouse [ELAN0413:00 04F3:3161] on i2c-ELAN0413:00<br>[    3.033612] i2c i2c-2: 2/2 memory slots populated (from DMI)<br>[    3.034104] i2c i2c-2: Successfully instantiated SPD at 0x50<br>[    3.504030] input: ELAN0413:00 04F3:3161 Mouse as /devices/pci0000:00/0000:00:15.0/i2c_designware.0/i2c-0/i2c-ELAN0413:00/0018:04F3:3161.0001/input/input18<br>[    3.504075] input: ELAN0413:00 04F3:3161 Touchpad as /devices/pci0000:00/0000:00:15.0/i2c_designware.0/i2c-0/i2c-ELAN0413:00/0018:04F3:3161.0001/input/input20<br>[    3.504118] hid-multitouch 0018:04F3:3161.0001: input,hidraw0: I2C HID v1.00 Mouse [ELAN0413:00 04F3:3161] on i2c-ELAN0413:00<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>龟兔赛跑算法</title>
    <link href="/2021/09/19/algo-tortoiseandhare/"/>
    <url>/2021/09/19/algo-tortoiseandhare/</url>
    
    <content type="html"><![CDATA[<h1 id="龟兔赛跑算法"><a href="#龟兔赛跑算法" class="headerlink" title="龟兔赛跑算法"></a>龟兔赛跑算法</h1><h2 id="Part-1-背景"><a href="#Part-1-背景" class="headerlink" title="Part 1 背景"></a>Part 1 背景</h2><p>问题来自<a href="https://leetcode-cn.com/problems/linked-list-cycle/">力扣</a>：判断链表中是否有环？</p><h2 id="Part-2-实现"><a href="#Part-2-实现" class="headerlink" title="Part 2 实现"></a>Part 2 实现</h2><p>准备两个指针，遍历时一个指针前进一次，另一个前进两次，如果两指针相遇或赶超，说明存在环。好比两人在操场上跑步，速度一快一慢，当时间足够时，总会“套圈”。</p><p>时间复杂度：O(N)，N 为链表节点数。</p><p>空间复杂度：O(1)。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python3 整除的浅思</title>
    <link href="/2021/09/10/python-exact-division/"/>
    <url>/2021/09/10/python-exact-division/</url>
    
    <content type="html"><![CDATA[<h1 id="Python3-整除的浅思"><a href="#Python3-整除的浅思" class="headerlink" title="Python3 整除的浅思"></a>Python3 整除的浅思</h1><p>Python 3 中，采用 <code>//</code> 来实现整除，两个整型变量整除后得到的变量依然是整型。而采用普通的除号 <code>/</code> 得到的却是浮点型。</p><p>Python 3 中，整型支持可以做到硬件允许范围内的大，但浮点型没有这样的实现机制。为了保留相对完整的大整数运算能力支持，需要整除的存在来避开对浮点的依赖。</p><p>那么，为什么两个整型采用除号运算，得到的却是浮点型？</p><p>可以参考：<a href="https://www.zhihu.com/question/473479381/answer/2015056944">pansz的回答</a>。</p>]]></content>
    
    
    <categories>
      
      <category>计算机杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>神船 TX6 BIOS 开关独显</title>
    <link href="/2021/08/10/bios-gpu-switch/"/>
    <url>/2021/08/10/bios-gpu-switch/</url>
    
    <content type="html"><![CDATA[<h1 id="神船-TX6-BIOS-开关独显"><a href="#神船-TX6-BIOS-开关独显" class="headerlink" title="神船 TX6 BIOS 开关独显"></a>神船 TX6 BIOS 开关独显</h1><h2 id="Part-1-背景"><a href="#Part-1-背景" class="headerlink" title="Part 1 背景"></a>Part 1 背景</h2><p>神船 TX6-CU5DA/S （蓝天 NK60SB 模具那一代）采用了桌面端 Intel Core i5-10400 CPU（主板采用 H470 芯片组），搭载 NVIDIA GeForce GTX1650 独立显卡，采用双风扇四铜管三出风口散热，且有两个 M.2 2280 的 SSD 接口、1 个 2.5 吋 7mm 硬盘位 ，内存可插拔，使用 16.1 吋 72% NTSC 屏幕，47Whr 的外置电池，150W 适配器。购买之初，笔者没认清自己对于续航的需求，或者对游戏本的续航表现抱有幻想，后来遇到无法充电的场景时屡屡尴尬（续航大约3h？）。</p><p>经过大量实践，调节蓝天 Control Center，改变电源模式，<a href="https://www.bilibili.com/read/cv10682637/">设备管理器禁用独显</a> 均无法彻底扭转这续航。联系逛笔吧的经验，笔者不禁想问，能不能在 BIOS 里禁用独显呢？这样做的效果又怎样呢？如果你也有同样的疑问，不妨往下看。</p><h2 id="Part-2-步骤"><a href="#Part-2-步骤" class="headerlink" title="Part 2 步骤"></a>Part 2 步骤</h2><p>参考<a href="https://bbs.letitfly.me/d/1151">神船 NK60SB (NKx0Sx) Insyde BIOS 折腾记</a> ，将 <code>IGD or MSHybird or DISCRETE Switch</code> 改为 <code>IGD</code> 即可。（改回来的时候别错改成 <code>DISCRETE</code>，可以参考原作者的帖子，这机器好像只能混合输出，没法独显直连）</p><p>如果链接失效，可以看<a href="https://zhaozihanzzh.github.io/images/website_biosgpu_20210810.jpeg">截图</a>。</p><h2 id="Part-3-总结"><a href="#Part-3-总结" class="headerlink" title="Part 3 总结"></a>Part 3 总结</h2><p>屏蔽独显后，续航改善明显。在某次 30 分钟使用后，电量从 80% 下降至 69%。看看这颗 TDP 65W （单烤也能到这个值）的桌面级 CPU，16.1 吋的屏幕，以及 47Whr 的电池，笔者感觉这样的续航还是可以接受的。</p><p>在过去的 2020 年，想要找一台 Intel CPU 性能释放足够强，屏幕大，价格低的机器，低价位选择并不多。这台机器能否成为披着游戏本外衣的程序员本呢？</p><p>也许，每个人都有自己的答案。</p><p>在笔者看来，这台机器有以下一些特点：</p><ul><li>性能释放强，单烤（Stress FPU）CPU 70+W。</li><li>扩展性较好，三硬盘位。</li><li>16.1吋，屏幕大。</li><li>全高方向键。</li><li>Linux 支持不算烂。</li><li>神船原装群联主控 OEM 固态是减分项，<a href="https://tieba.baidu.com/p/7442648091?pn=3">据传</a>（76楼） 2020 年年底到 2021 年年初有一批固态掉盘较为严重。</li><li>不支持 PD 充电。</li><li>Intel(R) Wireless-AC 9462 无线网卡，不支持 WiFi-6。</li></ul><p>关于电池，同样三硬盘位的机器，宏碁暗影骑士·擎（15.6吋）电池为 57Whr，神舟 TX8-CU5DA（16.1吋）为62Whr，神舟 TX9-CA5DP （16.1吋）电池为 55Whr，TX8-笔者感觉 TX6 这个电池还能再大一点，获得更好续航表现。</p><p>曾经，在蓝天模具的加持下，“神船大法保平安”广为流传，但最近的笔记本市场风云激荡，笔者愚见，神船更应该继续加油才能乘风破浪，驶向深蓝。</p>]]></content>
    
    
    <categories>
      
      <category>娱乐</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>概率论</title>
    <link href="/2021/06/07/probability-theory/"/>
    <url>/2021/06/07/probability-theory/</url>
    
    <content type="html"><![CDATA[<h2 id="一、随机事件与概率"><a href="#一、随机事件与概率" class="headerlink" title="一、随机事件与概率"></a>一、随机事件与概率</h2><h3 id="1-随机现象与随机试验"><a href="#1-随机现象与随机试验" class="headerlink" title="1.随机现象与随机试验"></a>1.随机现象与随机试验</h3><p>基本事件：每一个可能出现的实验结果，用 $w_i$ 表示。必然事件常用 $\Omega$ 表示，不可能事件常用 $\emptyset$ 表示。</p><p>事件的运算：和 $A\bigcup{B}$ ，差 $A-B$ 或 A\B ，交（积） $A\bigcap{B}$ 或 $AB$ 。</p><p>互不相同事件：不同时发生；对立事件：“事件A不发生”这一事件。</p><h3 id="2-概率的定义"><a href="#2-概率的定义" class="headerlink" title="2.概率的定义"></a>2.概率的定义</h3><p>古典概型（$\Omega$ 是有限集）：$P(A)=\frac{n_A}{n}$，几何概型：$P(A)=\frac{G 的几何度量}{\Omega 的几何度量}$。</p><p>概率的公理化定义：基本事件空间 $\Omega$ 是所有基本事件构成的集合，事件域为 $F$ （已有的事件怎么操作都跑不出去），概率测度 $P$ ，则 $(\Omega, F, P)$ 为概率空间。</p><p>如果 $P(A) = 0$ ，A 未必是不可能事件。</p><p>概率加法公式：$P(\bigcup\limits_{i=1}^{n}A_i)=\sum\limits_{i=1}^{n}P(A_i)-\sum\limits_{1\leq{i}&lt;j\leq{n}}^{n}P(A_{i}A_{j})+\sum\limits_{1\leq{i}&lt;j&lt;k\leq{n}}^{n}P(A_{i}A_{j}A_{k})-\cdots+(-1)^{n-1}P(A_{1}A_{2}\cdots A_{n})$</p><h3 id="3-条件概率"><a href="#3-条件概率" class="headerlink" title="3.条件概率"></a>3.条件概率</h3><p>条件概率：已知某事件发生，另一事件发生（可用来构造概率空间）</p><p>乘法公式：$P(B|A)=\frac{P(AB)}{P(A)}$，推广：$P(A_1A_2\cdots A_n)=P(A_1)P(A_2|A_1)P(A_3|(A_1A_2))\cdots P(A_n|(A_1A_2\cdots A_n))$</p><p>全概率公式：先化整为零，再聚零为整：$B_i$ 为 $B$ 的一个划分，则当 $A\subset B$ ，$B_i$ 是 $B$ 的一个划分，此时有 $P(A) = \sum\limits_{i=1}^{n}P(B_i)P(A|B_i)$ 。(6 个黑球，4 个白球，第二次摸到的是白球的概率？)</p><p>贝叶斯公式：若 $P(B_i)&gt;0$ ，$B_iB_j = \emptyset$，$A\subset{\bigcup\limits_{i=1}^{\infty}B_i}$ ，$P(A)&gt;0$ ，则 $P(B_j|A) = \frac{P(B_j)P(A|B_j)}{\sum\limits_{i=1}^{\infty}P(B_i)P(A|B_i)}$。（甲乙丙三车间产量占比已知，次品率已知，现在查出一个次品，是甲车间生产的概率？）</p><h3 id="4-事件独立性"><a href="#4-事件独立性" class="headerlink" title="4.事件独立性"></a>4.事件独立性</h3><p>若 $P(AB) = P(A)P(B)$，则 A、B 相互独立。</p><p>三个事件相互独立（$P(AB) = P(A)P(B)$，$P(BC) = P(B)P(C)$，$P(AC) = P(A)P(C)$，$P(ABC) = P(A)P(B)P(C)$）强于两两独立。</p><h3 id="5-独立实验"><a href="#5-独立实验" class="headerlink" title="5.独立实验"></a>5.独立实验</h3><p>n 重伯努利试验：试验只有两种可能结果，重复 n 次。</p><p>伯努利定理：成功概率 p 时成功 k 次概率 $b(k;n,p)=C^{k}_{n}p^{k}(1-p)^{n-k}$ ，称为伯努利数。</p><h2 id="二、一维随机变量及其分布"><a href="#二、一维随机变量及其分布" class="headerlink" title="二、一维随机变量及其分布"></a>二、一维随机变量及其分布</h2><h3 id="1-随机变量"><a href="#1-随机变量" class="headerlink" title="1.随机变量"></a>1.随机变量</h3><p>对实数集上的任意 x ，有 $\{\omega|X(\omega)\leq{x}\}\in{F}$ ，称 $X(\omega)$ 为随机变量。（这个事件必须在事件域 F 中）</p><p>随机变量 X 的分布函数 $F_x(x)=P(X\leq{x})$ ，则 $P(X&lt;{x})=F_x(x-0)$ （左极限），分布函数右连续，但不一定左连续，$P(X={x})=F_x(x)-F_x(x-0)$ ，$F_x(x)$ 为单调递增函数，且在负无穷、正无穷取值分别为 0、1。</p><h3 id="2-一维离散型随机变量"><a href="#2-一维离散型随机变量" class="headerlink" title="2.一维离散型随机变量"></a>2.一维离散型随机变量</h3><p>离散型随机变量的取值为有限个或可列多个。为了直观，可以使用表格列出分布列。接下来介绍几种概率分布：</p><p>a.两点分布（0-1分布）：</p><div class="table-container"><table><thead><tr><th>X</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>P</td><td>1-p</td><td>p</td></tr></tbody></table></div><p>b.二项分布 $X\sim{B(n, p)}$</p><p>n 重伯努利试验，成功概率 p，随机变量 X 为成功次数</p><p>记 $k_0=Int[(n+1)p]$，当 $k=k_0$ 时 $b(k;n,p)$ 最大；若 (n+1)p 为整数，则 $b(k_0;n,p)=b(k_0-1;n,p)$ 。</p><p>c.泊松分布 $X\sim{P(\lambda)}$，参数 $\lambda&gt;0$</p><p>$P(X=k)=\frac{e^{-\lambda}\lambda^k}{k!}$ ，其中又有泊松定理：$X_n\sim{B(n,p_n)}$，其中 $p_n$ 与 $n$ 有关，且 $\lim\limits_{n\rightarrow\infty}np_n=\lambda&gt;0$ ，此时有 $\lim\limits_{n\rightarrow\infty}P(x_n=k)=\frac{e^{-\lambda}\lambda^k}{k!}$ ，k 取自然数，表示的意义为：把一段时间分割为 $n$ 段，每段时间内某事件发生的概率为 $p_n$ （由于每段时间很小，认为事件不会在这样短的时间内发生两次及以上），由二项分布，乘积 $\lambda$ 为这段时间事件发生次数的期望，当把每段时间无限地分割下去时，二项分布实际上就成了泊松分布。因此，还有泊松近似公式：</p><p>当二项分布 n 很大，p 很小（一般取 $n\geq{10}$，$p\leq{0.1}$ ）时，$P(X=k)\approx{\frac{e^{-\lambda}\lambda^k}{k!}}$。</p><p>d.几何分布 $X\sim{Geo(p)}$</p><p>$P(X=k)=g^{k-1}p=g(k;p)$ 表示前 (k - 1) 次试验未成功，第 k 次首次成功。</p><p>几何分布有无记忆性，已知前 k 次还未成功，则从 (k + 1) 次，首次成功出现在哪一次与 k 无关，即 $P(X=k+n|X&gt;k)=P(x=n)$。（彼此独立）</p><h3 id="3-一维连续型随机变量"><a href="#3-一维连续型随机变量" class="headerlink" title="3.一维连续型随机变量"></a>3.一维连续型随机变量</h3><p>若存在 $f(x)&gt;0$ 使得对任意 x 有 $F(x)=\int_{-\infty}^{x}f(t)dt$，那么 $f(x)$ 为 x 的概率密度函数（在不至于混淆时简称密度函数）。显然，在某点上概率分布函数一定是 0，因此我们需要讨论随机变量落在某区间上的概率，为了便于描述概率分布函数与 x 轴围成图形的面积，引入密度函数。易知，$\int_{-\infty}^{+\infty}f(x)dx=1$ 。同样地，介绍几种概率分布：</p><p>a.均匀分布 $x\sim{U[a,b]}$</p><p>a&lt;b，$f(x)=\left\{\begin{matrix}\frac{1}{b-a},x\in[a,b]\\0,x\notin[a,b]\end{matrix}\right.$</p><p>显然，当 $a\leq{x}\leq{b}$ 时 $F(x)=\frac{x-a}{b-a}$。（“线性”）</p><p>b.指数分布 $X\sim{E(X)}$</p><p> x 的密度函数满足 $f(x)=\left\{\begin{matrix}\lambda{e}^{-\lambda{x}},x&gt;0\\0,x\leq0\end{matrix}\right.$ ，分布函数 $F(x)=\left\{\begin{matrix}1-e^{-\lambda{x}}, x&gt;0\\0, x\leq{0}\end{matrix}\right.$</p><p>指数分布也与泊松分布关系密切，后者表示的是某事件在一定时间中的发生次数的概率分布，而前者是某事件两次发生之间时间间隔的概率分布：设某段时间长为 x，在这段时间内某事件发生次数为 $\lambda{x}$，那么在这段时间中一次也不发生概率为 $\frac{e^{-\lambda{x}}(\lambda{x})^0}{0!}=e^{-\lambda{x}}$，那么在这段时间内发生一次及以上该事件的概率为 $1-e^{-\lambda{x}}$，即：时间间隔小于这个 x 的概率为 $1-e^{-\lambda{x}}$，这就是指数分布在时间间隔大于 0 时的分布函数。</p><p>指数分布具有“无记忆性”，即 $P(X&gt;k+n|X&gt;k)=P(X&gt;n)$。</p><p>c.正态分布 $X\sim{N}(\mu, \sigma^2)$</p><p>$f(x)=\frac{1}{\sqrt{2\pi}\sigma}e^-\frac{(x-\mu)^2}{2\sigma^2}$，分布函数为其积分。又有标准正态分布 $\mu=0,\sigma=1$，记其密度函数为 $\varphi(x)$，分布函数为 $\Phi(x)$，查表时要注意 $\Phi(x)-\frac{1}{2}=\frac{1}{2}-\Phi(-x)$，即概率分布关于 $\frac{1}{2}$ 对称。</p><p>正态分布标准化：对于 $X\sim{N(\mu, \sigma^2)}$，有 $\frac{x-\mu}{\sigma}\sim{N(0,1)}$。</p><h3 id="4-一维离散型随机变量函数的分布"><a href="#4-一维离散型随机变量函数的分布" class="headerlink" title="4.一维离散型随机变量函数的分布"></a>4.一维离散型随机变量函数的分布</h3><p>X 经某函数映射到 Y，那么求 Y 取某个值的概率时需要合并使 Y 取这个值的所有 X 的概率。</p><h3 id="5-一维连续型随机变量函数的分布"><a href="#5-一维连续型随机变量函数的分布" class="headerlink" title="5.一维连续型随机变量函数的分布"></a>5.一维连续型随机变量函数的分布</h3><p>需要利用分布函数和 Y 与 X 的关系，将 Y 小于等于某值的概率解不等式转为 X 取某区间的概率，之后如果需要求密度函数，直接对所得的分布函数求导即可，需要注意若 $F_Y(y)=\int_{h_2(y)}^{h_1(y)}g(x)dx$，那么 $F_Y’(y)=g(h_1(y))h_1’(y)-g(h_2(y))h_2’(y)$，$\pm\infty$ 导数看做 0。</p><h2 id="三、二维随机向量及其分布"><a href="#三、二维随机向量及其分布" class="headerlink" title="三、二维随机向量及其分布"></a>三、二维随机向量及其分布</h2><p>我们只讨论二维随机向量。</p><h3 id="1-随机向量联合分布函数与联合密度函数（连续型）"><a href="#1-随机向量联合分布函数与联合密度函数（连续型）" class="headerlink" title="1.随机向量联合分布函数与联合密度函数（连续型）"></a>1.随机向量联合分布函数与联合密度函数（连续型）</h3><p>随机向量联合分布函数 $F_{X_1,X_2}(x_1, x_2)=P(X_1\leq{x_1},X_2\leq{x_2})$，有 $F(-\infty, y)=F(x,-\infty)=F(-\infty, -\infty)=0$。</p><p>若 $(X,Y)$ 所有取值只有有限个或可列个，其为离散型随机变量；若存在 $f(x,y)$ 使得对任意 x, y，有 $F_{X,Y}(x,y)=\int_{-\infty}^{y}\int_{-\infty}^{x}f(u,v)dudv$，那么 $(X,Y)$ 为连续型随机变量，称 $f(x,y)$ 为它的联合概率密度函数（或者直接称为分布密度函数）。</p><h3 id="2-随机向量边缘分布函数与边缘密度函数（连续型）"><a href="#2-随机向量边缘分布函数与边缘密度函数（连续型）" class="headerlink" title="2.随机向量边缘分布函数与边缘密度函数（连续型）"></a>2.随机向量边缘分布函数与边缘密度函数（连续型）</h3><p>二维随机向量边缘分布为其中某个随机变量取某个值的概率（相当于在表格“边缘”的那一栏），对于离散型二维随机向量，有$P(Y=y_j)=\sum\limits_ip_{ij}$；对于连续型二维随机变量，其边缘分布函数为 $F_X(x)=F(x, +\infty)=\lim\limits_{y\rightarrow+\infty}F(x,y)$，其边缘密度函数为 $f_X(x)=\int_{-\infty}^{+\infty}f_{X,Y}(x,y)dy$ 。（由联合分布确定其边缘分布，但反之不一定，要考虑其独立性）</p><h3 id="3-随机变量的相互独立性"><a href="#3-随机变量的相互独立性" class="headerlink" title="3.随机变量的相互独立性"></a>3.随机变量的相互独立性</h3><p>若可判断 X、Y 取值互不影响，或对任意 x, y ，有 $F(x,y)=F(x)F(y)$，或离散型有 $p_{ij}=p_{i\cdot}p_{\cdot{j}}$，或连续型有 $f(x,y)=f_X(x)f_Y(y)$，那么 X、Y 相互独立。此时边缘分布可确定联合分布。</p><h3 id="4-二维均匀分布"><a href="#4-二维均匀分布" class="headerlink" title="4.二维均匀分布"></a>4.二维均匀分布</h3><p>有界区域 D 的面积为 $S_D$，$f(x,y)=\left\{\begin{matrix}\frac{1}{S_D},(x,y)\in{D}\\0,(x,y)\notin{D}\end{matrix}\right.$。可以用画图辅助。</p><h3 id="5-二维正态分布"><a href="#5-二维正态分布" class="headerlink" title="5.二维正态分布"></a>5.二维正态分布</h3><p>$(X,Y)\sim{N(\mu_1,\mu_2,\sigma^2_1,\sigma^2_2,\rho)}$，其边缘分布是一维正态分布，$\rho$ 为两变量的相关系数。（“物以类聚”，$\mu$ 在一起，$\sigma$ 在一起）</p><h3 id="6-二维随机向量函数的概率分布函数（离散型）与概率密度函数（连续型）"><a href="#6-二维随机向量函数的概率分布函数（离散型）与概率密度函数（连续型）" class="headerlink" title="6.二维随机向量函数的概率分布函数（离散型）与概率密度函数（连续型）"></a>6.二维随机向量函数的概率分布函数（离散型）与概率密度函数（连续型）</h3><p>$Z=g(x,y)$ 为一个二元函数，研究其分布：</p><p>离散型与一维类似，其概率分布函数直接将每个可能的 $(X,Y)$ 概率累加。</p><p>对于连续型，有 $F_Z(z)=P(g(X,Y)\leq{Z})=\iint\limits_{g(x,y)\leq{z}}f(x,y)dxdy$，但我们在这里只讨论随机向量函数为两随机变量之和的情况：令 $y=u-x$，则上式可写成 $\iint\limits_{x+y\leq{z}}f(x,y)dxdy=\int_{-\infty}^{+\infty}\int_{-\infty}^{z-x}f(x,y)dydx=\int_{-\infty}^{+\infty}\int_{-\infty}^{z}f(x,u-x)dudx=\int_{-\infty}^{z}\int_{-\infty}^{+\infty}f(x,u-x)dxdu$，求导得 $f_Z(z)=\int_{-\infty}^{+\infty}f(x, z-x)dx$。同理，$f_Z(z)=\int_{-\infty}^{+\infty}f(z-y, y)dy$。</p><p>特别地，当 x、y相互独立时，上式变为卷积公式 $f_Z(z)=\int_{-\infty}^{+\infty}f_X(x)f_Y(z-x)dx=f_Z(z)=\int_{-\infty}^{+\infty}f_X(z-y)f_Y(y)dy$</p><p>事实上，X、Y 相互独立时， $X\sim P(\lambda_1)$，$Y\sim P(\lambda_2)$，则 $X+Y\sim P(\lambda_1+\lambda_2)$；$X\sim B(m,p)$，$Y\sim B(n,p)$，则 $X+Y\sim B(m+n,p)$；$X\sim{N}(\mu_1, \sigma^2_1)$，$Y\sim{N}(\mu_2, \sigma^2_2)$，则 $X+Y\sim{N}(\mu_1+\mu_2, \sigma^2_1+\sigma^2_2)$。更进一步地，有限个独立的正态分布的随机变量线性组合仍然是正态分布。</p><h2 id="四、随机变量的数字特征"><a href="#四、随机变量的数字特征" class="headerlink" title="四、随机变量的数字特征"></a>四、随机变量的数字特征</h2><h3 id="1-数学期望"><a href="#1-数学期望" class="headerlink" title="1.数学期望"></a>1.数学期望</h3><p>a.一维随机变量数学期望的计算</p><p>对于离散型，当级数 $\sum\limits_{i=1}^{\infty}|x_i|p_i$ 收敛，则 X 期望存在，$E(X)=\sum\limits_{i=1}^{\infty}x_ip_i$。</p><p>对于连续型，当 $\int_{-\infty}^{+\infty}|x|f(x)dx$ 收敛时，有期望 $E(X)=\int_{-\infty}^{+\infty}xf(x)dx$ 。发散则不存在，如柯西分布、圣彼得堡悖论。</p><p>二项分布：$E(X)=np$；泊松分布：$E(X)=\lambda$；几何分布 $E(X)=\frac{1}{p}$；均匀分布为中点；正态分布 $E(X)=\mu$ ；指数分布 $E(X)=\frac{1}{\lambda}$ 。</p><p>b.一维随机变量函数的数学期望</p><p>离散型，$E(g(X))=\sum\limits_{k}g(x_k)P(X=x_k)$ （要求 $\sum\limits_{k}|g(x_k)|P(X=x_k)&lt;+\infty$）</p><p>连续型：$\int_{-\infty}^{+\infty}|g(x)|f(x)dx$ 收敛时，有期望 $E(g(x))=\int_{-\infty}^{+\infty}g(x)f(x)dx$ 。</p><p>c.二维随机变量函数的数学期望</p><p>离散型：与一维类似，将取值与对应的概率乘积求和</p><p>连续型：若$\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}g(x,y)f(x,y)dydx$ 绝对收敛，则期望存在。</p><p>特别地，$E(X)=\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}xf(x,y)dydx=\int_{-\infty}^{+\infty}x[\int_{-\infty}^{+\infty}f(x,y)dy]dx=\int_{-\infty}^{+\infty}xf_X(x)dx$</p><p>d.数学期望的部分性质</p><p>如果 $\xi$ 与 $\eta$ 相互独立，$E(\xi\eta)=E(\xi)E(\eta)$；但反之不一定。</p><h3 id="2-随机变量的矩"><a href="#2-随机变量的矩" class="headerlink" title="2.随机变量的矩"></a>2.随机变量的矩</h3><p>a.相关定义</p><p>记 $E[(X-c)^k]$ 为 X 关于 c 的 k 阶矩，当 c = 0 时为 k 阶原点矩 $a_k$，$c=E(X)$ 时为 k 阶中心矩 $\mu_k$。（$\mu$ 有些像以中心为轴左右对称）</p><p>记 $\mu_2$ 为方差。（X 必须有有限的期望）</p><p>$\frac{\mu_3}{\mu^{\frac{3}{2}}_2}$ 为偏度系数，正态分布偏度系数为 0，绝对值越大，离正态分布偏差越大，大于 0 说明右偏。</p><p>$\frac{\mu_4}{\mu^{2}_2}$ 为峰度系数，正态分布为 3。（“偏锋”，从 3 到 4）</p><p>b.随机变量的方差的计算</p><p>$Var(X)=E(X^2)-[E(X)]^2$ （“由内而外”）</p><p>$Var(cX)=c^2Var(X)$</p><p>对于二项分布，其方差有 $Var(X)=np(1-p)=npq$；泊松分布方差 $Var(X)=\lambda$；几何分布方差 $Var(X)=\frac{q}{p^2}$；均匀分布方差 $Var(X)=\frac{(b-a)^2}{12}$；正态分布方差 $Var(X)=\sigma^2$；指数分布方差 $Var(X)=\frac{1}{\lambda^2}$ 。</p><h3 id="3-二维随机向量的协方差"><a href="#3-二维随机向量的协方差" class="headerlink" title="3.二维随机向量的协方差"></a>3.二维随机向量的协方差</h3><p>定义 $Cov(X,Y)=E\{[X-E(X)][Y-E(Y)]\}$，则有 $Var(X)=Cov(X,X)$，$Cov(aX+bY,Z)=aCov(X,Z)+bCov(Y,Z)$；若 X、Y 独立，那么其协方差为 0，但反之不一定。</p><p>$Var(X+Y)=Var(X)+Var(Y)+2Cov(X,Y)$</p><p>注意 $Cov(X,-Y)=-Cov(X,Y)$，有 $Var(X-Y)=Var(X)+Var(Y)-2Cov(X,Y)$。</p><h3 id="4-相关系数"><a href="#4-相关系数" class="headerlink" title="4.相关系数"></a>4.相关系数</h3><p>当 $Var(X)&gt;0$，$Var(Y)&gt;0$ 时，定义相关系数 $r(X,Y)=\frac{Cov(X,Y)}{\sqrt{Var(X)Var(Y)}}$ （也可用 $\rho$），其绝对值总是小于等于 1。当 $\rho=0$ 时，两变量无线性关系；当 $\rho=1$ 时严格正相关，当 $\rho=-1$ 时严格负相关。</p><p>由协方差的性质，当 X、Y 独立时，其相关系数等于 0，但反之不一定成立。也就是说，X、Y 独立，则两者一定不相关，但反之不一定。不过，$(X,Y)$ 服从二维正态分布时，反之也成立。</p><h6 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h6><p><a href="https://zhuanlan.zhihu.com/p/261961315">https://zhuanlan.zhihu.com/p/261961315</a></p><p><a href="https://www.jianshu.com/p/6ee90ba47b4a">https://www.jianshu.com/p/6ee90ba47b4a</a></p><p><a href="https://www.zhihu.com/question/26441147/answer/429569625">https://www.zhihu.com/question/26441147/answer/429569625</a></p><p><a href="https://zhuanlan.zhihu.com/p/36555178">https://zhuanlan.zhihu.com/p/36555178</a></p>]]></content>
    
    
    <categories>
      
      <category>概率论与数理统计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ 类的成员函数访问该类的私有数据成员</title>
    <link href="/2021/05/21/cpp-private/"/>
    <url>/2021/05/21/cpp-private/</url>
    
    <content type="html"><![CDATA[<h1 id="C-类的成员函数访问该类的私有数据成员"><a href="#C-类的成员函数访问该类的私有数据成员" class="headerlink" title="C++ 类的成员函数访问该类的私有数据成员"></a>C++ 类的成员函数访问该类的私有数据成员</h1><p>知乎有<a href="https://www.zhihu.com/question/51218892">同款问题</a>。</p><p>类的成员函数访问该类的私有数据成员时，不因为该私有数据成员不是 this 指针指向的对象持有的而禁止访问。这种控制是基于类的，而不是对象层面的。</p><p>这样的代码将是可以编译的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Object</span>(<span class="hljs-type">int</span> arg):<span class="hljs-built_in">num</span>(arg) &#123;&#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_priv</span><span class="hljs-params">(Object)</span></span>;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> num;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Object::get_priv</span><span class="hljs-params">(Object arg)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> arg.num;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多元函数积分学</title>
    <link href="/2021/05/01/multivarintegral/"/>
    <url>/2021/05/01/multivarintegral/</url>
    
    <content type="html"><![CDATA[<h1 id="多元函数积分学"><a href="#多元函数积分学" class="headerlink" title="多元函数积分学"></a>多元函数积分学</h1><h2 id="零、定积分"><a href="#零、定积分" class="headerlink" title="零、定积分"></a>零、定积分</h2><p>个人的总结先从定积分开始：定积分形如 $\int_{a}^{b}f(x)dx$ ，积分域是一条线段，被积函数 $f(x)$ 是要沿着这条线段（积分域中微小的量）积累的量的函数。如：所谓“曲边梯形的面积”问题中，可以把竖直方向上的长度看成是要被积累的量，沿着线段（x 轴）积累所得。</p><p>计算方法：牛顿-莱布尼茨公式。</p><h2 id="一、二重积分"><a href="#一、二重积分" class="headerlink" title="一、二重积分"></a>一、二重积分</h2><p>对于被积函数是二元函数的情况，使用二重积分来将微小量（小区域）上的被积函数值积累起来。二重积分形如$\iint\limits_{D}f(x, y)d\sigma$，一般在 $xOy$ 平面内，由于是二重积分，书写成两个积分号。这里所有积分得出的都是一个数值，不是向量值。</p><p>计算方法：看成 $x-$ 型区域或 $y-$ 型区域；换元积分；利用极坐标。需要注意的是，由于 $d\sigma = dxdy = dx(u, v)dy(u, v)$ ，换元时要借助雅可比行列式。积分时最好画出被积区域的图像，把“固定”的一个变量书写在左侧的积分号处，把实质上先积分的变量放在右侧，从右往左积分时上下限的字母（积分的“维度”）越来越少，这是因为随着积分从右往左的进行，右侧的积分已经在上下限中包含了左侧上下限不写的字母的边界形状信息。</p><p>如果积分域字母，以 $x$ 为例，具有对称性，当 $f(-x, y)=f(x, y)$ 时，可以把积分域缩减到右侧，将所得的值乘以 2 ；当 $f(-x, y)=-f(x, y)$ 时，关于 $y$ 轴对称的两侧积分域的积分值相抵消。</p><h2 id="二、三重积分"><a href="#二、三重积分" class="headerlink" title="二、三重积分"></a>二、三重积分</h2><p>形如 $\iiint\limits_{\Omega}f(x, y, z)dV$ ，被积函数是三元函数，需要遍历（三维）区域的每个微小的体积量.</p><p>计算方法：直角坐标系：先单后重法（假设高度是用一根顶天花板立地板的竿子测量，把这竿子的高度用位置坐标 x、y 表示出来，再拿着竿子跑遍房间就行）；先重后单法（先积分出房间在高度 z 处的面积，即一层瓷砖覆盖房间的这个高度，再用瓷砖把房间填满）；换元，主要是球面坐标、柱坐标。</p><h2 id="三、第一类曲线积分"><a href="#三、第一类曲线积分" class="headerlink" title="三、第一类曲线积分"></a>三、第一类曲线积分</h2><p>形如 $\int_{C}f(x, y, z)ds$ ，相比定积分，被积函数是个三元函数，也就是空间的一个场，描述了要积累的属性在空间某点的值（定积分也可以看成是三元函数，但由于沿着坐标轴积分，把剩下两个维度忽略了），函数值还是数，但积分域从定积分的线段改成了曲线。</p><p>计算方法：通过换元，把曲线变换成直的，再调用定积分。要注意换元时弧长微分 $ds=\sqrt{x’^2(t)+y’^2(t)+z’^2(t)} dt$ ，无法把 s 分解，也不用再求导。</p><h2 id="四、第二类曲线积分"><a href="#四、第二类曲线积分" class="headerlink" title="四、第二类曲线积分"></a>四、第二类曲线积分</h2><p>第二类曲线积分与第一类曲线积分有较大的差别。第二类曲线积分中被积分的函数是个向量值函数（有方向的场），积分所沿着的曲线也是有向的，沿曲线方向依次取得各点的向量值函数在累加时采用的不是矢量求和，而是与曲线方向的数量积的和，记作 $\int_{L}\pmb{f}\cdot{d\pmb{s}}$ 。</p><p>计算方法：由于被积函数、曲线通常在 $xOy$ 坐标系中表示，可以将被积函数、曲线用 $\vec{i}$、$\vec{j}$、$\vec{k}$ 三个分方向表示出来，由于 ${d\pmb{s}} = \pmb{e_T}ds = \frac{1}{\sqrt{x’(t)^2+y’(t)^2+z’(t)^2}}\{x’(t), y’(t)\}\cdot{\sqrt{x’(t)^2+y’(t)^2+z’(t)^2}dt} = \{x’(t), y’(t)\}$ ，可得出对坐标的曲线积分 $\int_{L}P(x, y)dx+Q(x, y)dy$ ，再进行换元即可。</p><h2 id="五、第一类曲面积分"><a href="#五、第一类曲面积分" class="headerlink" title="五、第一类曲面积分"></a>五、第一类曲面积分</h2><p>二重积分是在 $xOy$ 上进行积分的，而第一类曲面积分将积分域提升到了空间中的曲面。第一类曲面积分形如 $\iint\limits_{S}f(x, y, z)dS$ ，被积函数是三元非向量值函数。</p><p>计算方法：把曲面投影（“拍扁”）到一个平面上，如取 $xOy$ 平面承接投影，则需要把 z 用 x 和 y 表示出来以正确表达原平面，即要有 $z=f(x, y)$ ，移项可得 $f(x, y) - z = 0$ ，求导得法向量 $\{f_x, f_y, -1\}$ ，法向量与 z 轴夹角的余弦值 $\cos{\gamma}=\frac{1}{\sqrt{f_x^2+f_y^2+1}}$ ，可得 $dS={\sqrt{f_x^2+f_y^2+1}}dxdy$，可化为投影到 $xOy$ 平面的二重积分。</p><h2 id="六、第二类曲面积分"><a href="#六、第二类曲面积分" class="headerlink" title="六、第二类曲面积分"></a>六、第二类曲面积分</h2><p>第二类曲面积分与第二类曲线积分有着某种联系，同样是向量值三元函数形成的场，但积分域是有向的空间曲面，其形如 $\iint\limits_{S}\vec{f}(x, y, z)d\vec{S}=\iint\limits_{S}(P\cos{\alpha}+Q\cos{\beta}+R\cos{\gamma})dS=\iint\limits_{S}Pdxdy+Qdydz+Rdzdx$ ，流量可看成流量微元在指定方向曲面上的第二类曲面积分。</p><p>计算方法：虽然与第一类曲面积分同属于曲面积分，但由于被积函数（场）是向量值的，不能仅仅投影到 $xOy$ 等一个平面了事，那样另外两个方向上的分量 $Q\vec{j}$、$R\vec{k}$ 无法计算。为了正确地处理，需要向 $xOy$、 $yOz$、$zOx$​ 三个平面分别投影，与第一类曲面积分一样，再把另一个变量用投影平面两个变量表达出来，代入被积函数，最后站在平面的上方，（如：$zOx$ 平面站在 y 轴正半轴往下看）如果曲面方向指向被观察者，即为正号，否则是负号，即“一投二代三定向”。</p><h2 id="七、格林公式"><a href="#七、格林公式" class="headerlink" title="七、格林公式"></a>七、格林公式</h2><p>$\iint\limits_{D}(\frac{\partial{Q}}{\partial{x}}-\frac{\partial{P}}{\partial{y}})dxdy=\oint_{L}{Pdx+Qdy}$ ，D 是以分段光滑的 L （L取正向）为边界的平面闭区域，且 $P(x, y)$、$Q(x, y)$ 在 D 上有一阶连续偏导数。</p><p>如果闭区域中间有一点使得 P 或 Q 函数无定义，要挖去。</p><p>取 $P=-y$，$Q=x$，可以求出面积。</p><p>格林公式相当于牛顿-莱布尼茨公式，将二重积分与第二类曲线积分联系起来。（在平面上）</p><h2 id="八、保守场与势函数"><a href="#八、保守场与势函数" class="headerlink" title="八、保守场与势函数"></a>八、保守场与势函数</h2><h2 id="九、散度与高斯公式"><a href="#九、散度与高斯公式" class="headerlink" title="九、散度与高斯公式"></a>九、散度与高斯公式</h2><h2 id="十、旋度与斯托克斯公式"><a href="#十、旋度与斯托克斯公式" class="headerlink" title="十、旋度与斯托克斯公式"></a>十、旋度与斯托克斯公式</h2><p>未完待续</p>]]></content>
    
    
    <categories>
      
      <category>工科数学分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ 重载赋值运算符</title>
    <link href="/2021/03/31/assignmentoverride/"/>
    <url>/2021/03/31/assignmentoverride/</url>
    
    <content type="html"><![CDATA[<h1 id="C-重载赋值运算符"><a href="#C-重载赋值运算符" class="headerlink" title="C++ 重载赋值运算符"></a>C++ 重载赋值运算符</h1><p>如果在含有指针数据成员的类中没有重载赋值运算符，赋值时进行浅复制，导致被赋值对象与赋值对象指向同一地址，析构、操作数据成员时会出现不符合期望的结果，因此需要进行深复制。但仅进行深复制仍然是不够完善的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Demo &amp; Demo::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Demo &amp; obj) &#123;<br><span class="hljs-keyword">delete</span> ptr;<br>ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(*obj.ptr);<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码首先释放 Demo 类中的 ptr 指针，但在遇到 <code>assigned = assigned;</code> 这种自赋值情况时，将会错误地释放掉指针所指向的内存，造成崩溃。在开始前进行判断可避免这一情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">Demo &amp; Demo::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Demo &amp; obj) &#123;<br><span class="hljs-keyword">if</span> (&amp;obj != <span class="hljs-keyword">this</span>) &#123;<br><span class="hljs-keyword">delete</span> ptr;<br>ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(*obj.ptr);<br>&#125;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FlexiCharger 减少笔记本电脑电池损耗</title>
    <link href="/2021/02/02/flexicharger/"/>
    <url>/2021/02/02/flexicharger/</url>
    
    <content type="html"><![CDATA[<h1 id="FlexiCharger-减少笔记本电脑电池损耗"><a href="#FlexiCharger-减少笔记本电脑电池损耗" class="headerlink" title="FlexiCharger 减少笔记本电脑电池损耗"></a>FlexiCharger 减少笔记本电脑电池损耗</h1><h2 id="Part-1-背景"><a href="#Part-1-背景" class="headerlink" title="Part 1 背景"></a>Part 1 背景</h2><p>平时常常插电使用笔记本电脑。在我的认知里，插电时会先用电源适配器满足电脑功耗，再给电池充电。但是，<a href="https://www.zhihu.com/question/25416371/answer/629008593">偶然了解到最好不要让电池长期处在电量充满的情况下后</a>，我希望寻找一种方法来阻止电池充满。经过一番搜索，我<a href="https://easyelectriclife.groupe.renault.com/en/glossary/flexi-charger/">找到</a>了我所使用的蓝天 NK 系列模具开启这种机制的方法—— FlexiCharger。</p><h2 id="Part-2-操作步骤"><a href="#Part-2-操作步骤" class="headerlink" title="Part 2 操作步骤"></a>Part 2 操作步骤</h2><p>1.开机按 F2 进入 BIOS，选择 Setup Utility。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20210202001.jpg" alt="BIOS"></p><p>2.找到 Advanced 中的 Advanced Chipset Control，将 FlexiCharger 调整到 Enabled，下面的 Start Charge 和 Stop Charge 分别是插电后开始充电和停止充电的阈值，合理设置即可。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20210202002.jpg" alt="Advanced Chipset Control"></p>]]></content>
    
    
    <categories>
      
      <category>娱乐</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>神船 TX6 安装 ArchLinux</title>
    <link href="/2020/12/25/arch-install/"/>
    <url>/2020/12/25/arch-install/</url>
    
    <content type="html"><![CDATA[<h1 id="神船-TX6-安装-ArchLinux"><a href="#神船-TX6-安装-ArchLinux" class="headerlink" title="神船 TX6 安装 ArchLinux"></a>神船 TX6 安装 ArchLinux</h1><p>警告！本文可能有大量图片，流量消耗大。</p><p>本文为安装完毕一个多月后撰写，部分回忆可能与事实有所出入，仅供参考。</p><h2 id="Part-1-准备工作"><a href="#Part-1-准备工作" class="headerlink" title="Part 1 准备工作"></a>Part 1 准备工作</h2><p>由于原装 SSD 使用的是被认为较差的群联 PS3111 主控且运行在 SATA 速率下，我选择加装一条 NVMe 的 SSD。蓝天的 NK60SB 模具拥有第二个 M.2 2280 硬盘位，且为 PCIe 3.0 × 4 速率。（在这里补充一下，固件里面可能写的模具是 NKx0Sx，其中 NK50、NK60、NK70 分别对应 15.6 吋、16.1 吋、17.3 吋的屏幕，NK50SZ 无独显，NK50S5 搭载 NVIDIA GeForce MX350 独显，NK50/60/70 后缀 SB 对应 GTX1650，SE 对应 GTX1650Ti，但可能识别是 NKx0Sx，参考神舟的<a href="http://kfgl.hasee.com/lookup/book/bblist.asp">网站</a>）为了管理方便，NVMe 固态“象征性地”在 Windows 下分出 5GiB，其余容量全部不分配。</p><p>虽然安装 ArchLinux 和 WinPE 没啥关系，但为了防止哪天 Win 出问题，我打算顺便创建一个 WinPE 的启动盘。</p><p>在这里，我选择使用 U 盘安装。参考 <a href="https://zhuanlan.zhihu.com/p/31361497">macOS、Windows 10、GParted Live、WinPE 多种操作系统，用一个 U 盘搞定 - 知乎</a>，选择使用 DiskGenius 为 U 盘创建两个 FAT32 的文件分区，第一个分区 3.1GiB，第二个 4.1GiB，用来实现 ArchLinux Live Install 和启动 WinPE。为了方便，可以设置不同的卷标。为了省事，我没有格式化，而是把原有的文件扔进了 PE 的分区。分区后，从 ArchLinux 网站（<a href="https://archlinux.org/download">https://archlinux.org/download</a> ）下载 x86_64 的安装 ISO，用资源管理器装载后把文件复制进第一个分区。下载安装 AOMEI PE Builder，安装，生成 ISO 文件后用同样的方法复制进第二个分区。</p><p>需要注意的是，如果 AOMEI PE Builder 下载缓慢的话，可以用我分享的版本：链接: <a href="https://pan.baidu.com/s/1C3O-OAkBika2yj4UGAU1xw">https://pan.baidu.com/s/1C3O-OAkBika2yj4UGAU1xw</a> 提取码: mfi5，将里面的目录复制到你的下载目录，这个目录在 PE Builder 安装位置的 DownloadPath.ini 文件中有指定。</p><p><img src="https://zhaozihanzzh.github.io/images/aomei_prog.jpg" alt="aomei_prog"></p><p>之后插入 U 盘，在 BIOS 里面 Boot Manager 可以选择 EFI Boot Devices 了，可以进入 AOMEI PE Builder，发现一切正常，也可以进入 ArchISO 看一看。</p><p><img src="https://zhaozihanzzh.github.io/images/sel_boot.jpg" alt="sel_boot"></p><p><img src="https://zhaozihanzzh.github.io/images/aomei_desktop.jpg" alt="aomei_desktop"></p><p><img src="https://zhaozihanzzh.github.io/images/archiso_menu.jpg" alt="archiso_menu"></p><p>然后，尴尬的事情发生了。一直出现</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">Waiting 30 seconds for device /dev/disk/by-label/ARCH_202011 ...<br><br>ERROR: &#x27;/dev/disk/by-label/ARCH_202011&#x27; device did not show up after 30 seconds...<br><br>​Falling back to interactive prompt<br><br>​You can try to fix the problem manually, log out when you are finished<br><br>sh: can&#x27;t access tty: job control turned off<br></code></pre></td></tr></table></figure><p><img src="https://zhaozihanzzh.github.io/images/starterr.jpg" alt="starterr"></p><p>不得已，我只好格式化 U 盘，这次用 DiskGenius 来往分区里写文件，一番操作后，终于成功启动 LiveCD 了。</p><p><img src="https://zhaozihanzzh.github.io/images/copyiso.png" alt="copyiso"></p><p>为了避免需要在浏览器中登录 WiFi，我使用手机连接 WiFi 后开启 WLAN 信号桥，中继出一个不需要浏览器认证的网络。</p><p><img src="https://zhaozihanzzh.github.io/images/WLANBridge.jpg" alt="WLANBridge"></p><h2 id="Part-2-安装"><a href="#Part-2-安装" class="headerlink" title="Part 2 安装"></a>Part 2 安装</h2><p>整个安装过程，参考以下文章，请以官方 Wiki 为准：<a href="https://wiki.archlinux.org/index.php/Installation_guide_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">Installation guide (简体中文) - ArchWiki</a></p><p><a href="https://zhuanlan.zhihu.com/p/99448314">ArchLinux安装(UEFI) - 知乎</a></p><p><a href="https://www.zhihu.com/question/21427410/answer/171867330">Arch Linux 怎么安装？ - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/202914804">Arch Linux 安装指南 2020.08 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/138951848">2020 Archlinux双系统安装教程（超详细） - 知乎</a></p><p>如果 CAPS-LOCK 按键无法使用，按住 Shift 的同时按下字母键来输入大写字母。</p><p>1.关闭 Win10 的“快速启动”功能（我安装时并没有关闭，漏掉了这一步），重启进入 BIOS，从 U 盘启动 ArchISO，键入以下命令以验证启动模式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls /sys/firmware/efi/efivars<br></code></pre></td></tr></table></figure><p>目录被正常显示，说明我使用的是 UEFI 模式启动。</p><p>接下来我们使用 iwctl 连接 WiFi，键入 <code>iwctl</code> 后使用 <code>device list</code> 命令列出可用的无线网卡，使用 <code>station 网卡名 scan</code> 来扫描后用 <code>station 网卡名 get-networks</code> 列出扫描到的热点，使用 <code>iwctl --passphrase 密码 station 网卡名 connect SSID</code> 连接，之后按 CtrlD 退出 iwctl。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121001.jpg" alt="image-20201121001"></p><p>2.使用 <code>ping archlinux.org</code> 检查能否连接 archlinux 网站，之后使用 <code>timedatectl set-ntp true</code> 命令确保系统时间准确（我当时好像没有检查时间，有些图片缺失）</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121002.jpg" alt="image-20201121002"></p><p>3.使用 <code>fdisk -l</code> 命令查看块设备，发现我们的目标磁盘块设备文件为 /dev/nvme0n1（Linux 中有“一切都是文件”一说），使用 gpt 磁盘分区表，接下来确定分区方案。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121003.jpg" alt="image-20201121003"></p><p>分区参考了 <a href="https://www.zhihu.com/question/25118984/answer/567568759">Linux 桌面用户是否有对 /boot 单独分区的必要？ - 知乎</a>、<a href="https://wiki.archlinux.org/index.php/Partitioning_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">Partitioning (简体中文) - ArchWiki</a>，为了简便选择不设立 swap 分区，选择使用 cfdisk 工具（应该是？）：<code>cfdisk 块设备路径</code> 后会进入一个互动式的界面，在这里我给剩余空间分出 2GiB 留作 EFI 引导和 boot 用（这块硬盘上原来是没有 EFI 分区的），分出 32GiB 作为根目录所需，另外在结尾预留 1.9 GiB 以备以后扩展或修正等后其余容量留给主目录，分区类型分别为 EFI System，Linux root (x86-64)，Linux filesystem，确认磁盘上原有的分区没有被错误地修改后即可写入新的分区，注意要记住你创建的分区的块设备文件，在本例中是屏幕最左侧的那一列。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121004.jpg" alt="image-20201121004"></p><p>4.创建分区完毕后对其进行格式化，Linux 有许多不同的文件系统，但由于本人对文件系统不甚了解，最终为根目录和主目录选择较老的 ext4 文件系统：<code>mkfs.ext4 块设备文件</code>，而根据 Wiki，UEFI 推荐使用 FAT32 文件系统：<code>mkfs.fat -F32 块设备文件</code>。之后进行挂载分区，在这里我把根目录的块设备挂载到 /mnt（<code>mount 块设备 挂载点</code>），之后执行 <code>mkdir /mnt/efi</code>、<code>mkdir /mnt/home</code> 为 EFI 和主目录创建挂载点并挂载。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121005.jpg" alt="image-20201121005"></p><p>5.使用 pacstrap 安装脚本安装 base 软件包、Linux 内核和常规硬件的固件（这里我没有使用 LTS 内核之类的），这里 <code>/mnt</code> 是根目录的挂载点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacstrap /mnt base linux linux-firmware<br></code></pre></td></tr></table></figure><p><img src="https://zhaozihanzzh.github.io/images/image-20201121006.jpg" alt="image-20201121006"></p><p>注意，这里日志中输出的几个关于 aic94xx，wd719x，xhci_pci 的 WARNING 可以参见 Wiki 说明：<a href="https://wiki.archlinux.org/index.php/Mkinitcpio#Possibly_missing_firmware_for_module_XXXX">mkinitcpio - ArchWiki</a>。</p><p>接下来创建分区表（/mnt 仍然是根目录挂载点）： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab<br></code></pre></td></tr></table></figure><p>接着检查一下创建的分区表 /mnt/etc/fstab：<img src="https://zhaozihanzzh.github.io/images/image-20201121007.jpg" alt="image-20201121007"></p><p>6.chroot 进安装的系统环境：<code>arch-chroot /mnt</code>（/mnt 为根目录挂载点），之后执行 <code>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code> 设置为上海（东八区）时间，执行 <code>hwclock --systohc</code> 命令，到此时间设置完毕。 </p><p>7.编辑 /etc/locale.gen 这个文本文件，在此我通过取消对应行前面的注释（即删除 # 号）来将 locale 设置为 en_US.UTF-8，不设置为中文的理由可以见官方 Wiki，据说会使 tty 乱码。之后，在终端执行 locale-gen 命令，然后，同样地创建 /etc/locale.conf，写入：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">LANG=en_US.UTF-8<br></code></pre></td></tr></table></figure><p>8.为你的机器想一个 hostname 来替换这一步的所有 myhostname：</p><p>创建 /etc/hostname，写入以下内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">myhostname<br></code></pre></td></tr></table></figure><p>在 /etc/hosts 添加对应的信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">127.0.0.1localhost<br>::1    localhost<br>127.0.1.1myhostname.localdomainmyhostname<br></code></pre></td></tr></table></figure><p> 使用 passwd 命令，为 root 用户设置密码。就算你用 sudo，这步也十分重要。</p><p>9.最后安装启动引导，对于我使用的 GPT 分区表 + UEFI 系统，需要安装 grub 和 efibootmgr 软件包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -S grub efibootmgr<br></code></pre></td></tr></table></figure><p>如果你想让 GRUB 自动检测到 Windows 的存在并自动配置好 Windows 的启动条目的话，还需要安装 os-prober 和 ntfs-3g。</p><p>之后执行  <code>grub-install --target=x86_64-efi --efi-directory=/efi --bootloader-id=GRUB</code>。这里的 /efi 是我为 EFI 系统选择的挂载点，最后的 grub 是启动引导器标识，详见 wik，这一步将把 GRUB EFI 安装到 挂载点/EFI/启动引导器标识 路径。之后，执行 <code>grub-mkconfig -o /boot/grub/grub.cfg</code> 来生成配置文件。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121008.jpg" alt="image-20201121008"></p><p>10.到这里可能就可以重启了，可能最好在此之前安装联网相关的软件包，但我已经不记得当时进行了什么操作。按 Ctrl + C 退出 chroot，之后 <code>umount -R 挂载点</code> 以卸载分区，使用 reboot 以重启。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121009.jpg" alt="image-20201121009"></p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121011.jpg" alt="image-20201121011"></p><h2 id="Part-3-锦上添花"><a href="#Part-3-锦上添花" class="headerlink" title="Part 3 锦上添花"></a>Part 3 锦上添花</h2><p>1.电脑时间问题</p><p><a href="https://sspai.com/post/55983">Linux Windows 双系统时间不一致 - 少数派</a></p><p>2.添加用户及 sudo</p><p>以下大部分内容可以在这里找到答案：</p><p><a href="https://wiki.archlinux.org/index.php/General_recommendations">General recommendations - ArchWiki</a></p><p>3.安装桌面环境（DE）</p><p>在这里，我选择 SDDM 作为显示管理器， KDE 作为桌面环境。但是，我安装 KDE 时选择的是 plasma-desktop 这一“最小化安装”，导致安装出来竟然在图形界面没有提供终端模拟器，最后按 Ctrl + Alt + F2 登录进另一个 tty 后手动安装了 konsole 软件包才得以解决。事后我还安装了 dolphin 和 ark。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121012.jpg" alt="image-20201121012"></p><p>4.安装字体</p><p>5.NVIDIA 独显驱动</p><p>我的 Intel Graphics UHD 630集成显卡一开始使用的是 mesa 软件包，希望使用 bumblebee 来实现双显卡切换，最终我的机器不仅无法启动图形界面，连其他的 tty 都无法开启，只好又插上了 ArchISO，卸载了 bumblebee，决定使用 PRIME 方案，结果，Arch wiki 里面nvidia-xconfig 的配置直接让我无法进入 KDE。我发现我的情况似乎与 wiki 上不一致，后来的一些研究为我提供了帮助：<a href="https://forums.developer.nvidia.com/t/archlinux-nvidia-settings-error-unable-to-load-info-from-any-available-system/111170">ArchLinux nvidia-settings ERROR: Unable to load info from any available system</a> 。以下网页说，现代系统不需要 nvidia-xconfig 了。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121010.jpg" alt="image-20201121010"></p><p>6.键盘背光</p><p>根据网络上的提示，我成功地为 NK60SB 开启了键盘背光，编译了<a href="https://github.com/zhaozihanzzh/clevo-xsm-wmi/commit/5d855522fbd18ddd6b2e3ba91632df909189c9dd">相关驱动</a>。</p><p>7.续航测试</p><p>某日，在图书馆没有能充电的位置了，顺便进行测试：屏幕亮度 20%，连接 WiFi，关闭蓝牙，开启独显（如果我没有配置错误的话）。机器电池 47 WHr，采用 Intel i5-10400 CPU，NVIDIA GeForce GTX1650 独显，16.1吋 60Hz 1080P 屏幕，进行少量网页浏览，主要是 WPS PDF 浏览和 WPS 文字编辑。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201128001.png" alt="image-20201128001"></p><p>8.开启蓝牙</p><p><a href="https://wiki.archlinux.org/index.php/Bluetooth_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">Wiki</a> 中提供了步骤，注意我的机器需要疑难解答中的步骤才能与手机配对。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>通用学术英语词表配套练习</title>
    <link href="/2020/12/18/general-academic-words/"/>
    <url>/2020/12/18/general-academic-words/</url>
    
    <content type="html"><![CDATA[<h1 id="通用学术英语词表配套练习"><a href="#通用学术英语词表配套练习" class="headerlink" title="通用学术英语词表配套练习"></a>通用学术英语词表配套练习</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>perform … analysis 进行 … 分析<br>approach the limit 接近限值<br>area 面积<br>assessment 评估<br>assume 假定，设想<br>authority 权力<br>little information is available on …<br>benefit 收益<br>concept 观念<br>be consistent with 与…一致<br>constitutional reform 宪政改革<br>in the context of 在…具体背景下<br>under the contract 依据合同<br>create flexibility 带来灵活性<br>data 资料<br>high definition 高清<br>be derived from 来源于，衍生于<br>division 分工 distribution 分布 circulation 流通<br>sth. is well established 某事物被认可接受<br>estimate the cost of … at 预估某事完成的成本是 …<br>evidence 证据，不可数名词<br>export 资料等导出<br>factor 因素 point 观点<br>formula 公式<br>fulfil … function 发挥作用<br>be identified as 被确认为 be associated with 有关联<br>per capita income 人均收入<br>indicate 表明<br>interpretation 理解<br>involve 是 … 的一部分，是 … 的结果<br>issue 议题<br>legislation 立法，法律<br>proportion of 前面不加具体数词<br>fiscal 财政的<br>in principle 理论上，原则上<br>procedure 程序<br>proceed 前进<br>qualitative research 定性研究<br>private sector 民营部门，私人部门（sector 扇形，扇区，部门）<br>indifferent 冷淡的，不关心的<br>commonplace 平凡的<br>incline to 倾向于<br>contamination 污染<br>specific provision 特定条款<br>generalization 概括</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>achieve the purpose 达到目的<br>acquisition 获得<br>headquarter 总部<br>alienation 疏远<br>supervision 监督<br>fall into … categories 分为 … 类型<br>commission 委任<br>residence 住所<br>load 传输<br>consequence analysis 结果分析<br>give/deserve/take credit for 因为 … 而受到应有的赞扬<br>demonstration 演示<br>specialty 专业，地方特产<br>final 最终的 eventual 过程和时间上的最终结果<br>suffer injury 受伤<br>journal 某学科或专业的刊物<br>provision 提供 precaution 预防<br>obtain a result 得到结果<br>be perceived to be 被认为是<br>respective 各自的<br>elemental 基础的<br>seek methodologies 寻求方法<br>competence 能力<br>transition 过渡</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>一般情况下，another之后只能接单数名词，如：another student。如果another后的名词有数词或few修饰时，则也可接复数名词，如：another few days.（另外几天）、another five chairs.（另外五把椅子）<br>（摘自 <a href="https://www.yikaow.com/yikao/57644.html）">https://www.yikaow.com/yikao/57644.html）</a><br>compensation 赔偿<br>consent 同意<br>impose constraint 施加约束<br>naming convention 命名约定<br>coordination 协同</p><p>只有一部分，见谅。</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图论</title>
    <link href="/2020/12/08/graph-theory/"/>
    <url>/2020/12/08/graph-theory/</url>
    
    <content type="html"><![CDATA[<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><p>简单辨析一些问题：</p><h2 id="一、图的基本组成"><a href="#一、图的基本组成" class="headerlink" title="一、图的基本组成"></a>一、图的基本组成</h2><p>1.图，组成，无向有向问题</p><p>2.平行边（注意有向图里情况），结点邻接，环（注意度数），孤立点，边关联于结点，边集元素重复，n 阶图？零图？平凡图？空图（及符号表示）？结点的度数，入度，出度（重复的边算吗，符号表示）？最大/小度及其符号？悬挂结点/边？图的度数序列？</p><p>3.简单图？多重图？n 阶无向完全图及符号表示？有向完全图？默认的完全图？n 阶有向/无向完全图的边数？什么是 k - 正则图？n 阶无向完全图是 (n-1) - 正则图吗 ？什么是环图？什么是轮图？轮图最低阶数？什么是 n 方体图？二分图？完全二分图及其记法？带权图的权在边上还是结点，还是都行？</p><p>4.删除边/边集/结点/结点集运算？边的收缩及其符号？加新边及其符号？子图 / 母图？生成子图？由结点集 / 边集导出子图及其符号？<em>G</em>(<em>E</em>-<em>E<sub>1</sub></em>) 与 <em>G</em>-<em>E<sub>1</sub></em> 的区别？<em>G</em> 的补图与符号表示？（注意其结点）图的同构，自互补图？</p><p>5.通路，简单通路，基本通路（又叫初级通路，路径）；回路，简单回路，基本回路（又叫初级回路、圈），奇 / 偶回路，短程线与<em>d</em>(u, v)，连通图、非连通图（无向图）？连通关系（无向图）？连通关系是等价关系吗？<em>W</em>(<em>G</em>) 指什么？简单图里 n-w&lt;=e？点割集与割点？边割集与割边（桥）？可达、相互可达（有向图）？有向图中：单向连通？强连通 / 弱连通？单向连通一定是弱连通？有向连通图？强分图？强连通图判定定理（有点像废话）？</p><p>6.邻接表（局限，有向图、无向图上的表现），有向图的邻接矩阵及某行 / 列和的意义？有向图邻接矩阵 k 次幂的元素意义？无向图的邻接矩阵及其幂？如何通过邻接矩阵判断图的连通性？邻接矩阵与同构的关系？什么是有向图的可达矩阵？怎么利用可达矩阵求强连通分支？什么是有向图的关联矩阵？什么是无向图的关联矩阵（行列代表什么？什么情况下元素为 2 ？每行元素和代表？）<br>邻接，可达，关联矩阵各有什么字母？</p><h2 id="二、特殊图"><a href="#二、特殊图" class="headerlink" title="二、特殊图"></a>二、特殊图</h2><p>1.欧拉回路，欧拉通路，欧拉图，半欧拉图？欧拉图的判定？半欧拉图呢？欧拉有向图、半欧拉有向图中的“有向”？欧拉有向图/半欧拉有向图的充要条件？（半）哈密顿回路 / 图（像欧拉图一样分有向无向吗）？判定哈密顿图的两个充分条件、一个必要条件？半哈密顿图的充分条件？彼得森图？格雷码？格雷码怎么找？</p><p>2.旅行商问题？最短路径问题及 Dijkstra 算法？中国邮路问题？</p><p>3.匹配？极大匹配？最大匹配？（VS 最大元，极大元）<em>M</em> 饱和点 / 非饱和点？完美匹配？<em>M</em> 交错路？<em>M</em> 可扩充路？最大匹配判定定理？</p><p>4.二分图？怎么判断一个图是不是二分图？互补结点集？完全二分图及其符号表示？完全二分图充要条件？【弄错了？】二分图的完备匹配 / 完美匹配？从 <em>V<sub>1</sub></em> 到 <em>V<sub>2</sub></em> 的完备匹配呢？怎么判断二分图是否存在完备匹配？ t 条件是二分图完备匹配存在的充分条件还是必要条件？</p><p>5.平面图？平面嵌入？<em>G</em> 的面？<em>f<sub>0</sub></em> 的中文名与意义？<em>f<sub>1</sub></em> ，<em>f<sub>2</sub></em> …呢？面的边界？deg(<em>f</em>)？∑deg(<em>f<sub>i</sub></em>) 与 e 的关系？连通平面图的欧拉公式与记忆技巧？非连通的平面图呢？什么叫两个图同胚？判定一个图是平面图的充要条件？</p><p>6.<em>G</em>* 是什么，怎么作？<em>G</em>* 是连通的吗？与原图的结点数，面数，边数关系？同构平面图的对偶图也一定同构吗？<em>G</em>* 的对偶图的对偶图和 <em>G</em>* 一定同构吗？什么是对简单图（结点）着色？什么是 k - 可着色的？什么是色数和 k 色图？无环图色数最大是？Brooks 定理（ <em>G</em> 不是完全图或长度为奇数的基本回路时色数最大值）？二分图的色数？色数为 2 能否说明是二分图？k - 可边着色？简单图的边色数？二分图的边色数？</p><h2 id="三、树"><a href="#三、树" class="headerlink" title="三、树"></a>三、树</h2><p>1.无向树？无向树的树叶、分支点、内点？平凡树？森林？<em>T</em> 是连通图且 e=n-1 能判定是无向树吗？<em>T</em> 无回路且 e=n-1 能判定是无向树吗？<em>T</em> 无回路且任意两结点间增加一条边，得到一条且仅一条回路，能判定 <em>T</em> 是无向树吗？证明 <em>T</em> 中结点数不小于 2 时 <em>T</em> 至少有两片树叶。生成树，弦，余树。图 <em>G</em> 有生成树的等价条件。给出求无向连通图的生成树的算法？给出求无向连通图的最小生成树的算法？</p><p>2.有向树？其边的方向是怎样的？有向根树？有向根树的树叶、分支点、树根、内点的定义？某结点的级数（层数）的定义，树的高度的定义？结点间的关系：祖先，后代，父子，兄弟？什么是根子树？什么是 m 元树，m 元正则树，完全 m 元正则树，完全 m 元树（学校的定义）？m 元正则树中结点数，分支点数，m 的关系？利用此关系与定义，能否互推出结点数、分支点数、树叶数的关系式？高为 h 的 m 元树里至多有多少树叶？</p><p>3.什么是有序根树？二元有序根树的左儿子，右儿子，左子树，右子树？介绍二元有序根树的前序遍历算法，中序遍历算法，后序遍历算法？什么是波兰、逆波兰记法？前缀码与二元树？前缀码是唯一的吗？如何生成最优二元树，最佳前缀码？</p><h2 id="四、证明定理："><a href="#四、证明定理：" class="headerlink" title="四、证明定理："></a>四、证明定理：</h2><p>握手定理+性质。（单独的度数可以用求和的方法转到度数和再借助不等式求解）结点总数超过 3 时平面简单图中每个面次数至少为 3。</p><p>某些定量性质：</p><p>图论基本定理（握手定理）？度数为奇数的结点一定有偶数个吗？有向图中所有结点入度之和与出度之和等于什么？怎么判断自然数序列是不是图的度数序列？</p><p>简单图里 n-w&lt;=e？</p><p>连通平面图的欧拉公式</p><p>m 元正则树中结点数，分支点数， m 的关系？利用此关系与定义，能否互推出结点数、分支点数、树叶数的关系式？高为 h 的 m 元树里至多有多少树叶？</p><p>旅行商问题？最短路径问题及 Dijkstra 算法？中国邮路问题？</p><p><em>G</em>* 是什么，怎么作？</p><p>介绍二元有序根树的前序遍历算法，中序遍历算法，后序遍历算法？</p><p>如何生成最优二元树，最佳前缀码？</p><h2 id="五、部分错题"><a href="#五、部分错题" class="headerlink" title="五、部分错题"></a>五、部分错题</h2><p>1.把平面分成 x 个区域，每两个区域相邻，问 x 最大为？</p><p>我的答案：5 正确答案：4</p><p>2.给设 d=(d<sub>1</sub>, d<sub>2</sub>, …, d<sub>n</sub>)，其中 d<sub>i</sub> 为正数，i = 1, 2, …, n。若存在 n 个结点的简单图，使得结点 v<sub>i</sub> 的度数为 d<sub>i</sub>，则称 d 是可图解的。下面给出的各序列中，（  ）不是可图解的。</p><p>A. (1, 1, 1, 2, 3) B. (2, 3, 3, 4, 5, 6) C. (0, 1, 1, 2, 3, 3) D. (1, 3, 3, 4, 5, 6, 6) E. (1, 2, 2, 3, 4, 5)</p><p>我的答案：B E 正确答案：B D E</p><p>3.设 G 是一棵根树，则 G 一定是（  ）</p><p>A. 强连通图 B. 单向连通图 C. 弱连通图 D. 有向连通图</p><p>我的答案：B C D 正确答案：C D</p><p>4.若有向图中无回路，则其每条边都是割边。</p><p>我的答案：对 正确答案：错</p><p>5.K<sub>m,n</sub>，当 m 不等于 n 时不是哈密顿图。</p><p>我的答案：错 正确答案：对</p>]]></content>
    
    
    <categories>
      
      <category>离散数学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>神船 TX6 加致钛 PC005 Active SSD</title>
    <link href="/2020/11/13/ztpc005/"/>
    <url>/2020/11/13/ztpc005/</url>
    
    <content type="html"><![CDATA[<h1 id="神船-TX6-加致钛-PC005-Active-SSD"><a href="#神船-TX6-加致钛-PC005-Active-SSD" class="headerlink" title="神船 TX6 加致钛 PC005 Active SSD"></a>神船 TX6 加致钛 PC005 Active SSD</h1><h2 id="Part-1-安装"><a href="#Part-1-安装" class="headerlink" title="Part 1 安装"></a>Part 1 安装</h2><p>首先，确保机器断电，移除外置电池，用螺丝刀（我的是直径 3mm 的十字螺丝刀）卸下 D 面的 6 颗螺丝。</p><p><img src="https://zhaozihanzzh.github.io/images/7bf1a1d0297cfc72.jpg" alt="7bf1a1d0297cfc72"></p><p><img src="https://zhaozihanzzh.github.io/images/19cb84b171e24f73.jpg" alt="image-20201114011201054"></p><p>然后，准备好 M.2 SSD 的固定螺丝。我从京东自营购入，对方表示不带螺丝。（这里这个螺丝与我的螺丝刀略微不匹配，应该使用略小一点的。用我这个拧神船自带那块固态的螺丝，会直接滑丝）于是只好单独购买……搞这么大盒子，其实只有六个小小的螺丝……</p><p><img src="https://zhaozihanzzh.github.io/images/3089e9848921c7b7.jpg" alt="3089e9848921c7b7"><img src="https://zhaozihanzzh.github.io/images/2484e133816dcf08.jpg" alt="2484e133816dcf08"></p><p><img src="https://zhaozihanzzh.github.io/images/-5afe891743a5908f.jpg" alt="image-20201114011308540"></p><p><img src="https://zhaozihanzzh.github.io/images/57b5dcaf1d9f990f.jpg" alt="image-20201114011323631"></p><p>开箱，取出盘的本体。</p><p><img src="https://zhaozihanzzh.github.io/images/IMG_20201114_010645.jpg" alt="image-20201114011452363"></p><p>放掉身上可能存在的静电，将硬盘一端呈 45° 插入插槽（注意缺口），之后按下并用螺丝固定好。</p><p>因为要加散热片，我就不把 D 面扣上，只是拿 D 面垫着，直接开机。</p><h2 id="Part-2-娱乐测试"><a href="#Part-2-娱乐测试" class="headerlink" title="Part 2 娱乐测试"></a>Part 2 娱乐测试</h2><p><img src="https://zhaozihanzzh.github.io/images/QQ20201121113026.jpg" alt="QQ20201121113026"></p><p>开机后进行格式化。</p><p><img src="https://zhaozihanzzh.github.io/images/IMG_20201114_013228.png" alt="IMG_20201114_013228"></p><p>按照默认设置，结束后，空盘情况下进行一番娱乐：</p><p><img src="https://zhaozihanzzh.github.io/images/04.png" alt="04"></p><p><img src="https://zhaozihanzzh.github.io/images/760d06b46c661b62.png" alt="760d06b46c661b62"></p><p>从中可以看到，在 CrystalDiskMark 中，SSD 温度多次接近 70℃ ，甚至直接撞上 75℃ （貌似温度墙？）不过待机情况下倒是没那么夸张（我拆了 D 面？）。</p><p><img src="https://zhaozihanzzh.github.io/images/IMG_20201114_013548.jpg" alt="IMG_20201114_013548"></p><p><img src="https://zhaozihanzzh.github.io/images/IMG_20201114_013447.jpg" alt="IMG_20201114_013447"></p><p>另外，长江存储官网也有一个对应的工具 YMTC Smart Tool。</p><p><img src="https://zhaozihanzzh.github.io/images/-73937f4019225a34.jpg" alt="-73937f4019225a34"></p><h2 id="Part-3-散热片"><a href="#Part-3-散热片" class="headerlink" title="Part 3 散热片"></a>Part 3 散热片</h2><p>买之前就从各评测看到极端情况下这块 SSD 主控频繁撞温度墙，于是整了这么些东西……</p><p><img src="https://zhaozihanzzh.github.io/images/-372f6c991f7ffb4a.jpg" alt="-372f6c991f7ffb4a"></p><p>那个反光的东西是铜片，拍出来颜色都变了。另外感觉少了一点什么？</p><p>把导热硅片表面的膜撕下（爱撕机膜人），压在盘的芯片面，等按压凹陷平整后把铜片盖上。硅片黏性大，进行操作时最好保持清洁。另外我这块略微有点不太矩形？</p><p><img src="https://zhaozihanzzh.github.io/images/QQ20201121114408.jpg" alt="QQ20201121114408"></p><p>感觉不算厚，起码顶后盖的情况在我这里是没有的。</p><p><img src="https://zhaozihanzzh.github.io/images/QQ20201121114412.jpg" alt="QQ20201121114412"></p><p>压铜片时注意位置，我第一次太靠螺丝孔一侧，导致螺丝拧不上去，只得拆了重新装。由于硅片很黏，我掰开的时候一直担心会不会把芯片给揭掉……不过没有。另外，我没用那个橡皮筋，有一点点担心盘会被弄弯曲。我想这铜片可能不太容易掉下来的吧？</p><p><img src="https://zhaozihanzzh.github.io/images/QQ20201121114334.jpg" alt="QQ20201121114334"></p><p>然后，我并没有进行进一步的测试。（挨打中）</p>]]></content>
    
    
    <categories>
      
      <category>娱乐</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关系和函数</title>
    <link href="/2020/11/02/relations-functions/"/>
    <url>/2020/11/02/relations-functions/</url>
    
    <content type="html"><![CDATA[<h1 id="关系和函数"><a href="#关系和函数" class="headerlink" title="关系和函数"></a>关系和函数</h1><p>简单辨析一些问题：</p><p>有序对，有序 n 元组</p><p>笛卡尔积（直积）</p><p>关系（二元关系）及符号表示，从 A 到 B 的二元关系， A 上的二元关系，E<sub>A</sub>，I<sub>A</sub>，二元关系是一个有序对吗？</p><p>二元关系与有序对构成的集合是否等价？</p><p>二元关系的定义域（前域）、值域（后域）、域及其符号表示？</p><p>关系的表示：集合，关系图（注意 A 到 B 上的与 A 上的），邻接矩阵</p><p>关系的逆</p><p>对关系的并，交，补，差，包含等的结果求逆与对关系求逆后再进行运算相同吗？</p><p>关系的复合运算本质？集合描述时注意换元？满足交换律吗？结合律呢？</p><p>判断复合运算对并运算、交运算的分配情况：<br>$$(S\cup P)\circ R\ 与 \ (S\circ R)\cup (P\circ R)$$$$R\circ (S\cup P)\ 与\ (R\circ S)\cup (R\circ P)$$$$(S\cap P)\circ R\ 与\ (S\circ R)\cap (P\circ R)$$$$R\circ (S\cap P)\ 与\ (R\circ S)\cap (R\circ P)$$对关系的复合运算求逆的规则是怎样的？</p><p>关系 R 的 n 次幂是如何定义的？周期性是怎么回事？</p><p>关系矩阵？复合关系的关系矩阵与原来的两个矩阵之间的关系？在这里如何求关系矩阵的乘积？</p><p>关系的性质：什么是自反关系，反自反关系，对称关系，反对称关系，传递关系？</p><p>关系闭包的概念？r(R)，s(R)，t(R) 分别是？怎么求关系的自反闭包、对称闭包、传递闭包？</p><p>当非空集合上两个关系存在包含关系时，其闭包是否也存在包含关系？</p><p>思考以下闭包的并集与并集的闭包的关系？（如果有思考难度，可以考虑举例，特别注意传递闭包）（仍然是非空集合上的）$$r(R_1)\cup r(R_2)\ 与\ r(R_1\cup R_2)$$$$s(R_1)\cup s(R_2)\ 与\ s(R_1\cup R_2)$$$$t(R_1)\cup t(R_2)\ 与\ t(R_1\cup R_2)$$若 R 是传递的，s(R) 一定是传递的吗？r(R) 呢？</p><p>能用关系矩阵的运算来求关系的关系闭包吗？</p><p>什么是 Warshall 算法？</p><p>什么是等价关系？等价关系中的一对有序对中的两个元素可以被称为“等价”吗？</p><p>[x]<sub>R</sub> 是什么？等价类是一个集合吗？A/R 是什么？</p><p>什么是一个集合的覆盖和划分？覆盖中的元素能是空集吗？什么是划分中的类/块？划分与商集的关系？划分的元素是？</p><p>什么是偏序关系？什么是偏序集？符号表示？</p><p>什么是可比？什么是不可比？什么是覆盖？哈斯图怎么画？</p><p>可比与全序关系、全序集？</p><p>极小元、最小元、极大元、最大元？</p><p>（集合）上界、下界、上确界、下确界？</p><p>良序集与良序关系？为什么说良序集一定是全序集，全序集不一定是良序集？</p><p>函数的像、原像？函数是一种集合吗？</p><p>B<sup>A</sup> 是什么集合？这种符号与其元素个数有什么关系？</p><p>单射函数、满射函数、双射函数？恒等函数、特征函数？自然映射？</p><p>复合函数的反函数与反函数的复合存在怎样的关系？</p><p>什么是等势？什么是有限集合的基数？可数集、可列集、阿列夫零、0 级无穷大？实数集的基数、1 级无穷大、阿列夫？</p><p>有最大的基数和最大的集合吗？</p><p>补充：注意各种运算的规律与性质，如 $f\circ g$ 是双射时满足“外满内单”。</p><p>错题：若 R 和 S 是集合 A 上的任意两个传递关系，则 R ○ S 也是传递的。</p><p>我的答案：对 正确答案：错</p>]]></content>
    
    
    <categories>
      
      <category>离散数学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>博客相关问题</title>
    <link href="/2020/11/01/gfm-error/"/>
    <url>/2020/11/01/gfm-error/</url>
    
    <content type="html"><![CDATA[<h1 id="博客相关问题"><a href="#博客相关问题" class="headerlink" title="博客相关问题"></a>博客相关问题</h1><p>1.使用 GFM 时发现，加粗、斜体格式用 *** 表示时在某些场景下会出现无法正确解析的问题。<img src="https://zhaozihanzzh.github.io/images/image-20201102210643027.png" alt="image-20201102210643027">（更新：按 6 的进一步参考链接做后使用这一条会导致下划线直接出现在文本中，需要换回原来的三星号）</p><p>更换为 **_ 与 _** 后问题消失。</p><p>参考：<a href="https://www.reinforce.cn/t/545.html">https://www.reinforce.cn/t/545.html</a></p><p>2.开启 Typora 的行内公式支持：<a href="https://blog.csdn.net/weixin_30892763/article/details/98202815">https://blog.csdn.net/weixin_30892763/article/details/98202815</a></p><p>3.在 Typora 里面直接粘贴图片会导致图片变成 png 格式，好像会重新编码，压缩过的 jpg 会变成特别大的 png，不清楚是 Windows “照片”还是剪贴板，亦或是 typora 的锅。如果直接从菜单里面“插入本地图片”就会原封不动地插进来。</p><p>4.URL 中的括号等特殊字符需要用转义字符表达以防止解析错误：左括号用 %28，右括号用 %29。</p><p>5.关于 raw.githubusercontent 无法加载图片：将 raw.githubusercontent.com/用户名/用户名.github.io/master/ 替换为 用户名.github.io/</p><p>6.行内公式下划线解析错误时，改用两个 dollar 符号括起来。（更进一步地解决，参考 <a href="https://www.cnblogs.com/Ai-heng/p/7282110.html）">https://www.cnblogs.com/Ai-heng/p/7282110.html）</a></p><p>7.某次，行间公式无法显示，需要对 dollar 符转义才行，查到<a href="https://yunist.cn/hexo/hexo_conflict_mathjax/">此方法</a>。</p>]]></content>
    
    
    <categories>
      
      <category>计算机杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>初探矩阵</title>
    <link href="/2020/10/25/matrix/"/>
    <url>/2020/10/25/matrix/</url>
    
    <content type="html"><![CDATA[<h1 id="初探矩阵"><a href="#初探矩阵" class="headerlink" title="初探矩阵"></a>初探矩阵</h1><h2 id="一、矩阵定义"><a href="#一、矩阵定义" class="headerlink" title="一、矩阵定义"></a>一、矩阵定义</h2><h3 id="1-数域"><a href="#1-数域" class="headerlink" title="1. 数域"></a>1. 数域</h3><p>对于一个至少含有 0,1 的复数集合的子集 F ，如果其中任意两个数的四则运算所得结果仍在 F 中，那么 F 称为一个数域。显然，有理数域是最小的数域。</p><h3 id="2-矩阵"><a href="#2-矩阵" class="headerlink" title="2. 矩阵"></a>2. 矩阵</h3><p>矩阵是指某一数域中的 m × n 个数排成 m 行 n 列的表。可记为 <strong><em>A</em></strong> = (a<sub>ij</sub>)<sub>mn</sub>，或 <strong><em>A</em></strong><sub>mn</sub>，或 <strong><em>A</em></strong><sub>m×n</sub>。如果没有特殊说明，我们讨论的是复矩阵。</p><p>两矩阵行列分别相等，称为同型矩阵。</p><p>当 m = 1 时，矩阵可以看成一个行向量；当 n = 1 时，矩阵可以看成一个列向量。当 m = n 时，称为 n 阶方阵，其主对角线（只有方阵才有）元素之和为方阵的迹，记作 tr(<strong><em>A</em></strong>)。</p><p>当 n 阶方阵不在主对角线上的元素都为 0 时，称为 n 阶对角矩阵，书写时只需保留主对角线，可记作 <strong><em>A</em></strong> = diag(a<sub>11</sub>, a<sub>22</sub>, …, a<sub>nn</sub>)。当 n 阶方阵不在次对角线上的元素都为 0 时，称为 n 阶反对角矩阵。</p><p>进一步地，如果对角矩阵主对角线所有数全为 1 ，称为单位矩阵，记作 <strong><em>E</em></strong><sub>n</sub> 或 <strong><em>E</em></strong> 。</p><p>当矩阵所有元素为 0 时，称为零矩阵，仍记为 <strong><em>0</em></strong> 。</p><p>仿照行列式，可以定义上三角、下三角矩阵。</p><p>某个矩阵的负矩阵中每个元素都与原矩阵中的对应元素互为相反数。</p><h2 id="二、矩阵运算"><a href="#二、矩阵运算" class="headerlink" title="二、矩阵运算"></a>二、矩阵运算</h2><h3 id="1-矩阵的加法"><a href="#1-矩阵的加法" class="headerlink" title="1.矩阵的加法"></a>1.矩阵的加法</h3><p>两个同型矩阵相加，所得矩阵上元素等于原来两矩阵对应位置元素之和。只有同型矩阵才能相加。某个矩阵减去另一个矩阵相当于加上它的负矩阵。</p><h3 id="2-矩阵的数乘"><a href="#2-矩阵的数乘" class="headerlink" title="2.矩阵的数乘"></a>2.矩阵的数乘</h3><p>某个矩阵与数域中某个数相乘，等于用这个数去乘这一矩阵上的每一个元素。这一点与行列式不同。</p><p>特别地，称 k<strong><em>E</em></strong> 为数量矩阵。</p><h3 id="3-矩阵的乘法"><a href="#3-矩阵的乘法" class="headerlink" title="3.矩阵的乘法"></a>3.矩阵的乘法</h3><p>设矩阵 <strong><em>A</em></strong> = (a<sub>ij</sub>)<sub>sn</sub>，<strong><em>B</em></strong> = (b<sub>kl</sub>)<sub>nm</sub>，则 <strong><em>AB</em></strong> = (c<sub>ij</sub>)<sub>sm</sub>，其中 c<sub>ij</sub> = a<sub>i1</sub>b<sub>1j</sub>+a<sub>i2</sub>b<sub>2j</sub>+a<sub>i3</sub>b<sub>3j</sub>+…+a<sub>n1</sub>b<sub>nj</sub> ，即：$$\sum^{n}_{k=1}a_{ik}b_{kj}$$显然，矩阵乘法不满足交换律，当乘号前矩阵的列数与乘号后矩阵的行数不相等时，无法对这两个矩阵求积。另外，两矩阵之积为零矩阵，则这两个矩阵可能都不为零矩阵。</p><p>当 <strong><em>AB</em></strong> = <strong><em>BA</em></strong> 时，称 <strong><em>A</em></strong> 与 <strong><em>B</em></strong> 可交换，易知此时 <strong><em>A</em></strong> 与 <strong><em>B</em></strong> 为同阶方阵。</p><p>当 <strong><em>A</em></strong> 为对角矩阵时，通过设出 <strong><em>B</em></strong> 中的代表项可知，若要 <strong><em>A</em></strong> 与 <strong><em>B</em></strong> 可交换，此时 <strong><em>B</em></strong> 一定亦是对角矩阵。</p><p>矩阵乘法满足结合律、分配律。（矩阵乘法中混入的与数相乘也满足结合律）</p><p>同阶的上三角矩阵的积仍然是上三角矩阵。</p><h3 id="4-方阵的方幂与多项式"><a href="#4-方阵的方幂与多项式" class="headerlink" title="4.方阵的方幂与多项式"></a>4.方阵的方幂与多项式</h3><p>方阵 <strong><em>A</em></strong> 的 k 次方幂 <strong><em>A</em></strong><sup>k</sup> 表示 k 个 <strong><em>A</em></strong> 相乘。特别地， <strong><em>A</em></strong><sup>0</sup> = <strong><em>E</em></strong><sub>n</sub>。显然，在这里满足 <strong><em>A</em></strong><sup>k</sup><strong><em>A</em></strong><sup>l</sup> = <strong><em>A</em></strong><sup>k+l</sup>，（<strong><em>A</em></strong><sup>k</sup>)<sup>l</sup> = <strong><em>A</em></strong><sup>kl</sup>。</p><p>称 f(<strong><em>A</em></strong>) = a<sub>m</sub><strong><em>A</em></strong><sup>m</sup>+a<sub>m-1</sub><strong><em>A</em></strong><sup>m-1</sup>+…+a<sub>1</sub><strong><em>A</em></strong><sup>1</sup>+a<sub>0</sub><strong><em>E</em></strong> 为方阵 <strong><em>A</em></strong> 的 m 次多项式。</p><p>可以证明，方阵 <strong><em>A</em></strong> 的多项式 f(<strong><em>A</em></strong>) 与 g(<strong><em>A</em></strong>) 满足 f(<strong><em>A</em></strong>)g(<strong><em>A</em></strong>)=g(<strong><em>A</em></strong>)f(<strong><em>A</em></strong>)。</p><h3 id="5-矩阵的转置"><a href="#5-矩阵的转置" class="headerlink" title="5.矩阵的转置"></a>5.矩阵的转置</h3><p>将 <strong><em>A</em></strong> 行列互换得到的矩阵称为 <strong><em>A</em></strong> 的转置矩阵，记作 <strong><em>A</em></strong><sup>T</sup> 或 <strong><em>A’</em></strong>。</p><p>矩阵转置时，(<strong><em>A</em></strong>+<strong><em>B</em></strong>)<sup>T</sup>=<strong><em>A</em></strong><sup>T</sup>+<strong><em>B</em></strong><sup>T</sup>，(k<strong><em>A</em></strong>)<sup>T</sup>=k<strong><em>A</em></strong><sup>T</sup>，(<strong><em>AB</em></strong>)<sup>T</sup>=<strong><em>B</em></strong><sup>T</sup><strong><em>A</em></strong><sup>T</sup>，可推广为：(<strong><em>A</em></strong><sub>1</sub><strong><em>A</em></strong><sub>2</sub>…<strong><em>A</em></strong><sub>m</sub>)<sup>T</sup> = <strong><em>A</em></strong><sub>m</sub><sup>T</sup><strong><em>A</em></strong><sub>m-1</sub><sup>T</sup>…<strong><em>A</em></strong><sub>1</sub><sup>T</sup>。</p><p>当某矩阵与其转置矩阵相等时，称其为对称矩阵；当某矩阵与其转置矩阵的负矩阵相等时，称其为反对称矩阵。易知，反对称矩阵主对角线元素均为 0。</p><h3 id="6-矩阵的共轭"><a href="#6-矩阵的共轭" class="headerlink" title="6.矩阵的共轭"></a>6.矩阵的共轭</h3><p>称 <span style="text-decoration: overline"><strong><em>A</em></strong></span> = (<span style="text-decoration: overline">a<sub>ij</sub></span>)<sub>mn</sub> 是 <strong><em>A</em></strong> 的共轭矩阵。则有：<span style="text-decoration: overline"><strong><em>A</em></strong> + <strong><em>B</em></strong> </span> = <span style="text-decoration: overline"><strong><em>A</em></strong></span> + <span style="text-decoration: overline"><strong><em>B</em></strong></span>；<span style="text-decoration: overline">k<strong><em>A</em></strong></span> = <span style="text-decoration: overline">k</span> <span style="text-decoration: overline"><strong><em>A</em></strong></span>；<span style="text-decoration: overline"><strong><em>AB</em></strong></span> = <span style="text-decoration: overline"><strong><em>A</em></strong></span> <span style="text-decoration: overline"><strong><em>B</em></strong></span>；<span style="text-decoration: overline"><strong><em>A</em></strong><sup>T</sup></span> = (<span style="text-decoration: overline"><strong><em>A</em></strong></span>)<sup>T</sup>。</p><h2 id="三、矩阵的分块"><a href="#三、矩阵的分块" class="headerlink" title="三、矩阵的分块"></a>三、矩阵的分块</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>将矩阵用水平、垂直线划分成若干小矩阵所得的小矩阵称为矩阵的子块，以子块为元素的形式上的矩阵称为分块矩阵。</p><p>如果分块矩阵具有类似对角矩阵的形式，称为准对角矩阵。</p><p>分块矩阵进行运算时，要额外注意子块之间的运算是否有意义。</p><h3 id="2-转置"><a href="#2-转置" class="headerlink" title="2.转置"></a>2.转置</h3><p>未分块的矩阵的转置相当于把分块矩阵转置后再转置所有子块。</p><h2 id="四、方阵的行列式"><a href="#四、方阵的行列式" class="headerlink" title="四、方阵的行列式"></a>四、方阵的行列式</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h3><p>方阵 <strong><em>A</em></strong> 上的元素按其位置形成的行列式称为该方阵的行列式，记作 det(<strong><em>A</em></strong>) 或 |<strong><em>A</em></strong>|。有：|k<strong><em>A</em></strong>| = k<sup>n</sup>|<strong><em>A</em></strong>|，|<span style="text-decoration: overline"><strong><em>A</em></strong></span>| = <span style="text-decoration: overline">|<strong><em>A</em></strong>|</span>，</p><h3 id="2-乘积"><a href="#2-乘积" class="headerlink" title="2.乘积"></a>2.乘积</h3><p>|<strong><em>A</em></strong>||<strong><em>B</em></strong>| = |<strong><em>AB</em></strong>|。</p><h3 id="3-矩阵的子式"><a href="#3-矩阵的子式" class="headerlink" title="3.矩阵的子式"></a>3.矩阵的子式</h3><p>在 m × n 矩阵中任意取 k 行 k 列，位于这些选定的行列交叉点上的元素按原顺序排成的 k 阶行列式称为原矩阵的一个子式。</p><h2 id="五、矩阵初等变换"><a href="#五、矩阵初等变换" class="headerlink" title="五、矩阵初等变换"></a>五、矩阵初等变换</h2><h3 id="1-矩阵的初等变换"><a href="#1-矩阵的初等变换" class="headerlink" title="1.矩阵的初等变换"></a>1.矩阵的初等变换</h3><p>矩阵的一次初等行变换，是指对矩阵进行以下三种变换之一：a. 交换矩阵中的两行 b. 用数域中一个非零的数 k 去乘矩阵某行的各元素 c. 把矩阵某行各元素的 k 倍加到另一行中，其中 k 在数域内。这三种分别称为第 Ⅰ、Ⅱ、Ⅲ 种初等行变换。类似地，可以定义矩阵的初等列变换。矩阵的初等行、列变换合称矩阵的初等变换。符号表示与行列式类似。</p><p>如果一个矩阵经过一系列初等变换变成另一个矩阵，那么这两个矩阵等价。</p><h3 id="2-阶梯形矩阵"><a href="#2-阶梯形矩阵" class="headerlink" title="2.阶梯形矩阵"></a>2.阶梯形矩阵</h3><p>当 <strong><em>A</em></strong> = (a<sub>ij</sub>)<sub>mn</sub> 满足：a. 若某行元素全为 0 ，则该行以下均全为 0 元素；b. 当前 r 行均存在非零元素时，若设第 i 行左起第一个非零元素为  $a_{ij_{i}}$，则有 j<sub>1</sub> &lt; j<sub>2</sub> &lt; … &lt; j<sub>r</sub> 恒成立。</p><p>任意一个矩阵可以通过一系列初等行变换化为阶梯形矩阵。</p><h3 id="3-简化阶梯形矩阵"><a href="#3-简化阶梯形矩阵" class="headerlink" title="3.简化阶梯形矩阵"></a>3.简化阶梯形矩阵</h3><p>当阶梯形矩阵满足：a. 所有先导元素（每行第一个非零元素）为 1；b. 先导元素所在列除了先导元素外全为 0 ，称其为简化阶梯形矩阵。</p><h3 id="4-等价标准形矩阵"><a href="#4-等价标准形矩阵" class="headerlink" title="4.等价标准形矩阵"></a>4.等价标准形矩阵</h3><p>等价标准形矩阵的形式：$$\left( \begin{matrix} 1 &0 &\cdots &0 &0 &\cdots &0\\0 &1 &\cdots &0 &0 &\cdots &0 \\\vdots &\vdots &&\vdots &\vdots & &\vdots \\ 0 &0 &\cdots &1 &0 &\cdots &0 \\ 0 &0 &\cdots &0 &0 &\cdots &0 \\ \vdots &\vdots & &\vdots\ &\vdots & &\vdots \\0 &0 &\cdots &0 &0 &\cdots &0 \end{matrix} \right)=\left( \begin{matrix} E_r &0  \\ 0 &0 \end{matrix} \right)$$向等价标准形转化时，可能需要用到列变换。</p><h3 id="5-初等矩阵"><a href="#5-初等矩阵" class="headerlink" title="5.初等矩阵"></a>5.初等矩阵</h3><p>第 Ⅰ 种类型初等矩阵：n 阶单位矩阵第 i 行、第 j 行互换所得，记作 <strong><em>P</em></strong>(i, j)。</p><p>第 Ⅱ 种类型初等矩阵：n 阶单位矩阵第 i 行乘非零的 k 所得，记作 <strong><em>P</em></strong>(i(k))。</p><p>第 Ⅲ 种类型初等矩阵：n 阶单位阵第 j 行的 k 倍加到第 i 行所得，记作 <strong><em>P</em></strong>(i, j(k))。</p><p>由于对任意矩阵作第 Ⅰ 种初等行变换相当于该矩阵左乘对应的第 Ⅰ 种初等矩阵，作第 Ⅰ 种初等列变换相当于该矩阵右乘对应的第 Ⅰ 种初等矩阵；对任意矩阵作第 Ⅱ 种初等行变换相当于该矩阵左乘对应的第 Ⅱ 种初等矩阵，作第 Ⅱ 种初等列变换相当于该矩阵右乘对应的第 Ⅱ 种初等矩阵；对任意矩阵作第 Ⅲ 种初等行变换相当于该矩阵左乘对应的第 Ⅲ 种初等矩阵，矩阵 <strong><em>A</em></strong> = (a<sub>ij</sub>)<sub>mn</sub> 右乘 n 阶 <strong><em>P</em></strong>(i, j(k)) 相当于 <strong><em>A</em></strong> 的第 i 列的 k 倍加到第 j 列，则可以将任一矩阵通过左乘或右乘初等矩阵化成等价标准形。</p><h2 id="六、矩阵的秩"><a href="#六、矩阵的秩" class="headerlink" title="六、矩阵的秩"></a>六、矩阵的秩</h2><h3 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h3><p>当非零的 m × n 矩阵 <strong><em>A</em></strong> 有非零的 r 阶子式而没有非零的 (r + 1) 阶子式时，该矩阵的秩为 r ，记作 r(<strong><em>A</em></strong>) 。零矩阵的秩规定为 0。</p><h3 id="2-满秩"><a href="#2-满秩" class="headerlink" title="2.满秩"></a>2.满秩</h3><p>如果 n 阶方阵 <strong><em>A</em></strong> 满足 r(<strong><em>A</em></strong>) = n，则称矩阵 <strong><em>A</em></strong> 为满秩的，或非奇异的，或非退化的。反之，则称 <strong><em>A</em></strong> 为降秩的，或奇异的，或退化的。</p><p>可以证明，方阵满秩与方阵的行列式非零等价。</p><h3 id="3-求解矩阵的秩"><a href="#3-求解矩阵的秩" class="headerlink" title="3.求解矩阵的秩"></a>3.求解矩阵的秩</h3><p>可以证明，初等变换不改变矩阵的秩，两个同型矩阵等价的充要条件为它们有相同的秩。矩阵转置后，秩不变。</p><p>阶梯型矩阵的秩等于其非零行的数目。</p><h2 id="七、矩阵的逆"><a href="#七、矩阵的逆" class="headerlink" title="七、矩阵的逆"></a>七、矩阵的逆</h2><h3 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1.定义"></a>1.定义</h3><p>设 <strong><em>A</em></strong> 为 n 阶方阵，若存在 <strong><em>B</em></strong> 使得 <strong><em>AB</em></strong> = <strong><em>BA</em></strong> = <strong><em>E</em></strong>，则 <strong><em>A</em></strong> 的逆矩阵 <strong><em>A</em></strong><sup>-1</sup> = <strong><em>B</em></strong>。</p><h3 id="2-性质"><a href="#2-性质" class="headerlink" title="2.性质"></a>2.性质</h3><p>a. <strong><em>A</em></strong>、<strong><em>B</em></strong> 可逆时，<strong><em>AB</em></strong> 也可逆，且 (<strong><em>AB</em></strong>)<sup>-1</sup> = <strong><em>B</em></strong><sup>-1</sup><strong><em>A</em></strong><sup>-1</sup>。（逆、转置的顺序要调换，共轭不需要）</p><p>b. <strong><em>A</em></strong> 可逆时，<strong><em>A</em></strong><sup>T</sup> 也可逆，且 (<strong><em>A</em></strong><sup>T</sup>)<sup>-1</sup>= （<strong><em>A</em></strong><sup>-1</sup>)<sup>T</sup>。</p><p>c. <strong><em>A</em></strong> 可逆时，<span style="text-decoration: overline"><strong><em>A</em></strong></span> 也可逆，且 <span style="text-decoration: overline"><strong><em>A</em></strong><sup>-1</sup></span> = (<span style="text-decoration: overline"><strong><em>A</em></strong></span>)<sup>-1</sup>。（逆的共轭等于共轭的逆）</p><p>d. (k<strong><em>A</em></strong>)<sup>-1</sup> = k<sup>-1</sup><strong><em>A</em></strong><sup>-1</sup>。</p><p>e. (<strong><em>A</em></strong><sub>1</sub><strong><em>A</em></strong><sub>2</sub>…<strong><em>A</em></strong><sub>S</sub>)<sup>-1</sup> = <strong><em>A</em></strong><sub>S</sub><sup>-1</sup><strong><em>A</em></strong><sub>S-1</sub><sup>-1</sup>…<strong><em>A</em></strong><sub>1</sub><sup>-1</sup></p><p>f. 上三角矩阵的逆仍然是上三角矩阵。</p><p>但是，(<strong><em>A</em></strong>+<strong><em>B</em></strong>)<sup>-1</sup> 不等于 <strong><em>A</em></strong><sup>-1</sup> + <strong><em>B</em></strong><sup>-1</sup>。</p><h3 id="3-充要条件"><a href="#3-充要条件" class="headerlink" title="3.充要条件"></a>3.充要条件</h3><p>当且仅当方阵 <strong><em>A</em></strong> 的行列式不为零时，<strong><em>A</em></strong> 可逆。</p><h3 id="4-利用伴随矩阵求逆"><a href="#4-利用伴随矩阵求逆" class="headerlink" title="4.利用伴随矩阵求逆"></a>4.利用伴随矩阵求逆</h3><p>定义 <strong><em>A</em></strong><sub>ij</sub> 为 方阵的行列式中元素 a<sub>ij</sub> 的代数余子式，称矩阵$$A^*=\left( \begin{matrix} A_{11} &A_{21} &\cdots  &A_{n1}\\A_{12} &A_{22} &\cdots  &A_{n2}\\\vdots &\vdots &&\vdots\\ A_{1n} &A_{2n} &\cdots  &A_{nn} \end{matrix} \right)$$为 <strong><em>A</em></strong> 的伴随矩阵。（特别注意此矩阵经过了转置）</p><p>则有:$$A^{-1} = \frac{1}{|A|}A^*$$但此方法较为繁琐。</p><h3 id="5-矩阵初等变换求逆"><a href="#5-矩阵初等变换求逆" class="headerlink" title="5.矩阵初等变换求逆"></a>5.矩阵初等变换求逆</h3><p>对于初等矩阵的逆，有：a. <strong><em>P</em></strong>(i, j)<sup>-1</sup> = <strong><em>P</em></strong>(i, j) b. <strong><em>P</em></strong>(i(k))<sup>-1</sup> = <strong><em>P</em></strong>(i(k<sup>-1</sup>)) c. <strong><em>P</em></strong>(i, j(k))<sup>-1</sup> = <strong><em>P</em></strong>(i, j(-k))，即初等矩阵的逆仍然是初等矩阵。</p><p>可逆矩阵只通过初等行变换即可变为单位矩阵。因此，可逆矩阵可表示为初等矩阵的积。</p><p>求 <strong><em>A</em></strong> 的逆时，可将与其同阶的单位阵加到其右边构成新矩阵，再通过初等行变换将矩阵左半边化成单位矩阵，此时右半边即为要求的逆；或者将与其同阶的单位阵加到其下边构成新矩阵，再通过初等列变换将矩阵上半边化成单位矩阵，此时下半边即为要求的逆。</p><p>这里，给出已知 <strong><em>A</em></strong>，<strong><em>B</em></strong> ，求 <strong><em>A</em></strong><sup>-1</sup><strong><em>B</em></strong> 的较快方法：(<strong><em>A</em></strong>, <strong><em>B</em></strong>) 通过初等行变换化为 (<strong><em>E</em></strong>, <strong><em>A</em></strong><sup>-1</sup><strong><em>B</em></strong>)。</p>]]></content>
    
    
    <categories>
      
      <category>线性代数与解析几何</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ 返回局部变量的引用与地址</title>
    <link href="/2020/10/24/local-variable-pr/"/>
    <url>/2020/10/24/local-variable-pr/</url>
    
    <content type="html"><![CDATA[<h1 id="C-返回局部变量的引用与地址"><a href="#C-返回局部变量的引用与地址" class="headerlink" title="C++ 返回局部变量的引用与地址"></a>C++ 返回局部变量的引用与地址</h1><p>听说 2020 - 1024 = 996？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">refer</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; arg)</span> </span>&#123;<br><span class="hljs-type">int</span> inter_var = <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">return</span> inter_var;<br><span class="hljs-comment">// 返回局部变量的引用</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">pointer</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; arg)</span> </span>&#123;<br><span class="hljs-type">int</span> var = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> &amp;var;<br><span class="hljs-comment">// 返回指向局部变量的指针</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> number = <span class="hljs-number">996</span>;<br><span class="hljs-comment">// cout &lt;&lt; refer(2020); 错误，不是常引用的引用作形参，实参只能是变量（或常量）。</span><br>cout &lt;&lt; &amp;<span class="hljs-built_in">refer</span>(number) &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-built_in">refer</span>(number)&lt;&lt; endl; <span class="hljs-comment">// 局部变量被销毁</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a_const_int = <span class="hljs-number">2020</span>;<br><span class="hljs-comment">// cout &lt;&lt; refer(a_const_int); 错误，形参访问限制不能弱于实参。</span><br>cout &lt;&lt; <span class="hljs-built_in">pointer</span>(<span class="hljs-number">2020</span> - number) &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *<span class="hljs-built_in">pointer</span>(number) &lt;&lt; endl; <span class="hljs-comment">// 形参为常引用，实参可以为常量，变量，表达式，数值。</span><br><span class="hljs-type">void</span>* v = (<span class="hljs-type">void</span>*)<span class="hljs-built_in">pointer</span>(number);<br>cout &lt;&lt; *(<span class="hljs-type">int</span>*)v &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zhaozihanzzh.github.io/images/image-20201025001237263.png" alt="image-20201025001237263"></p><p>在 Visual Studio 中用 debug 编译，从外部试图访问局部变量时出现了 -858993460。让我们看一下：-858993460 的二进制表示在补码方案下其实是 -858993460 -(-2^31) + 2^31 = 3435973836 的二进制表示，转成 16 进制正是大名鼎鼎的 0xCCCCCCCC 。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201025003653131.png" alt="image-20201025003653131"></p><p>以上代码在 TDM-GCC 4.9.2 上编译，发现正常读取。不论哪种编译器，使用 void 指针间接访问均可行，这反映系统并不会在局部变量生命周期结束后便急着将它写入新的值，短时间内内存上的值还是不变的。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201025005648503.png" alt="image-20201025005648503"></p><p>不过在 Ubuntu 下用 gcc 9.3.0 编译就不一样了……经 Issues 指点，这可能是 gcc 的一个<a href="https://stackoverflow.com/questions/62203933/c-return-address-of-stack-variable-null">特性</a>。</p><p>总之，这种操作应当避免……</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>进制转换</title>
    <link href="/2020/10/16/base-conversion/"/>
    <url>/2020/10/16/base-conversion/</url>
    
    <content type="html"><![CDATA[<h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><p>（无数的人已经写过这篇了）</p><p>首先介绍一下相关英文：</p><p>进制 Base</p><p>二进制 Binary</p><p>八进制 Octal</p><p>十进制 Decimal</p><p>十六进制 Hexadecimal</p><p>接下来探讨一下其转换。</p><h2 id="Part-1-整数部分"><a href="#Part-1-整数部分" class="headerlink" title="Part 1 整数部分"></a>Part 1 整数部分</h2><p>进制虽然不同，但其表示思想类似，即每一数位上的数字均代表进位的 n 次幂的倍数。因此，我们把其余数制转为十进制是直观容易的：</p><p>FEC (base 16) → 15×16²+14×16+12 (base 10)</p><p>如何将十进制转为其他进制呢？只需逆向以上过程：</p><p>1492 (base 10) → 512×2+64×7+8×2+1×4 (base 10) →2724 (base 8)</p><p>这样，以十进制为桥梁，可以实现进制转换。</p><p>针对十进制转二进制，可以使用长除法，应用“先余为低，后余为高”：（最先得出的余数可以认为代表低数位）</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201016234356469.png" alt="image-20201016234356469"></p><p>将 13 转为二进制，结果为 1101。</p><p>此外，由于除了十进制外的十六进制、八进制的进制数都是 2 的幂，我们也可以从二进制直接转至十六进制或八进制。举个例子，对于 111110110 (base 2) = 766 (base 8)，由于 2³=8 ，从右向左三位三位地分节，将每一节所对应的三位二进制数转为一位八进制后按原节次序排列即可。十六进制同理。</p><p>同样地，也可以用此方法将十六进制、八进制转为二进制，记得补 0 以占位。</p><h2 id="Part-2-小数部分"><a href="#Part-2-小数部分" class="headerlink" title="Part 2 小数部分"></a>Part 2 小数部分</h2><p>一个数的小数部分实质上是当 n 的指数为负数时对整数部分的扩展，对于其他进制转为十进制，这不难理解。但十进制往外转时，除以 n 的负数次幂再取余这一过程可以转成不断对小数部分乘以进制数且按照“先整为高，后整为低”原则取出商数：对于 0.375 (base 10) 转成二进制：</p><p>0.375×2=0.75 -&gt; 0</p><p>0.75×2=1.5     -&gt; 1</p><p>0.5×2=1          -&gt; 1</p><p>化为 0.011 (base 2)。</p>]]></content>
    
    
    <categories>
      
      <category>计算机杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android Studio 模拟器体验 Android R</title>
    <link href="/2020/10/11/android11/"/>
    <url>/2020/10/11/android11/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-Studio-模拟器体验-Android-R"><a href="#Android-Studio-模拟器体验-Android-R" class="headerlink" title="Android Studio 模拟器体验 Android R"></a>Android Studio 模拟器体验 Android R</h1><p><img src="https://zhaozihanzzh.github.io/images/image-20201011004247000.png" alt="20201011001"></p><p>​        2020 年 9 月 9 日，Android 11 正式发布了。在这里，使用 Android Studio 自带模拟器对其进行一番轻度把玩。</p><h2 id="Part-1-初步体验"><a href="#Part-1-初步体验" class="headerlink" title="Part 1 初步体验"></a>Part 1 初步体验</h2><p>​        本次更新增强了聊天气泡（然而这里并没有体验），提升了权限方面的保护，在通知面板集成了音乐播放控制，在开发者选项加入对不同屏幕形态的模拟，还增强了电源菜单，修改了启动器部分细节、最近任务后台等等。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011004247007.png" alt="image-20201011004247007"></p><p>正常的通知面板↑</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011004515860.png" alt="image-20201011004515860"></p><p>播放音乐时↑（可能需要 APP 适配？）</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005013961.png" alt="image-20201011005013961"></p><p>设置里可以开启通知历史记录了。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011004646477.png" alt="image-20201011004646477"></p><p>开发者选项，可怕。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011004751292.png" alt="image-20201011004751292"></p><p>电源菜单。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011004842462.png" alt="image-20201011004842462"></p><p>新的最近任务后台。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011004907812.png" alt="image-20201011004907812"></p><p>锁屏（为什么不显示全星期？）</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005121466.png" alt="image-20201011005121466"></p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005136070.png" alt="image-20201011005136070"></p><p>更新的手势（据说那个灵敏度调节有借鉴的成分？）</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005247493.png" alt="image-20201011005247493"></p><p>分享列表可以置顶选中应用了，合理利用应该比较方便，不过据说 Android 9 就有了，10 意外地砍掉了。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005404310.png" alt="image-20201011005404310"></p><p>原生终于有录屏了。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005503015.png" alt="image-20201011005503015"></p><p>“几个月”的权限。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005630444.png" alt="image-20201011005630444"></p><p>时钟好评。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005731378.png" alt="image-20201011005731378"></p><p>应用管理。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005757725.png" alt="image-20201011005757725"></p><p>拨号盘。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005826033.png" alt="image-20201011005826033"></p><p>音量。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005931564.png" alt="image-20201011005931564"></p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005940489.png" alt="image-20201011005940489"></p><p>Pixel 启动器。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011010004781.png" alt="image-20201011010004781"></p><p>模拟器找不到那个“设备控制器”？</p><h2 id="Part-2-娱乐跑分"><a href="#Part-2-娱乐跑分" class="headerlink" title="Part 2 娱乐跑分"></a>Part 2 娱乐跑分</h2><p><img src="https://zhaozihanzzh.github.io/images/image-20201011010147837.png" alt="image-20201011010147837"></p><p>自带输入法怎么有酷安？是我孤陋寡闻么？</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011010254365.png" alt="image-20201011010254365"></p><p>从某安安装安兔兔，无论模拟器设置中图形渲染使用硬件还是软件，GPU 测试均无法运行。那就这样吧。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011010501264.png" alt="image-20201011010501264"></p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011010517240.png" alt="image-20201011010517240"></p><p>Are you okay?</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011010545207.png" alt="image-20201011010545207"></p><p>娱乐大师无法运行……</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011010625076.png" alt="image-20201011010625076"></p><p>感觉 GeekBench 负载好像不太够，每个项目总是 CPU 没跑满就换下一个项目了。不过娱乐兔三十万分的机器怎么就超越了骁龙 865？</p><p>娱乐到此结束……</p>]]></content>
    
    
    <categories>
      
      <category>娱乐</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/09/30/hello-world/"/>
    <url>/2020/09/30/hello-world/</url>
    
    <content type="html"><![CDATA[<p>There is only one heroism in the world: to see the world as it is and to love it.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
