<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>图论</title>
    <link href="/2020/12/08/graph-theory/"/>
    <url>/2020/12/08/graph-theory/</url>
    
    <content type="html"><![CDATA[<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><p>简单辨析一些问题：</p><h2 id="一、图的基本组成"><a href="#一、图的基本组成" class="headerlink" title="一、图的基本组成"></a>一、图的基本组成</h2><p>1.图，组成，无向有向问题</p><p>2.平行边（注意有向图里情况），结点邻接，环（注意度数），孤立点，边关联于结点，边集元素重复，n 阶图？零图？平凡图？空图（及符号表示）？结点的度数，入度，出度（重复的边算吗，符号表示）？最大/小度及其符号？悬挂结点/边？图的度数序列？</p><p>3.简单图？多重图？n 阶无向完全图及符号表示？有向完全图？默认的完全图？n 阶有向/无向完全图的边数？什么是 k - 正则图？n 阶无向完全图是 (n-1) - 正则图吗 ？什么是环图？什么是轮图？轮图最低阶数？什么是 n 方体图？二分图？完全二分图及其记法？带权图的权在边上还是结点，还是都行？</p><p>4.删除边/边集/结点/结点集运算？边的收缩及其符号？加新边及其符号？子图 / 母图？生成子图？由结点集 / 边集导出子图及其符号？<em>G</em>(<em>E</em>-<em>E<sub>1</sub></em>) 与 <em>G</em>-<em>E<sub>1</sub></em> 的区别？<em>G</em> 的补图与符号表示？（注意其结点）图的同构，自互补图？</p><p>5.通路，简单通路，基本通路（又叫初级通路，路径）；回路，简单回路，基本回路（又叫初级回路、圈），奇 / 偶回路，短程线与<em>d</em>(u, v)，连通图、非连通图（无向图）？连通关系（无向图）？连通关系是等价关系吗？<em>W</em>(<em>G</em>) 指什么？简单图里 n-w&lt;=e？点割集与割点？边割集与割边（桥）？可达、相互可达（有向图）？有向图中：单向连通？强连通 / 弱连通？单向连通一定是弱连通？有向连通图？强分图？强连通图判定定理（有点像废话）？</p><p>6.邻接表（局限，有向图、无向图上的表现），有向图的邻接矩阵及某行 / 列和的意义？有向图邻接矩阵 k 次幂的元素意义？无向图的邻接矩阵及其幂？如何通过邻接矩阵判断图的连通性？邻接矩阵与同构的关系？什么是有向图的可达矩阵？怎么利用可达矩阵求强连通分支？什么是有向图的关联矩阵？什么是无向图的关联矩阵（行列代表什么？什么情况下元素为 2 ？每行元素和代表？）<br>邻接，可达，关联矩阵各有什么字母？</p><h2 id="二、特殊图"><a href="#二、特殊图" class="headerlink" title="二、特殊图"></a>二、特殊图</h2><p>1.欧拉回路，欧拉通路，欧拉图，半欧拉图？欧拉图的判定？半欧拉图呢？欧拉有向图、半欧拉有向图中的“有向”？欧拉有向图/半欧拉有向图的充要条件？（半）哈密顿回路 / 图（像欧拉图一样分有向无向吗）？判定哈密顿图的两个充分条件、一个必要条件？半哈密顿图的充分条件？彼得森图？格雷码？格雷码怎么找？</p><p>2.旅行商问题？最短路径问题及 Dijkstra 算法？中国邮路问题？</p><p>3.匹配？极大匹配？最大匹配？（VS 最大元，极大元）<em>M</em> 饱和点 / 非饱和点？完美匹配？<em>M</em> 交错路？<em>M</em> 可扩充路？最大匹配判定定理？</p><p>4.二分图？怎么判断一个图是不是二分图？互补结点集？完全二分图及其符号表示？完全二分图充要条件？【弄错了？】二分图的完备匹配 / 完美匹配？从 <em>V<sub>1</sub></em> 到 <em>V<sub>2</sub></em> 的完备匹配呢？怎么判断二分图是否存在完备匹配？ t 条件是二分图完备匹配存在的充分条件还是必要条件？</p><p>5.平面图？平面嵌入？<em>G</em> 的面？<em>f<sub>0</sub></em> 的中文名与意义？<em>f<sub>1</sub></em> ，<em>f<sub>2</sub></em> …呢？面的边界？deg(<em>f</em>)？∑deg(<em>f<sub>i</sub></em>) 与 e 的关系？连通平面图的欧拉公式与记忆技巧？非连通的平面图呢？什么叫两个图同胚？判定一个图是平面图的充要条件？</p><p>6.<em>G</em>* 是什么，怎么作？<em>G</em>* 是连通的吗？与原图的结点数，面数，边数关系？同构平面图的对偶图也一定同构吗？<em>G</em>* 的对偶图的对偶图和 <em>G</em>* 一定同构吗？什么是对简单图（结点）着色？什么是 k - 可着色的？什么是色数和 k 色图？无环图色数最大是？Brooks 定理（ <em>G</em> 不是完全图或长度为奇数的基本回路时色数最大值）？二分图的色数？色数为 2 能否说明是二分图？k - 可边着色？简单图的边色数？二分图的边色数？</p><h2 id="三、树"><a href="#三、树" class="headerlink" title="三、树"></a>三、树</h2><p>1.无向树？无向树的树叶、分支点、内点？平凡树？森林？<em>T</em> 是连通图且 e=n-1 能判定是无向树吗？<em>T</em> 无回路且 e=n-1 能判定是无向树吗？<em>T</em> 无回路且任意两结点间增加一条边，得到一条且仅一条回路，能判定 <em>T</em> 是无向树吗？证明 <em>T</em> 中结点数不小于 2 时 <em>T</em> 至少有两片树叶。生成树，弦，余树。图 <em>G</em> 有生成树的等价条件。给出求无向连通图的生成树的算法？给出求无向连通图的最小生成树的算法？</p><p>2.有向树？其边的方向是怎样的？有向根树？有向根树的树叶、分支点、树根、内点的定义？某结点的级数（层数）的定义，树的高度的定义？结点间的关系：祖先，后代，父子，兄弟？什么是根子树？什么是 m 元树，m 元正则树，完全 m 元正则树，完全 m 元树（学校的定义）？m 元正则树中结点数，分支点数，m 的关系？利用此关系与定义，能否互推出结点数、分支点数、树叶数的关系式？高为 h 的 m 元树里至多有多少树叶？</p><p>3.什么是有序根树？二元有序根树的左儿子，右儿子，左子树，右子树？介绍二元有序根树的前序遍历算法，中序遍历算法，后序遍历算法？什么是波兰、逆波兰记法？前缀码与二元树？前缀码是唯一的吗？如何生成最优二元树，最佳前缀码？</p><h2 id="四、证明定理："><a href="#四、证明定理：" class="headerlink" title="四、证明定理："></a>四、证明定理：</h2><p>握手定理+性质。（单独的度数可以用求和的方法转到度数和再借助不等式求解）结点总数超过 3 时平面简单图中每个面次数至少为 3。</p><p>某些定量性质：</p><p>图论基本定理（握手定理）？度数为奇数的结点一定有偶数个吗？有向图中所有结点入度之和与出度之和等于什么？怎么判断自然数序列是不是图的度数序列？</p><p>简单图里 n-w&lt;=e？</p><p>连通平面图的欧拉公式</p><p>m 元正则树中结点数，分支点数， m 的关系？利用此关系与定义，能否互推出结点数、分支点数、树叶数的关系式？高为 h 的 m 元树里至多有多少树叶？</p><p>旅行商问题？最短路径问题及 Dijkstra 算法？中国邮路问题？</p><p><em>G</em>* 是什么，怎么作？</p><p>介绍二元有序根树的前序遍历算法，中序遍历算法，后序遍历算法？</p><p>如何生成最优二元树，最佳前缀码？</p>]]></content>
    
    
    <categories>
      
      <category>离散数学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>神船 TX6 加致钛 PC005 Active SSD</title>
    <link href="/2020/11/13/ztpc005/"/>
    <url>/2020/11/13/ztpc005/</url>
    
    <content type="html"><![CDATA[<h1 id="神船-TX6-加致钛-PC005-Active-SSD"><a href="#神船-TX6-加致钛-PC005-Active-SSD" class="headerlink" title="神船 TX6 加致钛 PC005 Active SSD"></a>神船 TX6 加致钛 PC005 Active SSD</h1><h2 id="Part-1-安装"><a href="#Part-1-安装" class="headerlink" title="Part 1 安装"></a>Part 1 安装</h2><p>首先，确保机器断电，移除外置电池，用螺丝刀（我的是直径 3mm 的十字螺丝刀）卸下 D 面的 6 颗螺丝。</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/7bf1a1d0297cfc72.jpg" alt="7bf1a1d0297cfc72"></p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/19cb84b171e24f73.jpg" alt="image-20201114011201054"></p><p>然后，准备好 M.2 SSD 的固定螺丝。我从京东自营购入，对方表示不带螺丝。（这里这个螺丝与我的螺丝刀略微不匹配，应该使用略小一点的。用我这个拧神船自带那块固态的螺丝，会直接滑丝）于是只好单独购买……搞这么大盒子，其实只有六个小小的螺丝……</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/3089e9848921c7b7.jpg" alt="3089e9848921c7b7"><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/2484e133816dcf08.jpg" alt="2484e133816dcf08"></p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/-5afe891743a5908f.jpg" alt="image-20201114011308540"></p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/57b5dcaf1d9f990f.jpg" alt="image-20201114011323631"></p><p>开箱，取出盘的本体。</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/IMG_20201114_010645.jpg" alt="image-20201114011452363"></p><p>放掉身上可能存在的静电，将硬盘一端呈 45° 插入插槽（注意缺口），之后按下并用螺丝固定好。</p><p>因为要加散热片，我就不把 D 面扣上，只是拿 D 面垫着，直接开机。</p><h2 id="Part-2-娱乐测试"><a href="#Part-2-娱乐测试" class="headerlink" title="Part 2 娱乐测试"></a>Part 2 娱乐测试</h2><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/QQ20201121113026.jpg" alt="QQ20201121113026"></p><p>开机后进行格式化。</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/IMG_20201114_013228.png" alt="IMG_20201114_013228"></p><p>按照默认设置，结束后，空盘情况下进行一番娱乐：</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/04.png" alt="04"></p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/760d06b46c661b62.png" alt="760d06b46c661b62"></p><p>从中可以看到，在 CrystalDiskMark 中，SSD 温度多次接近 70℃ ，甚至直接撞上 75℃ （貌似温度墙？）不过待机情况下倒是没那么夸张（我拆了 D 面？）。</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/IMG_20201114_013548.jpg" alt="IMG_20201114_013548"></p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/IMG_20201114_013447.jpg" alt="IMG_20201114_013447"></p><p>另外，长江存储官网也有一个对应的工具 YMTC Smart Tool。</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/-73937f4019225a34.jpg" alt="-73937f4019225a34"></p><h2 id="Part-3-散热片"><a href="#Part-3-散热片" class="headerlink" title="Part 3 散热片"></a>Part 3 散热片</h2><p>买之前就从各评测看到极端情况下这块 SSD 主控频繁撞温度墙，于是整了这么些东西……</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/-372f6c991f7ffb4a.jpg" alt="-372f6c991f7ffb4a"></p><p>那个反光的东西是铜片，拍出来颜色都变了。另外感觉少了一点什么？</p><p>把导热硅片表面的膜撕下（爱撕机膜人），压在盘的芯片面，等按压凹陷平整后把铜片盖上。硅片黏性大，进行操作时最好保持清洁。另外我这块略微有点不太矩形？</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/QQ20201121114408.jpg" alt="QQ20201121114408"></p><p>感觉不算厚，起码顶后盖的情况在我这里是没有的。</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/QQ20201121114412.jpg" alt="QQ20201121114412"></p><p>压铜片时注意位置，我第一次太靠螺丝孔一侧，导致螺丝拧不上去，只得拆了重新装。由于硅片很黏，我掰开的时候一直担心会不会把芯片给揭掉……不过没有。另外，我没用那个橡皮筋，有一点点担心盘会被弄弯曲。我想这铜片可能不太容易掉下来的吧？</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/QQ20201121114334.jpg" alt="QQ20201121114334"></p><p>然后，我并没有进行进一步的测试。（挨打中）</p>]]></content>
    
    
    <categories>
      
      <category>娱乐</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关系和函数</title>
    <link href="/2020/11/02/relations-functions/"/>
    <url>/2020/11/02/relations-functions/</url>
    
    <content type="html"><![CDATA[<h1 id="关系和函数"><a href="#关系和函数" class="headerlink" title="关系和函数"></a>关系和函数</h1><p>简单辨析一些问题：</p><p>有序对，有序 n 元组</p><p>笛卡尔积（直积）</p><p>关系（二元关系）及符号表示，从 A 到 B 的二元关系， A 上的二元关系，E<sub>A</sub>，I<sub>A</sub>，二元关系是一个有序对吗？</p><p>二元关系与有序对构成的集合是否等价？</p><p>二元关系的定义域（前域）、值域（后域）、域及其符号表示？</p><p>关系的表示：集合，关系图（注意 A 到 B 上的与 A 上的），邻接矩阵</p><p>关系的逆</p><p>对关系的并，交，补，差，包含等的结果求逆与对关系求逆后再进行运算相同吗？</p><p>关系的复合运算本质？集合描述时注意换元？满足交换律吗？结合律呢？</p><p>判断复合运算对并运算、交运算的分配情况：</p><script type="math/tex; mode=display">(S\cup P)\circ R\ 与 \ (S\circ R)\cup (P\circ R)</script><script type="math/tex; mode=display">R\circ (S\cup P)\ 与\ (R\circ S)\cup (R\circ P)</script><script type="math/tex; mode=display">(S\cap P)\circ R\ 与\ (S\circ R)\cap (P\circ R)</script><script type="math/tex; mode=display">R\circ (S\cap P)\ 与\ (R\circ S)\cap (R\circ P)</script><p>对关系的复合运算求逆的规则是怎样的？</p><p>关系 R 的 n 次幂是如何定义的？周期性是怎么回事？</p><p>关系矩阵？复合关系的关系矩阵与原来的两个矩阵之间的关系？在这里如何求关系矩阵的乘积？</p><p>关系的性质：什么是自反关系，反自反关系，对称关系，反对称关系，传递关系？</p><p>关系闭包的概念？r(R)，s(R)，t(R) 分别是？怎么求关系的自反闭包、对称闭包、传递闭包？</p><p>当非空集合上两个关系存在包含关系时，其闭包是否也存在包含关系？</p><p>思考以下闭包的并集与并集的闭包的关系？（如果有思考难度，可以考虑举例，特别注意传递闭包）（仍然是非空集合上的）</p><script type="math/tex; mode=display">r(R_1)\cup r(R_2)\ 与\ r(R_1\cup R_2)</script><script type="math/tex; mode=display">s(R_1)\cup s(R_2)\ 与\ s(R_1\cup R_2)</script><script type="math/tex; mode=display">t(R_1)\cup t(R_2)\ 与\ t(R_1\cup R_2)</script><p>若 R 是传递的，s(R) 一定是传递的吗？r(R) 呢？</p><p>能用关系矩阵的运算来求关系的关系闭包吗？</p><p>什么是 Warshall 算法？</p><p>什么是等价关系？等价关系中的一对有序对中的两个元素可以被称为“等价”吗？</p><p>[x]<sub>R</sub> 是什么？等价类是一个集合吗？A/R 是什么？</p><p>什么是一个集合的覆盖和划分？覆盖中的元素能是空集吗？什么是划分中的类/块？划分与商集的关系？划分的元素是？</p><p>什么是偏序关系？什么是偏序集？符号表示？</p><p>什么是可比？什么是不可比？什么是覆盖？哈斯图怎么画？</p><p>可比与全序关系、全序集？</p><p>极小元、最小元、极大元、最大元？</p><p>（集合）上界、下界、上确界、下确界？</p><p>良序集与良序关系？为什么说良序集一定是全序集，全序集不一定是良序集？</p><p>函数的像、原像？函数是一种集合吗？</p><p>B<sup>A</sup> 是什么集合？这种符号与其元素个数有什么关系？</p><p>单射函数、满射函数、双射函数？恒等函数、特征函数？自然映射？</p><p>复合函数的反函数与反函数的复合存在怎样的关系？</p><p>什么是等势？什么是有限集合的基数？可数集、可列集、阿列夫零、0 级无穷大？实数集的基数、1 级无穷大、阿列夫？</p><p>有最大的基数和最大的集合吗？</p><p>补充：注意各种运算的规律与性质，如 $f\circ g$ 是双射时满足“外满内单”。</p>]]></content>
    
    
    <categories>
      
      <category>离散数学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>博客相关问题</title>
    <link href="/2020/11/01/gfm-error/"/>
    <url>/2020/11/01/gfm-error/</url>
    
    <content type="html"><![CDATA[<h1 id="博客相关问题"><a href="#博客相关问题" class="headerlink" title="博客相关问题"></a>博客相关问题</h1><p>1.使用 GFM 时发现，加粗、斜体格式用 *** 表示时在某些场景下会出现无法正确解析的问题。<img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201102210643027.png" alt="image-20201102210643027"></p><p>更换为 **_ 与 _** 后问题消失。</p><p>参考：<a href="https://www.reinforce.cn/t/545.html">https://www.reinforce.cn/t/545.html</a></p><p>2.开启 Typora 的行内公式支持：<a href="https://blog.csdn.net/weixin_30892763/article/details/98202815">https://blog.csdn.net/weixin_30892763/article/details/98202815</a></p><p>3.在 Typora 里面直接粘贴图片会导致图片变成 png 格式，好像会重新编码，压缩过的 jpg 会变成特别大的 png，不清楚是 Windows “照片”还是剪贴板，亦或是 typora 的锅。如果直接从菜单里面“插入本地图片”就会原封不动地插进来。</p>]]></content>
    
    
    <categories>
      
      <category>计算机杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>初探矩阵</title>
    <link href="/2020/10/25/matrix/"/>
    <url>/2020/10/25/matrix/</url>
    
    <content type="html"><![CDATA[<h1 id="初探矩阵"><a href="#初探矩阵" class="headerlink" title="初探矩阵"></a>初探矩阵</h1><h2 id="一、矩阵定义"><a href="#一、矩阵定义" class="headerlink" title="一、矩阵定义"></a>一、矩阵定义</h2><h3 id="1-数域"><a href="#1-数域" class="headerlink" title="1. 数域"></a>1. 数域</h3><p>对于一个至少含有 0,1 的复数集合的子集 F ，如果其中任意两个数的四则运算所得结果仍在 F 中，那么 F 称为一个数域。显然，有理数域是最小的数域。</p><h3 id="2-矩阵"><a href="#2-矩阵" class="headerlink" title="2. 矩阵"></a>2. 矩阵</h3><p>矩阵是指某一数域中的 m × n 个数排成 m 行 n 列的表。可记为 <strong><em>A</em></strong> = (a<sub>ij</sub>)<sub>mn</sub>，或 <strong><em>A</em></strong><sub>mn</sub>，或 <strong><em>A</em></strong><sub>m×n</sub>。如果没有特殊说明，我们讨论的是复矩阵。</p><p>两矩阵行列分别相等，称为同型矩阵。</p><p>当 m = 1 时，矩阵可以看成一个行向量；当 n = 1 时，矩阵可以看成一个列向量。当 m = n 时，称为 n 阶方阵，其主对角线（只有方阵才有）元素之和为方阵的迹，记作 tr(<strong><em>A</em></strong>)。</p><p>当 n 阶方阵不在主对角线上的元素都为 0 时，称为 n 阶对角矩阵，书写时只需保留主对角线，可记作 <strong><em>A</em></strong> = diag(a<sub>11</sub>, a<sub>22</sub>, …, a<sub>nn</sub>)。当 n 阶方阵不在次对角线上的元素都为 0 时，称为 n 阶准对角矩阵。</p><p>进一步地，如果对角矩阵主对角线所有数全为 1 ，称为单位矩阵，记作 <strong><em>E</em></strong><sub>n</sub> 或 <strong><em>E</em></strong> 。</p><p>当矩阵所有元素为 0 时，称为零矩阵，仍记为 <strong><em>0</em></strong> 。</p><p>仿照行列式，可以定义上三角、下三角矩阵。</p><p>某个矩阵的负矩阵中每个元素都与原矩阵中的对应元素互为相反数。</p><h2 id="二、矩阵运算"><a href="#二、矩阵运算" class="headerlink" title="二、矩阵运算"></a>二、矩阵运算</h2><h3 id="1-矩阵的加法"><a href="#1-矩阵的加法" class="headerlink" title="1.矩阵的加法"></a>1.矩阵的加法</h3><p>两个同型矩阵相加，所得矩阵上元素等于原来两矩阵对应位置元素之和。只有同型矩阵才能相加。某个矩阵减去另一个矩阵相当于加上它的负矩阵。</p><h3 id="2-矩阵的数乘"><a href="#2-矩阵的数乘" class="headerlink" title="2.矩阵的数乘"></a>2.矩阵的数乘</h3><p>某个矩阵与数域中某个数相乘，等于用这个数去乘这一矩阵上的每一个元素。这一点与行列式不同。</p><p>特别地，称 k<strong><em>E</em></strong> 为数量矩阵。</p><h3 id="3-矩阵的乘法"><a href="#3-矩阵的乘法" class="headerlink" title="3.矩阵的乘法"></a>3.矩阵的乘法</h3><p>设矩阵 <strong><em>A</em></strong> = (a<sub>ij</sub>)<sub>sn</sub>，<strong><em>B</em></strong> = (b<sub>kl</sub>)<sub>nm</sub>，则 <strong><em>AB</em></strong> = (c<sub>ij</sub>)<sub>sm</sub>，其中 c<sub>ij</sub> = a<sub>i1</sub>b<sub>1j</sub>+a<sub>i2</sub>b<sub>2j</sub>+a<sub>i3</sub>b<sub>3j</sub>+…+a<sub>n1</sub>b<sub>nj</sub> ，即：</p><script type="math/tex; mode=display">\sum^{n}_{k=1}a_{ik}b_{kj}</script><p>显然，矩阵乘法不满足交换律，当乘号前矩阵的列数与乘号后矩阵的行数不相等时，无法对这两个矩阵求积。另外，两矩阵之积为零矩阵，则这两个矩阵可能都不为零矩阵。</p><p>当 <strong><em>AB</em></strong> = <strong><em>BA</em></strong> 时，称 <strong><em>A</em></strong> 与 <strong><em>B</em></strong> 可交换，易知此时 <strong><em>A</em></strong> 与 <strong><em>B</em></strong> 为同阶方阵。</p><p>当 <strong><em>A</em></strong> 为对角矩阵时，通过设出 <strong><em>B</em></strong> 中的代表项可知，若要 <strong><em>A</em></strong> 与 <strong><em>B</em></strong> 可交换，此时 <strong><em>B</em></strong> 一定亦是对角矩阵。</p><p>矩阵乘法满足结合律、分配律。（矩阵乘法中混入的与数相乘也满足结合律）</p><p>同阶的上三角矩阵的积仍然是上三角矩阵。</p><h3 id="4-方阵的方幂与多项式"><a href="#4-方阵的方幂与多项式" class="headerlink" title="4.方阵的方幂与多项式"></a>4.方阵的方幂与多项式</h3><p>方阵 <strong><em>A</em></strong> 的 k 次方幂 <strong><em>A</em></strong><sup>k</sup> 表示 k 个 <strong><em>A</em></strong> 相乘。特别地， <strong><em>A</em></strong><sup>0</sup> = <strong><em>E</em></strong><sub>n</sub>。显然，在这里满足 <strong><em>A</em></strong><sup>k</sup><strong><em>A</em></strong><sup>l</sup> = <strong><em>A</em></strong><sup>k+l</sup>，（<strong><em>A</em></strong><sup>k</sup>)<sup>l</sup> = <strong><em>A</em></strong><sup>kl</sup>。</p><p>称 f(<strong><em>A</em></strong>) = a<sub>m</sub><strong><em>A</em></strong><sup>m</sup>+a<sub>m-1</sub><strong><em>A</em></strong><sup>m-1</sup>+…+a<sub>1</sub><strong><em>A</em></strong><sup>1</sup>+a<sub>0</sub><strong><em>E</em></strong> 为方阵 <strong><em>A</em></strong> 的 m 次多项式。</p><p>可以证明，方阵 <strong><em>A</em></strong> 的多项式 f(<strong><em>A</em></strong>) 与 g(<strong><em>A</em></strong>) 满足 f(<strong><em>A</em></strong>)g(<strong><em>A</em></strong>)=g(<strong><em>A</em></strong>)f(<strong><em>A</em></strong>)。</p><h3 id="5-矩阵的转置"><a href="#5-矩阵的转置" class="headerlink" title="5.矩阵的转置"></a>5.矩阵的转置</h3><p>将 <strong><em>A</em></strong> 行列互换得到的矩阵称为 <strong><em>A</em></strong> 的转置矩阵，记作 <strong><em>A</em></strong><sup>T</sup> 或 <strong><em>A’</em></strong>。</p><p>矩阵转置时，(<strong><em>A</em></strong>+<strong><em>B</em></strong>)<sup>T</sup>=<strong><em>A</em></strong><sup>T</sup>+<strong><em>B</em></strong><sup>T</sup>，(k<strong><em>A</em></strong>)<sup>T</sup>=k<strong><em>A</em></strong><sup>T</sup>，(<strong><em>AB</em></strong>)<sup>T</sup>=<strong><em>B</em></strong><sup>T</sup><strong><em>A</em></strong><sup>T</sup>，可推广为：(<strong><em>A</em></strong><sub>1</sub><strong><em>A</em></strong><sub>2</sub>…<strong><em>A</em></strong><sub>m</sub>)<sup>T</sup> = <strong><em>A</em></strong><sub>m</sub><sup>T</sup><strong><em>A</em></strong><sub>m-1</sub><sup>T</sup>…<strong><em>A</em></strong><sub>1</sub><sup>T</sup>。</p><p>当某矩阵与其转置矩阵相等时，称其为对称矩阵；当某矩阵与其转置矩阵的负矩阵相等时，称其为反对称矩阵。易知，反对称矩阵主对角线元素均为 0。</p><h3 id="6-矩阵的共轭"><a href="#6-矩阵的共轭" class="headerlink" title="6.矩阵的共轭"></a>6.矩阵的共轭</h3><p>称 <span style="text-decoration: overline"><strong><em>A</em></strong></span> = (<span style="text-decoration: overline">a<sub>ij</sub></span>)<sub>mn</sub> 是 <strong><em>A</em></strong> 的共轭矩阵。则有：<span style="text-decoration: overline"><strong><em>A</em></strong> + <strong><em>B</em></strong> </span> = <span style="text-decoration: overline"><strong><em>A</em></strong></span> + <span style="text-decoration: overline"><strong><em>B</em></strong></span>；<span style="text-decoration: overline">k<strong><em>A</em></strong></span> = <span style="text-decoration: overline">k</span> <span style="text-decoration: overline"><strong><em>A</em></strong></span>；<span style="text-decoration: overline"><strong><em>AB</em></strong></span> = <span style="text-decoration: overline"><strong><em>A</em></strong></span> <span style="text-decoration: overline"><strong><em>B</em></strong></span>；<span style="text-decoration: overline"><strong><em>A</em></strong><sup>T</sup></span> = (<span style="text-decoration: overline"><strong><em>A</em></strong></span>)<sup>T</sup>。</p><h2 id="三、矩阵的分块"><a href="#三、矩阵的分块" class="headerlink" title="三、矩阵的分块"></a>三、矩阵的分块</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>将矩阵用水平、垂直线划分成若干小矩阵所得的小矩阵称为矩阵的子块，以子块为元素的形式上的矩阵称为分块矩阵。</p><p>如果分块矩阵具有类似对角矩阵的形式，称为准对角矩阵。</p><p>分块矩阵进行运算时，要额外注意子块之间的运算是否有意义。</p><h3 id="2-转置"><a href="#2-转置" class="headerlink" title="2.转置"></a>2.转置</h3><p>未分块的矩阵的转置相当于把分块矩阵转置后再转置所有子块。</p><h2 id="四、方阵的行列式"><a href="#四、方阵的行列式" class="headerlink" title="四、方阵的行列式"></a>四、方阵的行列式</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h3><p>方阵 <strong><em>A</em></strong> 上的元素按其位置形成的行列式称为该方阵的行列式，记作 det(<strong><em>A</em></strong>) 或 |<strong><em>A</em></strong>|。有：|k<strong><em>A</em></strong>| = k<sup>n</sup>|<strong><em>A</em></strong>|，|<span style="text-decoration: overline"><strong><em>A</em></strong></span>| = <span style="text-decoration: overline">|<strong><em>A</em></strong>|</span>，</p><h3 id="2-乘积"><a href="#2-乘积" class="headerlink" title="2.乘积"></a>2.乘积</h3><p>|<strong><em>A</em></strong>||<strong><em>B</em></strong>| = |<strong><em>AB</em></strong>|。</p><h3 id="3-矩阵的子式"><a href="#3-矩阵的子式" class="headerlink" title="3.矩阵的子式"></a>3.矩阵的子式</h3><p>在 m × n 矩阵中任意取 k 行 k 列，位于这些选定的行列交叉点上的元素按原顺序排成的 k 阶行列式称为原矩阵的一个子式。</p><h2 id="五、矩阵初等变换"><a href="#五、矩阵初等变换" class="headerlink" title="五、矩阵初等变换"></a>五、矩阵初等变换</h2><h3 id="1-矩阵的初等变换"><a href="#1-矩阵的初等变换" class="headerlink" title="1.矩阵的初等变换"></a>1.矩阵的初等变换</h3><p>矩阵的一次初等行变换，是指对矩阵进行以下三种变换之一：a. 交换矩阵中的两行 b. 用数域中一个非零的数 k 去乘矩阵某行的各元素 c. 把矩阵某行各元素的 k 倍加到另一行中，其中 k 在数域内。这三种分别称为第Ⅰ、Ⅱ、Ⅲ 种初等行变换。类似地，可以定义矩阵的初等列变换。矩阵的初等行、列变换合称矩阵的初等变换。符号表示与行列式类似。</p><p>如果一个矩阵经过一系列初等变换变成另一个矩阵，那么这两个矩阵等价。</p><h3 id="2-阶梯形矩阵"><a href="#2-阶梯形矩阵" class="headerlink" title="2.阶梯形矩阵"></a>2.阶梯形矩阵</h3><p>当 <strong><em>A</em></strong> = (a<sub>ij</sub>)<sub>mn</sub> 满足：a. 若某行元素全为 0 ，则该行以下均全为 0 元素；b. 当前 r 行均存在非零元素时，若设第 i 行左起第一个非零元素为 a<sub>ij<sub>i</sub>&lt;/sub&gt;，则有 j<sub>1</sub> &lt; j<sub>2</sub> &lt; … &lt; j<sub>r</sub> 恒成立。</p><p>任意一个矩阵可以通过一系列初等行变换化为阶梯形矩阵。</p><h3 id="3-简化阶梯形矩阵"><a href="#3-简化阶梯形矩阵" class="headerlink" title="3.简化阶梯形矩阵"></a>3.简化阶梯形矩阵</h3><p>当阶梯形矩阵满足：a. 所有先导元素（每行第一个非零元素）为 1 b. 先导元素所在列除了先导元素外全为 0 ，称其为简化阶梯形矩阵。</p><h3 id="4-等价标准形矩阵"><a href="#4-等价标准形矩阵" class="headerlink" title="4.等价标准形矩阵"></a>4.等价标准形矩阵</h3><p>等价标准形矩阵的形式：</p><script type="math/tex; mode=display">\left( \begin{matrix} 1 &0 &\cdots &0 &0 &\cdots &0\\0 &1 &\cdots &0 &0 &\cdots &0 \\\vdots &\vdots &&\vdots &\vdots & &\vdots \\ 0 &0 &\cdots &1 &0 &\cdots &0 \\ 0 &0 &\cdots &0 &0 &\cdots &0 \\ \vdots &\vdots & &\vdots\ &\vdots & &\vdots \\0 &0 &\cdots &0 &0 &\cdots &0 \end{matrix} \right)=\left( \begin{matrix} E_r &0  \\ 0 &0 \end{matrix} \right)</script><p>向等价标准形转化时，可能需要用到列变换。</p><h3 id="5-初等矩阵"><a href="#5-初等矩阵" class="headerlink" title="5.初等矩阵"></a>5.初等矩阵</h3><p>第Ⅰ种类型初等矩阵：n 阶单位矩阵第 i 行、第 j 行互换所得，记作 <strong><em>P</em></strong>(i, j)。</p><p>第Ⅱ种类型初等矩阵：n 阶单位矩阵第 i 行乘非零的 k 所得，记作 <strong><em>P</em></strong>(i(k))。</p><p>第Ⅲ种类型初等矩阵：n 阶单位阵第 j 行的 k 倍加到第 i 行所得，记作 <strong><em>P</em></strong>(i, j(k))。</p><p>由于对任意矩阵作第Ⅰ种初等行变换相当于该矩阵左乘对应的第Ⅰ种初等矩阵，作第Ⅰ种初等列变换相当于该矩阵右乘对应的第Ⅰ种初等矩阵；对任意矩阵作第Ⅱ种初等行变换相当于该矩阵左乘对应的第Ⅱ种初等矩阵，作第Ⅱ种初等列变换相当于该矩阵右乘对应的第Ⅱ种初等矩阵；对任意矩阵作第Ⅲ种初等行变换相当于该矩阵左乘对应的第Ⅲ种初等矩阵，矩阵<strong><em>A</em></strong> = (a<sub>ij</sub>)<sub>mn</sub> 右乘 n 阶 <strong><em>P</em></strong>(i, j(k)) 相当于 <strong><em>A</em></strong> 的第 i 行的 k 倍加到第 j 列，则可以将任一矩阵通过左乘或右乘初等矩阵化成等价标准形。</p><h2 id="六、矩阵的秩"><a href="#六、矩阵的秩" class="headerlink" title="六、矩阵的秩"></a>六、矩阵的秩</h2><h3 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h3><p>当非零的 m × n 矩阵 <strong><em>A</em></strong> 有非零的 r 阶子式而没有非零的 (r + 1) 阶子式时，该矩阵的秩为 r ，记作 r(<strong><em>A</em></strong>) 。零矩阵的秩规定为 0。</p><h3 id="2-满秩"><a href="#2-满秩" class="headerlink" title="2.满秩"></a>2.满秩</h3><p>如果 n 阶方阵 <strong><em>A</em></strong> 满足 r(<strong><em>A</em></strong>) = n，则称矩阵 <strong><em>A</em></strong> 为满秩的，或非奇异的，或非退化的。反之，则称 <strong><em>A</em></strong> 为降秩的，或奇异的，或退化的。</p><p>可以证明，方阵满秩与方阵的行列式非零等价。</p><h3 id="3-求解矩阵的秩"><a href="#3-求解矩阵的秩" class="headerlink" title="3.求解矩阵的秩"></a>3.求解矩阵的秩</h3><p>可以证明，初等变换不改变矩阵的秩，两个同型矩阵等价的充要条件为它们有相同的秩。矩阵转置后，秩不变。</p><p>阶梯型矩阵的秩等于其非零行的数目。</p><h2 id="七、矩阵的逆"><a href="#七、矩阵的逆" class="headerlink" title="七、矩阵的逆"></a>七、矩阵的逆</h2><h3 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1.定义"></a>1.定义</h3><p>设 <strong><em>A</em></strong> 为 n 阶方阵，若存在 <strong><em>B</em></strong> 使得 <strong><em>AB</em></strong> = <strong><em>BA</em></strong> = <strong><em>E</em></strong>，则 <strong><em>A</em></strong> 的逆矩阵 <strong><em>A</em></strong><sup>-1</sup> = <strong><em>B</em></strong>。</p><h3 id="2-性质"><a href="#2-性质" class="headerlink" title="2.性质"></a>2.性质</h3><p>a. <strong><em>A</em></strong>、<strong><em>B</em></strong> 可逆时，<strong><em>AB</em></strong> 也可逆，且 (<strong><em>AB</em></strong>)<sup>-1</sup> = <strong><em>B</em></strong><sup>-1</sup><strong><em>A</em></strong><sup>-1</sup>。（逆、转置的顺序要调换，共轭不需要）</p><p>b. <strong><em>A</em></strong> 可逆时，<strong><em>A</em></strong><sup>T</sup> 也可逆，且 (<strong><em>A</em></strong><sup>T</sup>)<sup>-1</sup>= （<strong><em>A</em></strong><sup>-1</sup>)<sup>T</sup>。</p><p>c. <strong><em>A</em></strong> 可逆时，<span style="text-decoration: overline"><strong><em>A</em></strong></span> 也可逆，且 <span style="text-decoration: overline"><strong><em>A</em></strong><sup>-1</sup></span> = (<span style="text-decoration: overline"><strong><em>A</em></strong></span>)<sup>-1</sup>。（逆的共轭等于共轭的逆）</p><p>d. (k<strong><em>A</em></strong>)<sup>-1</sup> = k<sup>-1</sup><strong><em>A</em></strong><sup>-1</sup>。</p><p>e. (<strong><em>A</em></strong><sub>1</sub><strong><em>A</em></strong><sub>2</sub>…<strong><em>A</em></strong><sub>S</sub>)<sup>-1</sup> = <strong><em>A</em></strong><sub>S</sub><sup>-1</sup><strong><em>A</em></strong><sub>S-1</sub><sup>-1</sup>…<strong><em>A</em></strong><sub>1</sub><sup>-1</sup></p><p>f. 上三角矩阵的逆仍然是上三角矩阵。</p><p>但是，(<strong><em>A</em></strong>+<strong><em>B</em></strong>)<sup>-1</sup> 不等于 <strong><em>A</em></strong><sup>-1</sup> + <strong><em>B</em></strong><sup>-1</sup>。</p><h3 id="3-充要条件"><a href="#3-充要条件" class="headerlink" title="3.充要条件"></a>3.充要条件</h3><p>当且仅当方阵 <strong><em>A</em></strong> 的行列式不为零时，<strong><em>A</em></strong> 可逆。</p><h3 id="4-利用伴随矩阵求逆"><a href="#4-利用伴随矩阵求逆" class="headerlink" title="4.利用伴随矩阵求逆"></a>4.利用伴随矩阵求逆</h3><p>定义 <em>A</em><sub>ij</sub> 为 方阵的行列式中元素 a<sub>ij</sub> 的代数余子式，称矩阵</p><script type="math/tex; mode=display">A^*=\left( \begin{matrix} A_{11} &A_{21} &\cdots  &A_{n1}\\A_{12} &A_{22} &\cdots  &A_{n2}\\\vdots &\vdots &&\vdots\\ A_{1n} &A_{2n} &\cdots  &A_{nn} \end{matrix} \right)</script><p>为 <strong><em>A</em></strong> 的伴随矩阵。（特别注意此矩阵经过了转置）</p><p>则有:</p><script type="math/tex; mode=display">A^{-1} = \frac{1}{|A|}A^*</script><p>但此方法较为繁琐。</p><h3 id="5-矩阵初等变换求逆"><a href="#5-矩阵初等变换求逆" class="headerlink" title="5.矩阵初等变换求逆"></a>5.矩阵初等变换求逆</h3><p>对于初等矩阵的逆，有：a. <strong><em>P</em></strong>(i, j)<sup>-1</sup> = <strong><em>P</em></strong>(i, j) b. <strong><em>P</em></strong>(i(k))<sup>-1</sup> = <strong><em>P</em></strong>(i(k<sup>-1</sup>)) c. <strong><em>P</em></strong>(i, j(k))<sup>-1</sup> = <strong><em>P</em></strong>(i, j(-k))，即初等矩阵的逆仍然是初等矩阵。</p><p>可逆矩阵只通过初等行变换即可变为单位矩阵。因此，可逆矩阵可表示为初等矩阵的积。</p><p>求 <strong><em>A</em></strong> 的逆时，可将与其同阶的单位阵加到其右边构成新矩阵，再通过初等行变换将矩阵左半边化成单位矩阵，此时右半边即为要求的逆；或者将与其同阶的单位阵加到其下边构成新矩阵，再通过初等列变换将矩阵上半边化成单位矩阵，此时下半边即为要求的逆。</p><p>这里，给出已知 <strong><em>A</em></strong>，<strong><em>B</em></strong> ，求 <strong><em>A</em></strong><sup>-1</sup><strong><em>B</em></strong> 的较快方法：(<strong><em>A</em></strong>, <strong><em>B</em></strong>) 通过初等行变换化为 (<strong><em>E</em></strong>, <strong><em>A</em></strong><sup>-1</sup><strong><em>B</em></strong>)。</p>]]></content>
    
    
    <categories>
      
      <category>线性代数与解析几何</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ 返回局部变量的引用与地址</title>
    <link href="/2020/10/24/local-variable-pr/"/>
    <url>/2020/10/24/local-variable-pr/</url>
    
    <content type="html"><![CDATA[<h1 id="C-返回局部变量的引用与地址"><a href="#C-返回局部变量的引用与地址" class="headerlink" title="C++ 返回局部变量的引用与地址"></a>C++ 返回局部变量的引用与地址</h1><p>听说 2020 - 1024 = 996？</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span>&amp; <span class="hljs-title">refer</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; arg)</span> </span>&#123;<span class="hljs-keyword">int</span> inter_var = <span class="hljs-number">1024</span>;<span class="hljs-keyword">return</span> inter_var;<span class="hljs-comment">// 返回局部变量的引用</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">pointer</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; arg)</span> </span>&#123;<span class="hljs-keyword">int</span> var = <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> &amp;var;<span class="hljs-comment">// 返回指向局部变量的指针</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> number = <span class="hljs-number">996</span>;<span class="hljs-comment">// cout &lt;&lt; refer(2020); 错误，不是常引用的引用作形参，实参只能是变量（或常量）。</span><span class="hljs-built_in">cout</span> &lt;&lt; &amp;refer(number) &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; refer(number)&lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 局部变量被销毁</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a_const_int = <span class="hljs-number">2020</span>;<span class="hljs-comment">// cout &lt;&lt; refer(a_const_int); 错误，形参访问限制不能弱于实参。</span><span class="hljs-built_in">cout</span> &lt;&lt; pointer(<span class="hljs-number">2020</span> - number) &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *pointer(number) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 形参为常引用，实参可以为常量，变量，表达式，数值。</span><span class="hljs-keyword">void</span>* v = (<span class="hljs-keyword">void</span>*)pointer(number);<span class="hljs-built_in">cout</span> &lt;&lt; *(<span class="hljs-keyword">int</span>*)v &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201025001237263.png" alt="image-20201025001237263"></p><p>在 Visual Studio 中用 debug 编译，从外部试图访问局部变量时出现了 -858993460。让我们看一下：-858993460 的二进制表示在补码方案下其实是 -858993460 -(-2^31) + 2^31 = 3435973836 的二进制表示，转成 16 进制正是大名鼎鼎的 0xCCCCCCCC 。</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201025003653131.png" alt="image-20201025003653131"></p><p>以上代码在 TDM-GCC 4.9.2 上编译，发现正常读取。不论哪种编译器，使用 void 指针间接访问均可行，这反映系统并不会在局部变量生命周期结束后便急着将它写入新的值，短时间内内存上的值还是不变的。</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201025005648503.png" alt="image-20201025005648503"></p><p>不过在 Ubuntu 下用 gcc 9.3.0 编译就不一样了……</p><p>总之，这种操作应当避免……</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>进制转换</title>
    <link href="/2020/10/16/base-conversion/"/>
    <url>/2020/10/16/base-conversion/</url>
    
    <content type="html"><![CDATA[<h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><p>（无数的人已经写过这篇了）</p><p>首先介绍一下相关英文：</p><p>进制 Base</p><p>二进制 Binary</p><p>八进制 Octal</p><p>十进制 Decimal</p><p>十六进制 Hexadecimal</p><p>接下来探讨一下其转换。</p><h2 id="Part-1-整数部分"><a href="#Part-1-整数部分" class="headerlink" title="Part 1 整数部分"></a>Part 1 整数部分</h2><p>进制虽然不同，但其表示思想类似，即每一数位上的数字均代表进位的 n 次幂的倍数。因此，我们把其余数制转为十进制是直观容易的：</p><p>FEC (base 16) → 15×16²+14×16+12 (base 10)</p><p>如何将十进制转为其他进制呢？只需逆向以上过程：</p><p>1492 (base 10) → 512×2+64×7+8×2+1×4 (base 10) →2724 (base 8)</p><p>这样，以十进制为桥梁，可以实现进制转换。</p><p>针对十进制转二进制，可以使用长除法，应用“先余为低，后余为高”：（最先得出的余数可以认为代表低数位）</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201016234356469.png" alt="image-20201016234356469"></p><p>将 13 转为二进制，结果为 1101。</p><p>此外，由于除了十进制外的十六进制、八进制的进制数都是 2 的幂，我们也可以从二进制直接转至十六进制或八进制。举个例子，对于 111110110 (base 2) = 766 (base 8)，由于 2³=8 ，从右向左三位三位地分节，将每一节所对应的三位二进制数转为一位八进制后按原节次序排列即可。十六进制同理。</p><p>同样地，也可以用此方法将十六进制、八进制转为二进制，记得补 0 以占位。</p><h2 id="Part-2-小数部分"><a href="#Part-2-小数部分" class="headerlink" title="Part 2 小数部分"></a>Part 2 小数部分</h2><p>一个数的小数部分实质上是当 n 的指数为负数时对整数部分的扩展，对于其他进制转为十进制，这不难理解。但十进制往外转时，除以 n 的负数次幂再取余这一过程可以转成不断对小数部分乘以进制数且按照“先整为高，后整为低”原则取出商数：对于 0.375 (base 10) 转成二进制：</p><p>0.375×2=0.75 -&gt; 0</p><p>0.75×2=1.5     -&gt; 1</p><p>0.5×2=1          -&gt; 1</p><p>化为 0.011 (base 2)。</p>]]></content>
    
    
    <categories>
      
      <category>计算机杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android Studio 模拟器体验 Android Q</title>
    <link href="/2020/10/11/android11/"/>
    <url>/2020/10/11/android11/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-Studio-模拟器体验-Android-Q"><a href="#Android-Studio-模拟器体验-Android-Q" class="headerlink" title="Android Studio 模拟器体验 Android Q"></a>Android Studio 模拟器体验 Android Q</h1><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011004247000.png" alt="20201011001"></p><p>​        2020 年 9 月 9 日，Android 11 正式发布了。在这里，使用 Android Studio 自带模拟器对其进行一番轻度把玩。</p><h2 id="Part-1-初步体验"><a href="#Part-1-初步体验" class="headerlink" title="Part 1 初步体验"></a>Part 1 初步体验</h2><p>​        本次更新增强了聊天气泡（然而这里并没有体验），提升了权限方面的保护，在通知面板集成了音乐播放控制，在开发者选项加入对不同屏幕形态的模拟，还增强了电源菜单，修改了启动器部分细节、最近任务后台等等。</p><p>​        <img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011004247007.png" alt="image-20201011004247007"></p><p>正常的通知面板↑</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011004515860.png" alt="image-20201011004515860"></p><p>播放音乐时↑（可能需要 APP 适配？）</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011005013961.png" alt="image-20201011005013961"></p><p>设置里可以开启通知历史记录了。</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011004646477.png" alt="image-20201011004646477"></p><p>开发者选项，可怕。</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011004751292.png" alt="image-20201011004751292"></p><p>电源菜单。</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011004842462.png" alt="image-20201011004842462"></p><p>新的最近任务后台。</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011004907812.png" alt="image-20201011004907812"></p><p>锁屏（为什么不显示全星期？）</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011005121466.png" alt="image-20201011005121466"></p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011005136070.png" alt="image-20201011005136070"></p><p>更新的手势（据说那个灵敏度调节有借鉴的成分？）</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011005247493.png" alt="image-20201011005247493"></p><p>分享列表可以置顶选中应用了，合理利用应该比较方便，不过据说 Android 9 就有了，10 意外地砍掉了。</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011005404310.png" alt="image-20201011005404310"></p><p>原生终于有录屏了。</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011005503015.png" alt="image-20201011005503015"></p><p>“几个月”的权限。</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011005630444.png" alt="image-20201011005630444"></p><p>时钟好评。</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011005731378.png" alt="image-20201011005731378"></p><p>应用管理。</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011005757725.png" alt="image-20201011005757725"></p><p>拨号盘。</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011005826033.png" alt="image-20201011005826033"></p><p>音量。</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011005931564.png" alt="image-20201011005931564"></p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011005940489.png" alt="image-20201011005940489"></p><p>Pixel 启动器。</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011010004781.png" alt="image-20201011010004781"></p><p>模拟器找不到那个“设备控制器”？</p><h2 id="Part-2-娱乐跑分"><a href="#Part-2-娱乐跑分" class="headerlink" title="Part 2 娱乐跑分"></a>Part 2 娱乐跑分</h2><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011010147837.png" alt="image-20201011010147837"></p><p>自带输入法怎么有酷安？是我孤陋寡闻么？</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011010254365.png" alt="image-20201011010254365"></p><p>从某安安装安兔兔，无论模拟器设置中图形渲染使用硬件还是软件，GPU 测试均无法运行。那就这样吧。</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011010501264.png" alt="image-20201011010501264"></p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011010517240.png" alt="image-20201011010517240"></p><p>Are you okay?</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011010545207.png" alt="image-20201011010545207"></p><p>娱乐大师无法运行……</p><p><img src="https://raw.githubusercontent.com/zhaozihanzzh/zhaozihanzzh.github.io/master/images/image-20201011010625076.png" alt="image-20201011010625076"></p><p>感觉 GeekBench 负载好像不太够，每个项目总是 CPU 没跑满就换下一个项目了。不过娱乐兔三十万分的机器怎么就超越了骁龙 865？</p><p>娱乐到此结束……</p>]]></content>
    
    
    <categories>
      
      <category>娱乐</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/09/30/hello-world/"/>
    <url>/2020/09/30/hello-world/</url>
    
    <content type="html"><![CDATA[<p>There is only one heroism in the world: to see the world as it is and to love it.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
