<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>十大常见的内部排序算法</title>
    <link href="/2021/10/06/algo-ten-internalsort/"/>
    <url>/2021/10/06/algo-ten-internalsort/</url>
    
    <content type="html"><![CDATA[<h1 id="十大常见的内部排序算法"><a href="#十大常见的内部排序算法" class="headerlink" title="十大常见的内部排序算法"></a>十大常见的内部排序算法</h1><p>所谓内部 (Internal) 排序，是指在计算机的主存而非外存中进行的排序。<br>所谓稳定 (Stable) 的排序算法，是指排序完后大小相等的元素的相对位置能保持不变。在以某一键值进行排序时（如基数排序），稳定性是十分重要的。<br>所谓原地排序算法 (In-place Sorting Algorithm)，是指除了函数调用所需的栈和固定数目的实例变量之外无序额外内存的排序算法。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="《算法（第 4 版）》P154">[1]</span></a></sup></p><h2 id="Part-1-排序算法介绍"><a href="#Part-1-排序算法介绍" class="headerlink" title="Part 1 排序算法介绍"></a>Part 1 排序算法介绍</h2><p>在这里，我们以从小到大排序为例介绍这些算法，所有的排序都在数组中进行：</p><h3 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1. 选择排序"></a>1. 选择排序</h3><p>选择排序 (Selection Sort) 思路是每次选择最小的元素交换到已经排好的部分的末尾。实现起来较为简易。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selection_sort</span><span class="hljs-params">(T* start, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> scale)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; scale - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">int</span> min_index = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; scale; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (start[j] &lt; start[min_index]) &#123;<br>                min_index = j;<br>            &#125;<br>        &#125;<br>        T exchange = start[i];<br>        start[i] = start[min_index];<br>        start[min_index] = exchange;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>选择排序是不稳定的排序算法：1 2 <strong>7</strong> <em>7</em> 3 -&gt; 1 2 3 <em>7</em> <strong>7</strong><br>选择排序的时间复杂度在一般情况下为 O(n<sup>2</sup>)，不存在更好或更差的情况。<br>空间复杂度为 O(1)，是原地排序算法。</p><h3 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h3><p>插入排序 (Insertion Sort) 思路类似按高矮排队时新来了一个人的情况，这个人站到队尾后便开始与前面比他高的人不停地交换位置。元素越有序，对插入排序就越有利。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertion_sort</span><span class="hljs-params">(T* start, <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> scale)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; scale; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt; <span class="hljs-number">0</span> &amp;&amp; start[j] &lt; start[j - <span class="hljs-number">1</span>]; --j) &#123;<br>            T temp = start[j];<br>            start[j] = start[j - <span class="hljs-number">1</span>];<br>            start[j - <span class="hljs-number">1</span>] = temp;<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><br>交换元素时不会改变相同元素的相对顺序，故插入排序是稳定的排序算法。<br>插入排序平均时间复杂度为 O(n<sup>2</sup>)，最好情况下（元素全部有序）时间复杂度为 O(n)，这是内层循环条件不满足；最坏情况是完全逆序时，这时需要把每次遍历到的元素交换到最开头。<br>空间复杂度为 O(1)，是原地排序。</p><h3 id="3-冒泡排序及其改进"><a href="#3-冒泡排序及其改进" class="headerlink" title="3. 冒泡排序及其改进"></a>3. 冒泡排序及其改进</h3><p>冒泡排序 (Bubble Sort) 的思路是每次将未排序元素中最小或最大的交换到一端，形似因密度不同而不断冒出的气泡。由于每次都挑出最值，因此每挑出一次，下一次的最值就是上次的次最值，排在上次挑出值的后面。要注意挑出的最值位于遍历方向的末尾。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">original_bubble_sort</span><span class="hljs-params">(T *data, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; len - i; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (data[j] &gt; data[j - <span class="hljs-number">1</span>]) &#123;<br>                std::<span class="hljs-built_in">swap</span>(data[j], data[j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>冒泡排序是稳定的排序算法，由于交换的是相邻的元素，不会有相等的元素越过对方。<br>冒泡排序时间复杂度为 O(n<sup>2</sup>)，空间复杂度为 O(1)，属于原地排序。</p><p>但这还没完，冒泡排序显然还有优化的空间：</p><h4 id="1-有序时停止"><a href="#1-有序时停止" class="headerlink" title="1. 有序时停止"></a>1. 有序时停止</h4><p>在已经有序（即一轮比较后不发生任何交换）的情况下，可以停止排序了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">timelystop_bubble_sort</span><span class="hljs-params">(T *data, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">bool</span> has_exchange = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; len - i; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (data[j] &gt; data[j - <span class="hljs-number">1</span>]) &#123;<br>                std::<span class="hljs-built_in">swap</span>(data[j], data[j - <span class="hljs-number">1</span>]);<br>                has_exchange = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!has_exchange) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>此时，最好情况下（已有序）时间复杂度为 O(n)。</p><h4 id="2-确定有序边界"><a href="#2-确定有序边界" class="headerlink" title="2. 确定有序边界"></a>2. 确定有序边界</h4><p>从全部有序的情况出发，进一步地，如果数组只是末尾有序，虽然不能直接退出排序，但可以省掉末尾的部分（开头有序没法省去，因为要从里面挑元素往后移动，即使开头的元素有序了，那也不是它们最终的位置）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">skipsorted_bubble_sort</span><span class="hljs-params">(T *data, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> border = len;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">int</span> last_exchange = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; border; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (data[j] &lt; data[j - <span class="hljs-number">1</span>]) &#123;<br>                std::<span class="hljs-built_in">swap</span>(data[j], data[j - <span class="hljs-number">1</span>]);<br>                last_exchange = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (last_exchange == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        border = last_exchange;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时最好的时间复杂度为 O(n)。</p><h4 id="3-鸡尾酒排序"><a href="#3-鸡尾酒排序" class="headerlink" title="3. 鸡尾酒排序"></a>3. 鸡尾酒排序</h4><p>鸡尾酒排序 (Cocktail Sort) 是“来回”的冒泡排序。传统的冒泡排序在升序时，最小元素在数组末尾会一点一点往上冒，而最大元素在起始却一趟就冒过去了。为了更好地平衡，可以在顺序冒一趟后倒序再来。这里我们直接在上面确定有序边界版本的冒泡排序上作修改：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">skipsorted_cocktail_sort</span><span class="hljs-params">(T *data, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> last_exchange = <span class="hljs-number">0</span>, first_exchange = len;<br>    <span class="hljs-keyword">int</span> max_border = len, min_border = <span class="hljs-number">0</span>; <span class="hljs-comment">// 两个都取不到</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = min_border + <span class="hljs-number">1</span>; j &lt; max_border; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (data[j] &lt; data[j - <span class="hljs-number">1</span>]) &#123;<br>                std::<span class="hljs-built_in">swap</span>(data[j], data[j - <span class="hljs-number">1</span>]);<br>                last_exchange = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (last_exchange == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = last_exchange - <span class="hljs-number">1</span>; j &gt; min_border; --j) &#123;<br>            <span class="hljs-keyword">if</span> (data[j] &lt; data[j - <span class="hljs-number">1</span>]) &#123;<br>                std::<span class="hljs-built_in">swap</span>(data[j], data[j - <span class="hljs-number">1</span>]);<br>                first_exchange = j - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (first_exchange == len) <span class="hljs-keyword">break</span>;<br>        max_border = last_exchange;<br>        min_border = first_exchange;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h3><p>希尔排序 (Shell Sort，以发明者的名字命名) 又称递减增量排序 (Diminishing Increment Sort)，它使用插入排序先使数组中任意间隔 h 的元素有序，然后按照一定的序列减小 h （要求 h 最后要以 1 结尾）并按减小的 h 排序。这里，我们使用 1/2(3<sup>k</sup>-1) 作为希尔排序的递增序列，递增到小于数组长度的最大值，然后每次除以 3，直到等于 1：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shell_sort</span><span class="hljs-params">(T* start, <span class="hljs-keyword">int</span> scale)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> span = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (span &lt; scale / <span class="hljs-number">3</span>) span = <span class="hljs-number">3</span> * span + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (span &gt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = span; i &lt; scale; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt;= span &amp;&amp; start[j] &lt; start[j - span]; j-= span) &#123;<br>                T temp = start[j];<br>                start[j] = start[j - span];<br>                start[j - span] = temp;<br>            &#125;<br>        &#125;<br>        span = span / <span class="hljs-number">3</span>;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><br>希尔排序交换元素时会跨越一部分元素，因此可能改变相等元素的相对位置，是不稳定的排序算法：<strong>3</strong> <em>3</em> 1 -&gt; 1 <em>3</em> <strong>3</strong><br>希尔排序的时间复杂度似乎是无法准确描述的。这里给出的算法在最坏情况下的时间复杂度为 O(1.5)，空间复杂度为 O(1)，是原地排序。</p><h3 id="5-归并排序及其改进"><a href="#5-归并排序及其改进" class="headerlink" title="5. 归并排序及其改进"></a>5. 归并排序及其改进</h3><p>归并排序 (Merge Sort) 是通过将已经排序好的两个小的子数组合并成大的数组实现的，传统上，归并排序需要一个辅助数组，在排序通过双指针时判断是把哪个小数组中的元素加入。这里我们用自顶向下的方法，先分割，直到无法再分割，然后通过函数栈的顺序调用来合并。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MergeSorts</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> T* auxiliary;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(T* start, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left_cursor = low,<br>            right_cursor = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 指向第一个没加入的元素</span><br>        <span class="hljs-keyword">if</span> (start[mid] &lt;= start[mid + <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果已经满足有序，直接返回</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = low; i &lt;= high; ++i) &#123;<br>            auxiliary[i] = start[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = low; i &lt;= high; ++i) &#123;  <span class="hljs-comment">// 设计好循环的次数，保证不越界</span><br>            <span class="hljs-keyword">if</span> (left_cursor &gt; mid)<br>                start[i] = auxiliary[right_cursor++];  <span class="hljs-comment">// 左边全加进去了加右边</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right_cursor &gt; high)<br>                start[i] = auxiliary[left_cursor++];  <span class="hljs-comment">// 右边全加进去了加左边</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (auxiliary[left_cursor] &gt; auxiliary[right_cursor])<br>                start[i] = auxiliary[right_cursor++]; <span class="hljs-comment">// 否则就比左右大小决定</span><br>            <span class="hljs-keyword">else</span><br>                start[i] = auxiliary[left_cursor++];  <span class="hljs-comment">// 注意排序稳定性（元素相等时）</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 注意 low 和 high 能不能取到：这里都能取到</span><br>    <span class="hljs-comment">// 如果 low 和 high 相等，直接返回，保证 merge 函数 low 和 high 差至少为 2；</span><br>    <span class="hljs-comment">// 差 1 的时候 mid 与 low 相等，mid + 1 与</span><br>    <span class="hljs-comment">// high 相等，不重叠</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort_TD</span><span class="hljs-params">(T* start, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (high &lt;= low)<br>            <span class="hljs-keyword">return</span>;                        <span class="hljs-comment">// Only one in selection.</span><br>        <span class="hljs-keyword">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// Ensure mid &lt;= high</span><br>        <span class="hljs-built_in">merge_sort_TD</span>(start, low, mid);<br>        <span class="hljs-built_in">merge_sort_TD</span>(start, mid + <span class="hljs-number">1</span>, high);<br>        <span class="hljs-built_in">merge</span>(start, low, mid, high);<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort_TopDown</span><span class="hljs-params">(T* start, <span class="hljs-keyword">int</span> scale)</span> </span>&#123;<br>        auxiliary = <span class="hljs-keyword">new</span> T[scale];<br>        <span class="hljs-built_in">merge_sort_TD</span>(start, <span class="hljs-number">0</span>, scale - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">delete</span>[] auxiliary;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; T* MergeSorts&lt;T&gt;::auxiliary;<br></code></pre></td></tr></table></figure><p>类似地，还有自底向上的归并排序，从最小单元开始逐步增大小数组的长度来合并：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort_UpBottom</span><span class="hljs-params">(T* start, <span class="hljs-keyword">int</span> scale)</span> </span>&#123;<br>    auxiliary = <span class="hljs-keyword">new</span> T[scale];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> sub_length = <span class="hljs-number">1</span>; sub_length &lt; scale; sub_length *= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> left_cursor = <span class="hljs-number">0</span>; left_cursor &lt; scale - sub_length; left_cursor+= <span class="hljs-number">2</span> * sub_length) &#123;<br>            <span class="hljs-built_in">merge</span>(start, left_cursor, left_cursor + sub_length - <span class="hljs-number">1</span>, std::<span class="hljs-built_in">mi</span>(left_cursor + <span class="hljs-number">2</span> * sub_length - <span class="hljs-number">1</span>, (scale - <span class="hljs-number">1</span>)));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] auxiliary;<br>&#125;<br></code></pre></td></tr></table></figure><br>这样看，归并排序是稳定的排序算法，归并时子数组的相对位置不改变，相等的元素也可以按照先后顺序并入最后的答案中。<br>如果采用树形结构描述归并排序的递归流程，由于每“层”中各次操作加起来（例如调用前 1/4，上 1/4，下 1/4，末 1/4）都得比较整个数组一遍，而有大约 log<sub>2</sub>n 层（递归深度），故一般的时间复杂度为 O(nlogn)。考虑到针对有序子数组的优化，最好的情况下比较是 O(n) 的。<br>需要额外数组，空间复杂度为 O(n)。<br>但归并排序也有优化空间，可以通过在每层遍历时交换输入原数据的数组和辅助数组来减少归并时的数组复制：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// std::swap 会交换指针指向的对象，需要自己的交换函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap_ptr</span><span class="hljs-params">(T *&amp; a, T *&amp; b)</span> </span>&#123;<br>    T *temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(T* start, T* auxiliary, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left_cursor = low,<br>        right_cursor = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 指向第一个没加入的元素</span><br>    <span class="hljs-comment">//if (start[mid] &lt;= start[mid + 1])</span><br>    <span class="hljs-comment">//    return;  //  不能使用这样的优化，因为在 auxiliary 和 start 交换优化时这两个数组根本不相等，没法把 auxiliary 写回</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = low; i &lt;= high; ++i) &#123;  <span class="hljs-comment">// 设计好循环的次数，保证不越界</span><br>        <span class="hljs-keyword">if</span> (left_cursor &gt; mid)<br>            start[i] = auxiliary[right_cursor++];  <span class="hljs-comment">// 左边全加进去了加右边</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right_cursor &gt; high)<br>            start[i] = auxiliary[left_cursor++];  <span class="hljs-comment">// 右边全加进去了加左边</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (auxiliary[left_cursor] &gt; auxiliary[right_cursor])<br>            start[i] = auxiliary[right_cursor++];<br>        <span class="hljs-keyword">else</span><br>            start[i] = auxiliary[left_cursor++];  <span class="hljs-comment">// 否则就比左右大小决定</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort_TD</span><span class="hljs-params">(T* start, T* auxiliary, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (high &lt;= low)<br>        <span class="hljs-keyword">return</span>;                        <span class="hljs-comment">// Only one in selection.</span><br>    <span class="hljs-keyword">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// Ensure mid &lt;= high</span><br>    <span class="hljs-built_in">merge_sort_TD</span>(auxiliary, start, low, mid);<br>    <span class="hljs-built_in">merge_sort_TD</span>(auxiliary, start, mid + <span class="hljs-number">1</span>, high);<br>    <span class="hljs-built_in">merge</span>(start, auxiliary, low, mid, high);<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort_TopDown</span><span class="hljs-params">(T* start, <span class="hljs-keyword">int</span> scale)</span> </span>&#123;<br>    T *auxiliary = <span class="hljs-keyword">new</span> T[scale];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; scale; ++i) &#123;<br>        auxiliary[i] = start[i];<br>    &#125;<br>    <span class="hljs-built_in">merge_sort_TD</span>(start, auxiliary, <span class="hljs-number">0</span>, scale - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">delete</span>[] auxiliary;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h3><p>快速排序 (Quick Sort) 被誉为是“20世纪对科学和工程领域的发展产生最大影响力的十大算法”<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://blog.sciencenet.cn/blog-83029-468247.html">[2]</span></a></sup>，在快速排序中对给定的范围需要选定一个切分元素（“轴”元素 pivot），接下来保证比它大的元素在切分元素后面，比它小的在前面，不断缩小范围，直到完成排序。这就好像给 N 个班混在一起的考试卷分开一样，先大体上分成几小堆，再继续分（先忽略那个 move_pivot_to_first 函数）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">part</span><span class="hljs-params">(T* start, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-built_in">move_pivot_to_first</span>(start, left, right);<br>    <span class="hljs-keyword">int</span> l_cursor = left, r_cursor = right + <span class="hljs-number">1</span>;<br>    T partition = start[left];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">while</span> (start[++l_cursor] &lt; partition) <span class="hljs-keyword">if</span> (l_cursor == right) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">while</span> (start[--r_cursor] &gt; partition) ;<span class="hljs-comment">/*if (r_cursor == left) break;*/</span><br>        <span class="hljs-keyword">if</span> (l_cursor &gt;= r_cursor) <span class="hljs-keyword">break</span>;<br>        std::<span class="hljs-built_in">swap</span>(start[l_cursor], start[r_cursor]);<br>    &#125;<br>    std::<span class="hljs-built_in">swap</span>(start[left], start[r_cursor]);<br>    <span class="hljs-keyword">return</span> r_cursor;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(T* start, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> <span class="hljs-comment">/* 闭区间 */</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (right &lt;= left) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> partition = <span class="hljs-built_in">part</span>(start, left, right);<br>    <span class="hljs-built_in">quick_sort</span>(start, left, partition - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quick_sort</span>(start, partition + <span class="hljs-number">1</span>, right);<br>&#125;<br></code></pre></td></tr></table></figure><br>每次进行切分的步骤是：规定切分元素是某段数组的首个元素，略过数组首个元素，向右移动左指针，直到它不小于切分元素大小或达到右边界，这时左指针以左全是小于切分元素的值；向左移动右指针，直到它不大于切分元素（不用检查是不是到了左边界，左边最前面就是切分元素，最坏情况会停在切分元素上），这时它右边的值全部大于切分元素；检查左右指针相对位置，如果有重叠，说明已经完成切分，此时把首个元素和右指针指向元素进行交换即可（为什么交换右指针指向元素？因为首个元素在左侧，交换后必须保证它小于等于切分元素，而此时左指针已经移出小于切分元素值的区域了，可能指向的是第一个大于切分元素值的元素）；如果不重叠，直接交换左右指针指向的元素，再继续进行这一步骤。<br>完成切分之后，返回切分元素的位置（右指针），这样就把数组切成两小段，再继续切分。<br>由此可见，如果选择的切分元素大小处在待排序元素的中位数附近，那么两个子数组长度接近，可以使得递归的深度更小（接近 log N），每层合计需要遍历所有元素，则其时间复杂度为 O(nlog n)。然而，如果每次切分所选择的都是最大或者最小的元素——如这个数组本来就是有序的，那么递归的深度为 N，此时整个排序过程成为 O(N<sup>2</sup>) 的时间复杂度，这显然是我们不希望的。因此，一味地选取数组首个元素作为切分元素是不合适的，在这里我们采用三取样切分，取首个元素下一位，中间，末尾三个值的中位数与数组首个元素交换以减少最坏情况的发生（这里参考了 gcc 11.1.0 的 <code>std::__move_median_to_first</code> 函数）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">move_pivot_to_first</span><span class="hljs-params">(T *array, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> middle = (right - left) / <span class="hljs-number">2</span> + left; <span class="hljs-comment">// 防 int 溢出</span><br>    <span class="hljs-keyword">if</span> (array[left + <span class="hljs-number">1</span>] &lt; array[right]) &#123;<br>        <span class="hljs-keyword">if</span> (array[right] &lt; array[middle])  &#123;<br>            std::<span class="hljs-built_in">swap</span>(array[left], array[right]);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (array[middle] &lt; array[left + <span class="hljs-number">1</span>]) &#123;<br>            std::<span class="hljs-built_in">swap</span>(array[left], array[left + <span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        std::<span class="hljs-built_in">swap</span>(array[left], array[middle]);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (array[left + <span class="hljs-number">1</span>] &lt; array[middle]) &#123;<br>        std::<span class="hljs-built_in">swap</span>(array[left + <span class="hljs-number">1</span>], array[left]);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (array[middle] &lt; array[right]) &#123;<br>        std::<span class="hljs-built_in">swap</span>(array[right], array[left]);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    std::<span class="hljs-built_in">swap</span>(array[middle], array[left]);<br>&#125;<br></code></pre></td></tr></table></figure><br>可以看出，快速排序对于随机性强的数据更有优势，而对于已经部分有序的数据，则不能利用这种有序性。快速排序是原地排序算法，但我们的实现版本需要递归，当每次切分元素都较为均匀时，递归深度接近 log<sub>2</sub>N，此时空间复杂度为 O(log N)（由于栈是先入后出的，此时递归二叉树的另一半还没有长出来，另一半生长出来时左边已经释放了，而我们只考虑同一时间占用的最大内存）；当每次切分元素都是两端的元素时，空间复杂度达到了 O(n)。此外，快速排序是不稳定的排序算法，如果左右指针指向的元素大小相同，并且他们被分别切到了左右两边，那么这对元素仍然会被交换位置。</p><h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h3><p>堆排序 (Heap Sort) 的一种实现方法是为元素创建最大堆，每次取出堆顶最大元素并移动到数组的最后，从而得到有序数组。在建堆过程中，由上而下进行有序化，保证节点大于其儿子节点的过程成为下沉 (sink)；由下而上进行有序化，保证节点小于其父亲的过程称为上浮 (swim)。在输入数组中构造堆时，可以自顶向下推进，依次把末尾的新节点上浮，也可以自底向上，依次把新节点下沉。自底向上建堆时，可以把后一半的节点（叶子节点）省掉，且插入大量底部节点时树高较小，插入少量顶部节点时树高较大，更加合理，但判断与哪个儿子交换时会略微复杂。我们采用自底向上建堆的方法建立最大堆。之后，我们将堆顶的元素与最后一个元素交换，这时最后一个元素是最大元素，我们把它排除在堆外，即令堆的大小减 1，再从堆顶进行下沉操作，得到新的最大堆，再取堆顶与倒数第二个元素交换，这样一直进行下去：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* Make sure that the pointer start points at the top of the heap, </span><br><span class="hljs-comment">otherwise we can&#x27;t access the children by 2 * start_position + 1/ + 2 */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sink</span><span class="hljs-params">(T *start, <span class="hljs-keyword">int</span> start_position,  <span class="hljs-keyword">int</span> scale)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span> &gt;= scale) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * start_position + <span class="hljs-number">2</span> &gt;= scale) &#123; <span class="hljs-comment">/* only left child */</span><br>            <span class="hljs-keyword">if</span> (start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span>] &gt; start[start_position]) &#123;<br>                T temp = start[start_position];<br>                start[start_position] = start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span>];<br>                start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span>] = temp;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span>] &gt; start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">2</span>]) &#123; <span class="hljs-comment">/* left child bigger than right*/</span>          <br>            <span class="hljs-keyword">if</span> (start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span>] &gt; start[start_position]) &#123; <span class="hljs-comment">/* left bigger than father */</span><br>                T temp = start[start_position];<br>                start[start_position] = start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span>];<br>                start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span>] = temp;<br>                start_position = <span class="hljs-number">2</span> * start_position + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">/* right child bigger than left */</span><br>        <span class="hljs-keyword">if</span> (start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">2</span>] &gt; start[start_position] <span class="hljs-comment">/* right child bigger than father*/</span>) &#123;<br>            T temp = start[start_position];<br>            start[start_position] = start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">2</span>];<br>            start[<span class="hljs-number">2</span> * start_position + <span class="hljs-number">2</span>] = temp;<br>            start_position = <span class="hljs-number">2</span> * start_position + <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">(T *start, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-comment">// firstly build heap</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> sink_start = length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; sink_start &gt;= <span class="hljs-number">0</span>; --sink_start) &#123;<br>        <span class="hljs-built_in">sink</span>(start, sink_start, length);<br>    &#125;<br>    <span class="hljs-comment">// secondly swap the top elem with the last and sink the top again</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; ++i) &#123;<br>        T top = *start;<br>        *start = *(start + length - i);<br>        *(start + length - i) = top;<br><br>        <span class="hljs-built_in">sink</span>(start, <span class="hljs-number">0</span>, length - i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>建堆时我们自底向上地建堆，假设这个堆有 N = 2<sup>k</sup>-1 个元素，建立自底向上第 i 层时共有 $\frac{N+1}{2^i}$ 个元素，每个元素下沉时最多比较 2(i-1) 次，总比较次数 $\sum_{i-1}^{\log_{2}(N+1)}{\frac{N+1}{2^i}\cdot{}{2(i-1)}}$ ，经错位相减求和可知，建堆需要 O(n) 时间复杂度；每次删除最大元素后的调整是 log n 级别的，全部删除元素需要 O(nlog n) 时间复杂度，故整个堆排序的时间复杂度为 O(nlog n)。但是，堆排序比较大小的数据（儿子节点、父亲节点）在内存中常常不连续，而快速排序访问连续的数据的比重更大，根据局部性原理，快速排序对 cache 等利用效率更高，要更快一些。<br>堆排序是原地排序，空间复杂度为 O(1)。堆排序也不是稳定的排序算法：9 <em>4</em> <strong>4</strong> -&gt; <strong>4</strong> <em>4</em>  9<br>R.W. Floyd 提出<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="《算法（第 4 版）》P208">[3]</span></a></sup>，由于建堆后数组末尾的元素均是较小的元素，它们在交换到堆顶后大概率还会下沉到很靠近堆底的部分，在每次取出最大元素后可以先另外暂存占用的数组末尾的那个元素，然后从堆顶开始，把较大的儿子节点覆盖到堆顶，再把大儿子的大儿子节点覆盖大儿子，一直到堆底，这时再把暂存的元素放到停下来的位置，从这里开始做上浮操作，这样能避免传统方法（从堆顶下沉）中不必要的比较大小（不用把堆顶和左右节点比较了），虽然看起来额外增加了一段路程，但总体上是减少了比较次数的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swim</span><span class="hljs-params">(T *start, <span class="hljs-keyword">int</span> node_pos)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (node_pos) &#123;<br>        <span class="hljs-keyword">if</span> (start[(node_pos - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>] &lt; start[node_pos]) &#123;<br>            T temp = start[node_pos];<br>            start[node_pos] = start[(node_pos - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>];<br>            node_pos = (node_pos - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            start[node_pos] = temp;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heap_sort_floyd</span><span class="hljs-params">(T *start, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> sink_start = length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; sink_start &gt;= <span class="hljs-number">0</span>; --sink_start) &#123;<br>        <span class="hljs-built_in">sink</span>(start, sink_start, length);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; ++i) &#123;<br>        T end = *(start + length - i);<br>        *(start + length - i) = *start;<br>        <span class="hljs-keyword">int</span> new_pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &gt;= length - i) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">2</span> &gt;= length - i) &#123; <span class="hljs-comment">// only left child</span><br>                <span class="hljs-comment">//if (start[new_pos * 2 + 1] &gt; start[new_pos]) &#123;</span><br>                    start[new_pos] = start[new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>                    new_pos = new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//&#125;</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (start[new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &gt; start[new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>]) &#123;<br>                start[new_pos] = start[new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>                new_pos = new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                start[new_pos] = start[new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>];<br>                new_pos = new_pos * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        start[new_pos] = end;<br>        <span class="hljs-built_in">swim</span>(start, new_pos);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8. 计数排序"></a>8. 计数排序</h3><p>计数排序（Counting Sort）可以通过用元素值直接访问数组来统计比某个元素小的元素的个数，从而得出元素排序后的数组下标来实现排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">counting_sort</span><span class="hljs-params">(T *start, <span class="hljs-keyword">int</span> elem_num, <span class="hljs-keyword">int</span> array_size)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> *times = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[array_size];<br>    <span class="hljs-built_in">memset</span>(times, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) * array_size);<br>    <span class="hljs-keyword">int</span> *offset = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[elem_num];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elem_num; ++i) &#123;<br>        ++times[start[i]];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; array_size; ++i) &#123;<br>        times[i] += times[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = elem_num - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        offset[i] = --times[start[i]];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elem_num; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (offset[i] != i) &#123;<br>            T temp = start[i];<br>            start[i] = start[offset[i]];<br>            start[offset[i]] = temp;<br>            std::<span class="hljs-built_in">swap</span>(offset[i], offset[offset[i]]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] times;<br>    <span class="hljs-keyword">delete</span>[] offset;<br>&#125;<br></code></pre></td></tr></table></figure><br>此排序算法要求待排序元素的键值必须能作为数组下标，且要求我们知道待排序元素的取值范围。我们申请一个与取值范围相同的数组并赋初值为 0，之后通过元素的键值直接访问该数组，将对应值加 1，直到遍历全部元素。之后，从前到后地，把取值范围数组中（从第二个元素开始）每个位置上的元素与前一个位置上的元素相加并赋值给这个位置，这样这个位置下标的值就是从小到大访问到这个元素时，总共已经有了多少元素。遍历完后，可以新建一个临时数组以保存排序结果，从后往前遍历源数组，把源数组元素值作为下标访问取值范围数组，得到的值就是其在临时数组中的下标，之后再把刚刚用源数组元素值访问范围数组得到的值 - 1 后写回。通过倒序遍历、减一写回，我们实现了排序的稳定性。但是不同版本计数排序实现不同，代码中的版本是不开辅助数组的版本，仍然保证了排序的稳定性。<br>计数排序正是一种不基于比较的排序算法。以上代码排序 int 时的时间复杂度为 O(n+k)，空间复杂度为 O(k)，其中 k 为数字的范围。当 n+k &lt; nlog n 时，计数排序可以实现对快速排序等基于比较的排序算法的超越。然而如果数据过于稀疏，n+k 甚至会远大于 nlog n。</p><h3 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9. 桶排序"></a>9. 桶排序</h3><p>我曾经突发奇想，能不能直接利用自然数作为数组下标来访问数组的方式实现排序呢？于是我写下了类似的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Due to the lack of memory, we only allow [0, 2147483646] here.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pigeonhole_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *start, <span class="hljs-keyword">int</span> elem_num, <span class="hljs-keyword">int</span> max_value)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> *array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[max_value + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">memset</span>(array, <span class="hljs-number">-1</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) * (max_value + <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elem_num; ++i) &#123;<br>        ++array[start[i]];<br>    &#125;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; max_value + <span class="hljs-number">1</span>; ++j) &#123;<br>        <span class="hljs-keyword">while</span> (~array[j]) &#123;<br>            start[i++] = j;<br>            --array[j];<br>            <span class="hljs-keyword">if</span> (i == elem_num) &#123;<br>                j = max_value;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] array;<br>&#125;<br></code></pre></td></tr></table></figure><br>虽然开一个 2147483647 长度的整型数组需要大概 8GB 的内存（而且大多数情况下不会有 2147483647 个重复的元素，也就用不到 int 来存放相同元素的个数），但这种朴素的排序算法（鸽巢排序，Pigeonhole Sort）其实正是桶排序 (Bucket Sort) 的雏形。桶排序先用某些键值将元素装进不同的桶里以缩小问题规模，然后常常通过其他排序方式继续对同一个桶中的元素进行排序，最后将桶中的元素依次拿出按顺序放在一起。比如说要对某些日期排序时，先按月份排好，再在每个月份中按日期进行排序。下面的代码通过将 [0, 1) 之间的数据分成 10 个“桶”，然后对每个桶中的链表进行插入排序实现桶排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// [0, 1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bucket_sort_0to1</span><span class="hljs-params">(<span class="hljs-keyword">double</span>* src, <span class="hljs-keyword">size_t</span> len)</span> </span>&#123;<br>    Node** list = <span class="hljs-keyword">new</span> Node*[<span class="hljs-number">10</span>];<br>    <span class="hljs-built_in">memset</span>(list, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Node*) * <span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        Node** ptr = &amp;list[(<span class="hljs-keyword">int</span>)(src[i] * <span class="hljs-number">10</span>)];<br>        <span class="hljs-keyword">while</span> (*ptr) &#123;<br>            <span class="hljs-keyword">if</span> ((*ptr)-&gt;val &lt;= src[i])<br>                ptr = &amp;(*ptr)-&gt;next;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        *ptr = <span class="hljs-keyword">new</span> Node&#123;src[i], *ptr&#125;;<br>    &#125;<br>    <span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i != len) &#123;<br>        Node* ptr = list[j++];<br>        <span class="hljs-keyword">while</span> (ptr) &#123;<br>            src[i] = ptr-&gt;val;<br>            ptr = ptr-&gt;next;<br>            ++i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        <span class="hljs-keyword">delete</span> list[i];<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] list;<br>&#125;<br></code></pre></td></tr></table></figure><br>在这段代码中，当元素均匀分布在 [0, 1) 中时，将元素分为 k 桶需要 O(n) 时间复杂度，而对每一桶元素使用插入排序时间复杂度为 $O(\frac{n^2}{k^2})$，因此总时间复杂度为 $O(n+\frac{n^2}{k})$。当 k 接近于 n 时（接近鸽巢排序），此时总时间复杂度接近 O(n)。然而，最坏情况下，所有元素集中在同一个桶，此时桶排序退化为插入排序，时间复杂度为 O(n<sup>2</sup>)。此外，如果桶的个数 k 远多于 n 时，此时桶排序效率也不够理想。<br>桶排序空间复杂度为 O(n+k)，是稳定的排序算法。</p><h3 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10. 基数排序"></a>10. 基数排序</h3><p>当我们比较整数时，常常是由高到低按位比较的，能否依照此思想设计一种排序算法呢？基数排序（Radix Sort）正是一种对各元素从低位到高位先放入个数等于进制数的桶中，再将各桶中的元素按顺序取出，直到整个数组中的元素均有序的排序算法。可以看出，该算法的实现依赖于桶排序的稳定性：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">radix_sort_linkedlist</span><span class="hljs-params">(T *src, <span class="hljs-keyword">int</span> base, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span>Node * next; T elem;&#125;;<br>    Node **list = <span class="hljs-keyword">new</span> Node*[base];<br>    T *sorted = <span class="hljs-keyword">new</span> T[len];<br>    <span class="hljs-built_in">memset</span>(list, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Node*) * base);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        sorted[i] = src[i];<br>    &#125;<br>    <span class="hljs-keyword">int</span> i = base, k = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len ; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (!list[sorted[j] % i / k]) &#123;<br>                list[sorted[j] % i / k] = <span class="hljs-keyword">new</span> Node&#123;<span class="hljs-literal">nullptr</span>, sorted[j]&#125;;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list[sorted[j] % i / k]-&gt;elem &gt; sorted[j]) &#123;<br>                list[sorted[j] % i / k] = <span class="hljs-keyword">new</span> Node&#123;list[sorted[j] % i / k], sorted[j]&#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Node *now = list[sorted[j] % i / k];<br>                <span class="hljs-keyword">while</span> (now-&gt;next &amp;&amp; now-&gt;next-&gt;elem &lt; sorted[j]) now = now-&gt;next;<br>                now-&gt;next = <span class="hljs-keyword">new</span> Node&#123;now-&gt;next, sorted[j]&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> sorted_elem_num = <span class="hljs-number">0</span>, curr_base = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (sorted_elem_num &lt; len) &#123;<br>            Node *curr_node = list[curr_base++];<br>            <span class="hljs-keyword">while</span> (curr_node) &#123;<br>                sorted[sorted_elem_num++] = curr_node-&gt;elem;<br>                curr_node = curr_node-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; base; ++j) &#123;<br>            Node *curr_del = list[j];<br>            <span class="hljs-keyword">while</span> (curr_del) &#123;<br>                Node *temp = curr_del-&gt;next;<br>                <span class="hljs-keyword">delete</span> curr_del;<br>                curr_del = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">memset</span>(list, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Node*) * base);<br>        <span class="hljs-keyword">if</span> (curr_base == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>        i = i * base;<br>        k = k * base;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        src[i] = sorted[i];<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] list;<br>    <span class="hljs-keyword">delete</span>[] sorted;<br>&#125;<br></code></pre></td></tr></table></figure><br>在这里，我们对每一位进行桶排序时，实际上可以利用计数排序的思想直接计算出每个元素在拼接出新数组的位置，从而摆脱有形的“桶”：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">radix_sort</span><span class="hljs-params">(T *src, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">long</span> base)</span> </span>&#123;<br>    T * <span class="hljs-keyword">const</span> initial_src = src;<br>    T *copy = <span class="hljs-keyword">new</span> T[len];<br>    <span class="hljs-keyword">long</span> curr_base = base, last_base = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> *count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[base];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-built_in">memset</span>(count, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) * base);<br>        <span class="hljs-keyword">bool</span> has_nonzero_group = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (src[i] / last_base) has_nonzero_group = <span class="hljs-literal">true</span>;<br>            ++count[src[i] % curr_base / last_base];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!has_nonzero_group) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; base; ++i) &#123;<br>            count[i] += count[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            copy[--count[src[i] % curr_base / last_base]] = src[i];<br>        &#125;<br>        T *temp = src;<br>        src = copy;<br>        copy = temp;<br>        last_base = curr_base;<br>        curr_base *= base;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (initial_src != src) &#123;<br>        T *temp = copy;<br>        copy = src;<br>        src = temp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            src[i] = copy[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] copy;<br>    <span class="hljs-keyword">delete</span>[] count;<br>&#125;<br></code></pre></td></tr></table></figure><br>这里我们每次的模 <code>curr_base</code> 都会与进制数 <code>base</code> 相乘，相当于元素中进行比较的位每次都会左移，实现从低位到高位的比较，同时除以 <code>last_base</code> 舍弃掉末尾已经比较过的位上的数字，同时使得数在 [0, base) 范围内；用 <code>src</code> 和 <code>copy</code> 两个数组来回交换，省去了部分的元素复制操作。<br>基数排序是稳定的排序算法，由于从桶中“拿出”到 <code>copy</code> 是按顺序的，相同大小元素的相对位置不变。<br>基数排序时间复杂度看起来是 O(d(n+k)) ，其中 n 是元素数目，k 是桶的个数，d 是元素的位数，但是 d 与 n 并不是完全无关的：重复元素越少，d 与 n 就越相关，当所有元素均不重复时，$d\geq\log_kn$，此时时间复杂度达到 O(nlog n)级别；当所有元素均大小相等时，时间复杂度为 O(n+k)。不过，我们可以利用计算机多位数比较的硬件能力，将多位数合成一次比较，减少比较次数（认为 CPU 每次比较是等时的，那不妨一次多比较几位）。<br>基数排序空间复杂度为 O(n+k)。（这里采用了类似计数排序的处理方式）<br>显然上面的代码在元素能转为非负整型值时可以排序，但元素是浮点数呢？查阅互联网后，我了解到，IEEE 754 标准下的浮点数，在不考虑符号位时，具有和整型相似的性质：自低位到高位，各位对结果大小的影响越来越大，且高位有“压倒性”优势，那么我们也可以写出如下的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">radix_sort_double</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *src, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> base = <span class="hljs-number">256</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *src_l = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *)src;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> * <span class="hljs-keyword">const</span> initial_src = src_l;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *copy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>[len];<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>[base];<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> FLIP_MSB = (<span class="hljs-number">1ull</span> &lt;&lt; <span class="hljs-number">63</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (src_l[i] &gt;= FLIP_MSB) src_l[i] = ~src_l[i];<br>        <span class="hljs-keyword">else</span> src_l[i] ^= FLIP_MSB;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> eightbit = <span class="hljs-number">0</span>; eightbit &lt; <span class="hljs-number">8</span>; ++eightbit) &#123;<br>        <span class="hljs-built_in">memset</span>(count, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) * base);<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *bit = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *&gt;(src_l) + eightbit; <span class="hljs-comment">// src_l 和 copy 交换，导致只能使用 src_l 不能用 src</span><br><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            ++count[(<span class="hljs-keyword">unsigned</span>)*(bit + <span class="hljs-number">8</span> * i)];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; base; ++i) &#123;<br>            count[i] += count[i - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> (count[(<span class="hljs-keyword">unsigned</span>)*(bit + <span class="hljs-number">8</span> * i)] == <span class="hljs-number">0</span>) <span class="hljs-built_in">abort</span>();<br>            copy[--count[(<span class="hljs-keyword">unsigned</span>)*(bit + <span class="hljs-number">8</span> * i)]] = src_l[i];<br>        &#125;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *temp = src_l;<br>        src_l = copy;<br>        copy = temp;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (initial_src != src_l) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *temp = copy;<br>        copy = src_l;<br>        src_l = temp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            src_l[i] = copy[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (src_l[i] &gt;= FLIP_MSB)<br>        src_l[i] ^= FLIP_MSB;<br>        <span class="hljs-keyword">else</span> src_l[i] = ~src_l[i];<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] copy;<br>    <span class="hljs-keyword">delete</span>[] count;<br>&#125;<br></code></pre></td></tr></table></figure><br>这里我们先把负数取反，因为去掉符号位后绝对值大的负数取反后绝对值小，这样稍后排序时就把小的负数排在大的负数前面；同时对整数只对最高位取反，这样负数的符号位（最高为）实际上成了 0，正数的符号位成了 1，这样稍后排序时负数始终在正数前面。之后，我们由低位向高位 一个字节一个字节地排序（x86 采用小端模式，多字节数据，如这里的 double，的低字节在小的地址端，所以指针递增时实际上是由低字节指向高字节，也就是基数排序从低位向高位转移），最后就能得出结果。</p><h2 id="Part-2-总结"><a href="#Part-2-总结" class="headerlink" title="Part 2 总结"></a>Part 2 总结</h2><p>排序算法多种多样，且一种排序算法常有许多不同的实现，本文只是粗浅地谈到了其中的几种。可以看出，基于比较的排序算法平均时间复杂度不可能低于 nlog n 级别，这是因为一般地，要想将 n 个元素排序完毕，必须确定这 n 个元素之间的相对大小关系。n 个元素相对大小关系共有 n! 种可能（相等被合并进大于或者小于里），而我们每进行一次比较，就把可能的大小关系数减少一半，而 n! 总共需要这样“折半”的次数，是计算 log(n!) = nlog n 级别的。在基于比较的排序算法里，当给出的数据是“随机”的时，快速排序似乎是最快的，但它不是稳定的。如果想要稳定的话，可以考虑归并排序。而当数据总体上是有序时，插入排序则常常是最快的。需要实现优先队列时，可能选择的是堆排序。<br>实际上，C++ STL (g++ 11.1.0, Linux x86_64) 上 std::sort 使用的是“内省式排序” (Introspective Sort)，在元素个数大于 16 时先进行快速排序（三取样切分），快速排序时发现递归深度超过 2log n 时启动堆排序，最后使用插入排序收尾。而 Java JDK 1.8 排序整型数组时，长度小于等于 47 时采用插入排序，长度大于 47 小于等于 286 ，或是长度大于 286 且相同元素或乱序组过多时根据数据相等的情况，决定是采用双轴快速排序 (Dual Pivot Quicksort) 还是单轴快速排序，长度大于 286 且有序情况好的整型数组采用归并排序<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://cloud.tencent.com/developer/article/1690708?from=article.detail.1394343">[4]</span></a></sup>；排序 char、byte 时，数组足够大时将启用计数排序<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.csdn.net/qq_45557225/article/details/105956950">[5]</span></a></sup>。此外，Python 还使用了 TimSort，这一排序算法被认为在现实数据（有一定的有序片段）的排序中性能超过快速排序。就算是对于我们已经简单介绍过的这些算法，也仍然有许多值得尝试的思路，如使用迭代而非递归实现快速排序。不幸的是，笔者水平有限，也没有如此的精力。我们必须结尾了。</p><h2 id="Part-3-性能测试（娱乐）"><a href="#Part-3-性能测试（娱乐）" class="headerlink" title="Part 3 性能测试（娱乐）"></a>Part 3 性能测试（娱乐）</h2><p>下面的代码在 Intel Core i5-10400 的笔记本上编译运行，Linux 内核版本 5.15.2-arch1-1，glibc 版本 2.33-5，g++ 版本 11.1.0：（g++ 开启 O2 优化）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::random_device rd;<br>    <span class="hljs-function">std::default_random_engine <span class="hljs-title">eng</span><span class="hljs-params">(rd())</span></span>;<br>    std::uniform_real_distribution&lt;&gt; <span class="hljs-built_in">distr</span>(下界, 上界);<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> LENGTH = 数组长度;<br>    <span class="hljs-keyword">double</span> test_input_double[LENGTH], test_src[LENGTH], standard_answer[LENGTH];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>); ++i) &#123;<br>        standard_answer[i] = test_input_double[i] = <span class="hljs-built_in">distr</span>(eng);<br>    &#125;<br>    <span class="hljs-keyword">clock_t</span> start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">sort</span>(standard_answer, standard_answer + <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(standard_answer) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br>    cout &lt;&lt; <span class="hljs-string">&quot;std::sort &quot;</span> &lt;&lt;(<span class="hljs-keyword">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">qsort</span>(test_src, LENGTH, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>), double_cmp);<br>    cout &lt;&lt; <span class="hljs-string">&quot;qsort &quot;</span> &lt;&lt;(<span class="hljs-keyword">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) &#123;cout&lt;&lt;<span class="hljs-string">&quot;qsort dead!&quot;</span>&lt;&lt;endl;<span class="hljs-built_in">abort</span>();&#125;<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">selection_sort</span>(test_src, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br>    cout &lt;&lt; <span class="hljs-string">&quot;Selection Sort &quot;</span> &lt;&lt;(<span class="hljs-keyword">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">insertion_sort</span>(test_src, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br>    cout &lt;&lt; <span class="hljs-string">&quot;Insertion Sort &quot;</span> &lt;&lt;(<span class="hljs-keyword">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">skipsorted_cocktail_sort</span>(test_src, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br>    cout &lt;&lt; <span class="hljs-string">&quot;Cocktail Sort(Skip Sorted) &quot;</span> &lt;&lt;(<span class="hljs-keyword">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">shell_sort</span>(test_src, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br>    cout &lt;&lt; <span class="hljs-string">&quot;Shell Sort &quot;</span> &lt;&lt;(<span class="hljs-keyword">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">merge_sort_TopDown</span>(test_src, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br>    cout &lt;&lt; <span class="hljs-string">&quot;Merge Sort(Top Down) &quot;</span> &lt;&lt;(<span class="hljs-keyword">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">quick_sort</span>(test_src, <span class="hljs-number">0</span>,  <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>) - <span class="hljs-number">1</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Quick Sort &quot;</span> &lt;&lt;(<span class="hljs-keyword">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">heap_sort_floyd</span>(test_src, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br>    cout &lt;&lt; <span class="hljs-string">&quot;Heap Sort (Floyd) &quot;</span> &lt;&lt;(<span class="hljs-keyword">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(test_src, test_input_double, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double));<br>    start_time = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">radix_sort_double</span>(test_src, <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>)));<br>    cout &lt;&lt; <span class="hljs-string">&quot;Radix Sort &quot;</span> &lt;&lt;(<span class="hljs-keyword">double</span>)(<span class="hljs-built_in">clock</span>() - start_time) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test_input_double) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (standard_answer[i] != test_src[i]) <span class="hljs-built_in">abort</span>();<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><br>改变数组的长度，下界，上界，每次运行 3 次取平均时间，对随机序列浮点数排序：<br>当上下界为 <code>(-1000, 1000)</code> 时：</p><div class="table-container"><table><thead><tr><th>数组长度</th><th>100</th><th>1000</th></tr></thead><tbody><tr><td>std::sort</td><td>7.66667E-06</td><td>0.000111667</td></tr><tr><td>qsort</td><td>1.33333E-05</td><td>0.000197</td></tr><tr><td>选择排序</td><td>1.36667E-05</td><td>0.001195667</td></tr><tr><td>插入排序</td><td>1.03333E-05</td><td>0.000722333</td></tr><tr><td>跳过有序部分的鸡尾酒排序</td><td>0.000024</td><td>0.001728667</td></tr><tr><td>希尔排序</td><td>0.000007</td><td>9.73333E-05</td></tr><tr><td>自顶向下归并排序</td><td>1.03333E-05</td><td>0.000105667</td></tr><tr><td>快速排序</td><td>0.000008</td><td>9.93333E-05</td></tr><tr><td>Floyd 优化堆排序</td><td>0.000009</td><td>0.000113333</td></tr><tr><td>基数排序</td><td>1.33333E-05</td><td>0.000046</td></tr></tbody></table></div><p>当上下界为 <code>(-1000000, 1000000)</code> 时：</p><div class="table-container"><table><thead><tr><th>数组长度</th><th>100</th><th>1000</th></tr></thead><tbody><tr><td>std::sort</td><td>1.30E-05</td><td>0.000147333</td></tr><tr><td>qsort</td><td>2.20E-05</td><td>0.000278</td></tr><tr><td>选择排序</td><td>2.30E-05</td><td>0.001250333</td></tr><tr><td>插入排序</td><td>1.63E-05</td><td>0.001108</td></tr><tr><td>跳过有序部分的鸡尾酒排序</td><td>3.83E-05</td><td>0.002401667</td></tr><tr><td>希尔排序</td><td>1.07E-05</td><td>0.000148667</td></tr><tr><td>自顶向下归并排序</td><td>1.67E-05</td><td>0.000158</td></tr><tr><td>快速排序</td><td>1.37E-05</td><td>0.000148</td></tr><tr><td>Floyd 优化堆排序</td><td>1.37E-05</td><td>0.000170333</td></tr><tr><td>基数排序</td><td>2.33E-05</td><td>6.53333E-05</td></tr></tbody></table></div><p>总的来说，数据范围小时，排序似乎更快，以下几组都在 <code>(-1000, 1000)</code> 中测出（这几组由于长度比较长，没有重复实验）：</p><div class="table-container"><table><thead><tr><th>数组长度</th><th>10000</th><th>100000</th><th>1000000</th></tr></thead><tbody><tr><td>std::sort</td><td>0.000936333</td><td>0.012468</td><td>0.071469</td></tr><tr><td>qsort</td><td>0.001347</td><td>0.012289333</td><td>0.111367</td></tr><tr><td>选择排序</td><td>0.033825</td><td>2.86037</td><td>333.48</td></tr><tr><td>插入排序</td><td>0.033676</td><td>3.161943333</td><td>341.91</td></tr><tr><td>跳过有序部分的鸡尾酒排序</td><td>0.091149667</td><td>9.482406667</td><td>1009.35</td></tr><tr><td>希尔排序</td><td>0.000645333</td><td>0.008864</td><td>0.12158</td></tr><tr><td>自顶向下归并排序</td><td>0.000623333</td><td>0.008097667</td><td>0.097622</td></tr><tr><td>快速排序</td><td>0.000550333</td><td>0.006777</td><td>0.080969</td></tr><tr><td>Floyd 优化堆排序</td><td>0.000673333</td><td>0.009133667</td><td>0.128802</td></tr><tr><td>基数排序</td><td>0.000163</td><td>0.002073333</td><td>0.028749</td></tr></tbody></table></div><p>仅仅是为了好玩，我又测量了 200000，300000，…，900000 的情况，得到：<br><img src="https://zhaozihanzzh.github.io/images/sort_time.png" alt="总用时"><br><img src="https://zhaozihanzzh.github.io/images/sort_withoutn2.png" alt="去除 O(n^2) 后的用时"><br>为了考察有序性对性能的影响，当数组长度为 10000，范围 <code>(-1000，1000)</code> 时，测量出完全升序、（第 0，10000，20000，30000，40000，…，90000）随机，其余位置升序、完全降序的情况：</p><div class="table-container"><table><thead><tr><th>有序性</th><th>完全升序</th><th>接近升序</th><th>完全降序</th></tr></thead><tbody><tr><td>std::sort</td><td>0.001059</td><td>0.005846</td><td>0.001357</td></tr><tr><td>qsort</td><td>0.002488</td><td>0.002918</td><td>0.004248</td></tr><tr><td>选择排序</td><td>2.84899</td><td>3.72152</td><td>2.87279</td></tr><tr><td>插入排序</td><td>8.6e-05</td><td>0.000498</td><td>6.33238</td></tr><tr><td>跳过有序部分的鸡尾酒排序</td><td>0.000123</td><td>1.48579</td><td>6.57123</td></tr><tr><td>希尔排序</td><td>0.000667</td><td>0.00176</td><td>0.001462</td></tr><tr><td>自顶向下归并排序</td><td>0.001812</td><td>0.001958</td><td>0.002136</td></tr><tr><td>快速排序</td><td>0.001385</td><td>0.115653</td><td>0.001515</td></tr><tr><td>Floyd 优化堆排序</td><td>0.004723</td><td>0.004694</td><td>0.005258</td></tr><tr><td>基数排序</td><td>0.002475</td><td>0.002295</td><td>0.002025</td></tr></tbody></table></div><p>为了了解整型的情况，我又对 <code>(0, 1000000)</code> 的正整数排序进行测试，这次将基数排序替换为整型版本，并加入了计数排序：</p><div class="table-container"><table><thead><tr><th>数组长度</th><th>10000</th><th>100000</th><th>1000000</th></tr></thead><tbody><tr><td>std::sort</td><td>0.001190667</td><td>0.005622667</td><td>0.068292</td></tr><tr><td>qsort</td><td>0.002274667</td><td>0.009722333</td><td>0.104763</td></tr><tr><td>选择排序</td><td>0.046129</td><td>2.66948</td><td>308.974</td></tr><tr><td>插入排序</td><td>0.031989</td><td>2.98289</td><td>311.727</td></tr><tr><td>跳过有序部分的鸡尾酒排序</td><td>0.077564667</td><td>8.208996667</td><td>857.231</td></tr><tr><td>希尔排序</td><td>0.000599</td><td>0.00847</td><td>0.110247</td></tr><tr><td>自顶向下归并排序</td><td>0.000569667</td><td>0.007658667</td><td>0.095276</td></tr><tr><td>快速排序</td><td>0.000516333</td><td>0.006403333</td><td>0.071781</td></tr><tr><td>Floyd 优化堆排序</td><td>0.000665667</td><td>0.00898</td><td>0.131631</td></tr><tr><td>基数排序</td><td>0.001474</td><td>0.014975667</td><td>0.134972</td></tr><tr><td>计数排序</td><td>0.0004</td><td>0.002697667</td><td>0.062725</td></tr></tbody></table></div><p>由于 O2 优化等因素的影响，实际得到的结果与预想有些出入。<br>总之，尽管排序算法性能差距悬殊，可有时人和人之间的差别比这还大呢！</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>《算法（第 4 版）》P154<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="http://blog.sciencenet.cn/blog-83029-468247.html">http://blog.sciencenet.cn/blog-83029-468247.html</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>《算法（第 4 版）》P208<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://cloud.tencent.com/developer/article/1690708?from=article.detail.1394343">https://cloud.tencent.com/developer/article/1690708?from=article.detail.1394343</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://blog.csdn.net/qq_45557225/article/details/105956950">https://blog.csdn.net/qq_45557225/article/details/105956950</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>神船 TX6 修复 ArchLinux 下触摸板问题</title>
    <link href="/2021/09/25/touchpad-clevo-arch/"/>
    <url>/2021/09/25/touchpad-clevo-arch/</url>
    
    <content type="html"><![CDATA[<h1 id="神船-TX6-修复-ArchLinux-下触摸板问题"><a href="#神船-TX6-修复-ArchLinux-下触摸板问题" class="headerlink" title="神船 TX6 修复 ArchLinux 下触摸板问题"></a>神船 TX6 修复 ArchLinux 下触摸板问题</h1><h2 id="Part-1-背景"><a href="#Part-1-背景" class="headerlink" title="Part 1 背景"></a>Part 1 背景</h2><p>在 Arch Linux 刚刚<a href="https://zhaozihanzzh.github.io/2020/12/25/arch-install/">安装好</a>时，这台神船 TX6（蓝天 NK60SB 模具）的触摸板是正常的。然而，2021 年 2 月 26 日系统更新之后的重启改变了这一切——触摸板不能用了。我按照 wiki 上的各种方法，安装了 <code>xf86-input-synaptics</code>，调整了 <code>/etc/X11/xorg.conf.d/70-synaptics.conf</code>、<code>/usr/share/X11/xorg.conf.d/70-synaptics.conf</code>等配置文件 ，查了 <code>journalctl</code>、<code>/var/log/Xorg.0.log</code> 等各种日志，追踪了 <code>/proc/bus/input/devices</code>等，甚至安装了 GNOME、切换 wayland，无果。求助了一些大佬，仍然没有解决问题。由于当时更新了 nvidia 驱动，切换 nvidia 驱动仍然无果。后来，尝试<a href="https://zhaozihanzzh.github.io/2021/08/10/bios-gpu-switch/">禁用独显</a>，仍然没用，说明可能不是 nvidia 的原因……</p><h2 id="Part-2-解决"><a href="#Part-2-解决" class="headerlink" title="Part 2 解决"></a>Part 2 解决</h2><p>事发 6 个月后，通过在 Bing 上搜索 “dev/input/mouse touchpad” ，成功找到 <a href="https://bbs.archlinux.org/viewtopic.php?pid=1927097#p1927097">archlinux 的 bbs</a>，在 <code>/etc/default/grub</code> 中 <code>GRUB_CMDLINE_LINUX_DEFAULT</code> 条目加入 <code>pci=nocrs</code>，之后执行<code>sudo grub-mkconfig -o /boot/grub/grub.cfg</code>（根据自己 grub 安装情况调整，这里我在 <code>/etc/default/grub</code> 里加入了 <code>GRUB_DISABLE_OS_PROBER=false</code> 来检测到 Windows），重启，触摸板可以用了，并且执行 <code>sudo dmesg | grep i2c</code> 可以看到这样的输出：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[    <span class="hljs-number">3.028457</span>] input: ELAN0413:<span class="hljs-number">00</span> <span class="hljs-number">04</span>F3:<span class="hljs-number">3161</span> Mouse as <span class="hljs-regexp">/devices/</span>pci0000:<span class="hljs-number">00</span><span class="hljs-regexp">/0000:00:15.0/i</span>2c_designware.<span class="hljs-number">0</span><span class="hljs-regexp">/i2c-0/i</span>2c-ELAN0413:<span class="hljs-number">00</span><span class="hljs-regexp">/0018:04F3:3161.0001/i</span>nput/input11<br>[    <span class="hljs-number">3.028517</span>] input: ELAN0413:<span class="hljs-number">00</span> <span class="hljs-number">04</span>F3:<span class="hljs-number">3161</span> Touchpad as <span class="hljs-regexp">/devices/</span>pci0000:<span class="hljs-number">00</span><span class="hljs-regexp">/0000:00:15.0/i</span>2c_designware.<span class="hljs-number">0</span><span class="hljs-regexp">/i2c-0/i</span>2c-ELAN0413:<span class="hljs-number">00</span><span class="hljs-regexp">/0018:04F3:3161.0001/i</span>nput/input13<br>[    <span class="hljs-number">3.028561</span>] hid-generic <span class="hljs-number">0018</span>:<span class="hljs-number">04</span>F3:<span class="hljs-number">3161.0001</span>: input,hidraw0: I2C HID v1.<span class="hljs-number">00</span> Mouse [ELAN0413:<span class="hljs-number">00</span> <span class="hljs-number">04</span>F3:<span class="hljs-number">3161</span>] on i2c-ELAN0413:<span class="hljs-number">00</span><br>[    <span class="hljs-number">3.033612</span>] i2c i2c-<span class="hljs-number">2</span>: <span class="hljs-number">2</span>/<span class="hljs-number">2</span> memory slots populated (<span class="hljs-keyword">from</span> DMI)<br>[    <span class="hljs-number">3.034104</span>] i2c i2c-<span class="hljs-number">2</span>: Successfully instantiated SPD at <span class="hljs-number">0</span>x50<br>[    <span class="hljs-number">3.504030</span>] input: ELAN0413:<span class="hljs-number">00</span> <span class="hljs-number">04</span>F3:<span class="hljs-number">3161</span> Mouse as <span class="hljs-regexp">/devices/</span>pci0000:<span class="hljs-number">00</span><span class="hljs-regexp">/0000:00:15.0/i</span>2c_designware.<span class="hljs-number">0</span><span class="hljs-regexp">/i2c-0/i</span>2c-ELAN0413:<span class="hljs-number">00</span><span class="hljs-regexp">/0018:04F3:3161.0001/i</span>nput/input18<br>[    <span class="hljs-number">3.504075</span>] input: ELAN0413:<span class="hljs-number">00</span> <span class="hljs-number">04</span>F3:<span class="hljs-number">3161</span> Touchpad as <span class="hljs-regexp">/devices/</span>pci0000:<span class="hljs-number">00</span><span class="hljs-regexp">/0000:00:15.0/i</span>2c_designware.<span class="hljs-number">0</span><span class="hljs-regexp">/i2c-0/i</span>2c-ELAN0413:<span class="hljs-number">00</span><span class="hljs-regexp">/0018:04F3:3161.0001/i</span>nput/input20<br>[    <span class="hljs-number">3.504118</span>] hid-multitouch <span class="hljs-number">0018</span>:<span class="hljs-number">04</span>F3:<span class="hljs-number">3161.0001</span>: input,hidraw0: I2C HID v1.<span class="hljs-number">00</span> Mouse [ELAN0413:<span class="hljs-number">00</span> <span class="hljs-number">04</span>F3:<span class="hljs-number">3161</span>] on i2c-ELAN0413:<span class="hljs-number">00</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>龟兔赛跑算法</title>
    <link href="/2021/09/19/algo-tortoiseandhare/"/>
    <url>/2021/09/19/algo-tortoiseandhare/</url>
    
    <content type="html"><![CDATA[<h1 id="龟兔赛跑算法"><a href="#龟兔赛跑算法" class="headerlink" title="龟兔赛跑算法"></a>龟兔赛跑算法</h1><h2 id="Part-1-背景"><a href="#Part-1-背景" class="headerlink" title="Part 1 背景"></a>Part 1 背景</h2><p>问题来自<a href="https://leetcode-cn.com/problems/linked-list-cycle/">力扣</a>：判断链表中是否有环？</p><h2 id="Part-2-实现"><a href="#Part-2-实现" class="headerlink" title="Part 2 实现"></a>Part 2 实现</h2><p>准备两个指针，遍历时一个指针前进一次，另一个前进两次，如果两指针相遇或赶超，说明存在环。好比两人在操场上跑步，速度一快一慢，当时间足够时，总会“套圈”。</p><p>时间复杂度：O(N)，N 为链表节点数。</p><p>空间复杂度：O(1)。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python3 整除的浅思</title>
    <link href="/2021/09/10/python-exact-division/"/>
    <url>/2021/09/10/python-exact-division/</url>
    
    <content type="html"><![CDATA[<h1 id="Python3-整除的浅思"><a href="#Python3-整除的浅思" class="headerlink" title="Python3 整除的浅思"></a>Python3 整除的浅思</h1><p>Python 3 中，采用 <code>//</code> 来实现整除，两个整型变量整除后得到的变量依然是整型。而采用普通的除号 <code>/</code> 得到的却是浮点型。</p><p>Python 3 中，整型支持可以做到硬件允许范围内的大，但浮点型没有这样的实现机制。为了保留相对完整的大整数运算能力支持，需要整除的存在来避开对浮点的依赖。</p><p>那么，为什么两个整型采用除号运算，得到的却是浮点型？</p><p>可以参考：<a href="https://www.zhihu.com/question/473479381/answer/2015056944">pansz的回答</a>。</p>]]></content>
    
    
    <categories>
      
      <category>计算机杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>神船 TX6 BIOS 开关独显</title>
    <link href="/2021/08/10/bios-gpu-switch/"/>
    <url>/2021/08/10/bios-gpu-switch/</url>
    
    <content type="html"><![CDATA[<h1 id="神船-TX6-BIOS-开关独显"><a href="#神船-TX6-BIOS-开关独显" class="headerlink" title="神船 TX6 BIOS 开关独显"></a>神船 TX6 BIOS 开关独显</h1><h2 id="Part-1-背景"><a href="#Part-1-背景" class="headerlink" title="Part 1 背景"></a>Part 1 背景</h2><p>神船 TX6-CU5DA/S （蓝天 NK60SB 模具那一代）采用了桌面端 Intel Core i5-10400 CPU（主板采用 H470 芯片组），搭载 NVIDIA GeForce GTX1650 独立显卡，采用双风扇四铜管三出风口散热，且有两个 M.2 2280 的 SSD 接口、1 个 2.5 吋 7mm 硬盘位 ，内存可插拔，使用 16.1 吋 72% NTSC 屏幕，47Whr 的外置电池，150W 适配器。购买之初，笔者没认清自己对于续航的需求，或者对游戏本的续航表现抱有幻想，后来遇到无法充电的场景时屡屡尴尬（续航大约3h？）。</p><p>经过大量实践，调节蓝天 Control Center，改变电源模式，<a href="https://www.bilibili.com/read/cv10682637/">设备管理器禁用独显</a> 均无法彻底扭转这续航。联系逛笔吧的经验，笔者不禁想问，能不能在 BIOS 里禁用独显呢？这样做的效果又怎样呢？如果你也有同样的疑问，不妨往下看。</p><h2 id="Part-2-步骤"><a href="#Part-2-步骤" class="headerlink" title="Part 2 步骤"></a>Part 2 步骤</h2><p>参考<a href="https://bbs.letitfly.me/d/1151">神船 NK60SB (NKx0Sx) Insyde BIOS 折腾记</a> ，将 <code>IGD or MSHybird or DISCRETE Switch</code> 改为 <code>IGD</code> 即可。（改回来的时候别错改成 <code>DISCRETE</code>，可以参考原作者的帖子，这机器好像只能混合输出，没法独显直连）</p><p>如果链接失效，可以看<a href="https://zhaozihanzzh.github.io/images/website_biosgpu_20210810.jpeg">截图</a>。</p><h2 id="Part-3-总结"><a href="#Part-3-总结" class="headerlink" title="Part 3 总结"></a>Part 3 总结</h2><p>屏蔽独显后，续航改善明显。在某次 30 分钟使用后，电量从 80% 下降至 69%。看看这颗 TDP 65W （单烤也能到这个值）的桌面级 CPU，16.1 吋的屏幕，以及 47Whr 的电池，笔者感觉这样的续航还是可以接受的。</p><p>在过去的 2020 年，想要找一台 Intel CPU 性能释放足够强，屏幕大，价格低的机器，低价位选择并不多。这台机器能否成为披着游戏本外衣的程序员本呢？</p><p>也许，每个人都有自己的答案。</p><p>在笔者看来，这台机器有以下一些特点：</p><ul><li>性能释放强，单烤（Stress FPU）CPU 70+W。</li><li>扩展性较好，三硬盘位。</li><li>16.1吋，屏幕大。</li><li>全高方向键。</li><li>Linux 支持不算烂。</li><li>神船原装群联主控 OEM 固态是减分项，<a href="https://tieba.baidu.com/p/7442648091?pn=3">据传</a>（76楼） 2020 年年底到 2021 年年初有一批固态掉盘较为严重。</li><li>不支持 PD 充电。</li><li>Intel(R) Wireless-AC 9462 无线网卡，不支持 WiFi-6。</li></ul><p>关于电池，同样三硬盘位的机器，宏碁暗影骑士·擎（15.6吋）电池为 57Whr，神舟 TX8-CU5DA（16.1吋）为62Whr，神舟 TX9-CA5DP （16.1吋）电池为 55Whr，TX8-笔者感觉 TX6 这个电池还能再大一点，获得更好续航表现。</p><p>曾经，在蓝天模具的加持下，“神船大法保平安”广为流传，但最近的笔记本市场风云激荡，笔者愚见，神船更应该继续加油才能乘风破浪，驶向深蓝。</p>]]></content>
    
    
    <categories>
      
      <category>娱乐</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>概率论</title>
    <link href="/2021/06/07/probability-theory/"/>
    <url>/2021/06/07/probability-theory/</url>
    
    <content type="html"><![CDATA[<h2 id="一、随机事件与概率"><a href="#一、随机事件与概率" class="headerlink" title="一、随机事件与概率"></a>一、随机事件与概率</h2><h3 id="1-随机现象与随机试验"><a href="#1-随机现象与随机试验" class="headerlink" title="1.随机现象与随机试验"></a>1.随机现象与随机试验</h3><p>基本事件：每一个可能出现的实验结果，用 <script type="math/tex">w_i</script> 表示。必然事件常用 <script type="math/tex">\Omega</script> 表示，不可能事件常用 <script type="math/tex">\emptyset</script> 表示。</p><p>事件的运算：和 <script type="math/tex">A\bigcup{B}</script> ，差 <script type="math/tex">A-B</script> 或 A\B ，交（积） <script type="math/tex">A\bigcap{B}</script> 或 <script type="math/tex">AB</script> 。</p><p>互不相同事件：不同时发生；对立事件：“事件A不发生”这一事件。</p><h3 id="2-概率的定义"><a href="#2-概率的定义" class="headerlink" title="2.概率的定义"></a>2.概率的定义</h3><p>古典概型（<script type="math/tex">\Omega</script> 是有限集）：<script type="math/tex">P(A)=\frac{n_A}{n}</script>，几何概型：<script type="math/tex">P(A)=\frac{G 的几何度量}{\Omega 的几何度量}</script>。</p><p>概率的公理化定义：基本事件空间 <script type="math/tex">\Omega</script> 是所有基本事件构成的集合，事件域为 <script type="math/tex">F</script> （已有的事件怎么操作都跑不出去），概率测度 <script type="math/tex">P</script> ，则 <script type="math/tex">(\Omega, F, P)</script> 为概率空间。</p><p>如果 <script type="math/tex">P(A) = 0</script> ，A 未必是不可能事件。</p><p>概率加法公式：<script type="math/tex">P(\bigcup\limits_{i=1}^{n}A_i)=\sum\limits_{i=1}^{n}P(A_i)-\sum\limits_{1\leq{i}<j\leq{n}}^{n}P(A_{i}A_{j})+\sum\limits_{1\leq{i}<j<k\leq{n}}^{n}P(A_{i}A_{j}A_{k})-\cdots+(-1)^{n-1}P(A_{1}A_{2}\cdots A_{n})</script></p><h3 id="3-条件概率"><a href="#3-条件概率" class="headerlink" title="3.条件概率"></a>3.条件概率</h3><p>条件概率：已知某事件发生，另一事件发生（可用来构造概率空间）</p><p>乘法公式：<script type="math/tex">P(B|A)=\frac{P(AB)}{P(A)}</script>，推广：<script type="math/tex">P(A_1A_2\cdots A_n)=P(A_1)P(A_2|A_1)P(A_3|(A_1A_2))\cdots P(A_n|(A_1A_2\cdots A_n))</script></p><p>全概率公式：先化整为零，再聚零为整：<script type="math/tex">B_i</script> 为 <script type="math/tex">B</script> 的一个划分，则当 <script type="math/tex">A\subset B</script> ，<script type="math/tex">B_i</script> 是 <script type="math/tex">B</script> 的一个划分，此时有 <script type="math/tex">P(A) = \sum\limits_{i=1}^{n}P(B_i)P(A|B_i)</script> 。(6 个黑球，4 个白球，第二次摸到的是白球的概率？)</p><p>贝叶斯公式：若 <script type="math/tex">P(B_i)>0</script> ，<script type="math/tex">B_iB_j = \emptyset</script>，<script type="math/tex">A\subset{\bigcup\limits_{i=1}^{\infty}B_i}</script> ，<script type="math/tex">P(A)>0</script> ，则 <script type="math/tex">P(B_j|A) = \frac{P(B_j)P(A|B_j)}{\sum\limits_{i=1}^{\infty}P(B_i)P(A|B_i)}</script>。（甲乙丙三车间产量占比已知，次品率已知，现在查出一个次品，是甲车间生产的概率？）</p><h3 id="4-事件独立性"><a href="#4-事件独立性" class="headerlink" title="4.事件独立性"></a>4.事件独立性</h3><p>若 <script type="math/tex">P(AB) = P(A)P(B)</script>，则 A、B 相互独立。</p><p>三个事件相互独立（<script type="math/tex">P(AB) = P(A)P(B)</script>，<script type="math/tex">P(BC) = P(B)P(C)</script>，<script type="math/tex">P(AC) = P(A)P(C)</script>，<script type="math/tex">P(ABC) = P(A)P(B)P(C)</script>）强于两两独立。</p><h3 id="5-独立实验"><a href="#5-独立实验" class="headerlink" title="5.独立实验"></a>5.独立实验</h3><p>n 重伯努利试验：试验只有两种可能结果，重复 n 次。</p><p>伯努利定理：成功概率 p 时成功 k 次概率 <script type="math/tex">b(k;n,p)=C^{k}_{n}p^{k}(1-p)^{n-k}</script> ，称为伯努利数。</p><h2 id="二、一维随机变量及其分布"><a href="#二、一维随机变量及其分布" class="headerlink" title="二、一维随机变量及其分布"></a>二、一维随机变量及其分布</h2><h3 id="1-随机变量"><a href="#1-随机变量" class="headerlink" title="1.随机变量"></a>1.随机变量</h3><p>对实数集上的任意 x ，有 <script type="math/tex">\{\omega|X(\omega)\leq{x}\}\in{F}</script> ，称 <script type="math/tex">X(\omega)</script> 为随机变量。（这个事件必须在事件域 F 中）</p><p>随机变量 X 的分布函数 <script type="math/tex">F_x(x)=P(X\leq{x})</script> ，则 <script type="math/tex">P(X<{x})=F_x(x-0)</script> （左极限），分布函数右连续，但不一定左连续，<script type="math/tex">P(X={x})=F_x(x)-F_x(x-0)</script> ，<script type="math/tex">F_x(x)</script> 为单调递增函数，且在负无穷、正无穷取值分别为 0、1。</p><h3 id="2-一维离散型随机变量"><a href="#2-一维离散型随机变量" class="headerlink" title="2.一维离散型随机变量"></a>2.一维离散型随机变量</h3><p>离散型随机变量的取值为有限个或可列多个。为了直观，可以使用表格列出分布列。接下来介绍几种概率分布：</p><p>a.两点分布（0-1分布）：</p><div class="table-container"><table><thead><tr><th>X</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>P</td><td>1-p</td><td>p</td></tr></tbody></table></div><p>b.二项分布 <script type="math/tex">X\sim{B(n, p)}</script></p><p>n 重伯努利试验，成功概率 p，随机变量 X 为成功次数</p><p>记 <script type="math/tex">k_0=Int[(n+1)p]</script>，当 <script type="math/tex">k=k_0</script> 时 <script type="math/tex">b(k;n,p)</script> 最大；若 (n+1)p 为整数，则 <script type="math/tex">b(k_0;n,p)=b(k_0-1;n,p)</script> 。</p><p>c.泊松分布 <script type="math/tex">X\sim{P(\lambda)}</script>，参数 <script type="math/tex">\lambda>0</script></p><p>$P(X=k)=\frac{e^{-\lambda}\lambda^k}{k!}$ ，其中又有泊松定理：<script type="math/tex">X_n\sim{B(n,p_n)}</script>，其中 <script type="math/tex">p_n</script> 与 <script type="math/tex">n</script> 有关，且 <script type="math/tex">\lim\limits_{n\rightarrow\infty}np_n=\lambda>0</script> ，此时有 <script type="math/tex">\lim\limits_{n\rightarrow\infty}P(x_n=k)=\frac{e^{-\lambda}\lambda^k}{k!}</script> ，k 取自然数，表示的意义为：把一段时间分割为 <script type="math/tex">n</script> 段，每段时间内某事件发生的概率为 <script type="math/tex">p_n</script> （由于每段时间很小，认为事件不会在这样短的时间内发生两次及以上），由二项分布，乘积 <script type="math/tex">\lambda</script> 为这段时间事件发生次数的期望，当把每段时间无限地分割下去时，二项分布实际上就成了泊松分布。因此，还有泊松近似公式：</p><p>当二项分布 n 很大，p 很小（一般取 <script type="math/tex">n\geq{10}</script>，<script type="math/tex">p\leq{0.1}</script> ）时，<script type="math/tex">P(X=k)\approx{\frac{e^{-\lambda}\lambda^k}{k!}}</script>。</p><p>d.几何分布 $X\sim{Geo(p)}$</p><p>$P(X=k)=g^{k-1}p=g(k;p)$ 表示前 (k - 1) 次试验未成功，第 k 次首次成功。</p><p>几何分布有无记忆性，已知前 k 次还未成功，则从 (k + 1) 次，首次成功出现在哪一次与 k 无关，即 <script type="math/tex">P(X=k+n|X>k)=P(x=n)</script>。（彼此独立）</p><h3 id="3-一维连续型随机变量"><a href="#3-一维连续型随机变量" class="headerlink" title="3.一维连续型随机变量"></a>3.一维连续型随机变量</h3><p>若存在 <script type="math/tex">f(x)>0</script> 使得对任意 x 有 <script type="math/tex">F(x)=\int_{-\infty}^{x}f(t)dt</script>，那么 <script type="math/tex">f(x)</script> 为 x 的概率密度函数（在不至于混淆时简称密度函数）。显然，在某点上概率分布函数一定是 0，因此我们需要讨论随机变量落在某区间上的概率，为了便于描述概率分布函数与 x 轴围成图形的面积，引入密度函数。易知，<script type="math/tex">\int_{-\infty}^{+\infty}f(x)dx=1</script> 。同样地，介绍几种概率分布：</p><p>a.均匀分布 <script type="math/tex">x\sim{U[a,b]}</script></p><p>a&lt;b，<script type="math/tex">f(x)=\left\{\begin{matrix}\frac{1}{b-a},x\in[a,b]\\0,x\notin[a,b]\end{matrix}\right.</script></p><p>显然，当 <script type="math/tex">a\leq{x}\leq{b}</script> 时 <script type="math/tex">F(x)=\frac{x-a}{b-a}</script>。（“线性”）</p><p>b.指数分布 <script type="math/tex">X\sim{E(X)}</script></p><p> x 的密度函数满足 <script type="math/tex">f(x)=\left\{\begin{matrix}\lambda{e}^{-\lambda{x}},x>0\\0,x\leq0\end{matrix}\right.</script> ，分布函数 <script type="math/tex">F(x)=\left\{\begin{matrix}1-e^{-\lambda{x}}, x>0\\0, x\leq{0}\end{matrix}\right.</script></p><p>指数分布也与泊松分布关系密切，后者表示的是某事件在一定时间中的发生次数的概率分布，而前者是某事件两次发生之间时间间隔的概率分布：设某段时间长为 x，在这段时间内某事件发生次数为 <script type="math/tex">\lambda{x}</script>，那么在这段时间中一次也不发生概率为 <script type="math/tex">\frac{e^{-\lambda{x}}(\lambda{x})^0}{0!}=e^{-\lambda{x}}</script>，那么在这段时间内发生一次及以上该事件的概率为 <script type="math/tex">1-e^{-\lambda{x}}</script>，即：时间间隔小于这个 x 的概率为 <script type="math/tex">1-e^{-\lambda{x}}</script>，这就是指数分布在时间间隔大于 0 时的分布函数。</p><p>指数分布具有“无记忆性”，即 <script type="math/tex">P(X>k+n|X>k)=P(X>n)</script>。</p><p>c.正态分布 <script type="math/tex">X\sim{N}(\mu, \sigma^2)</script></p><p>$f(x)=\frac{1}{\sqrt{2\pi}\sigma}e^-\frac{(x-\mu)^2}{2\sigma^2}$，分布函数为其积分。又有标准正态分布 <script type="math/tex">\mu=0,\sigma=1</script>，记其密度函数为 <script type="math/tex">\varphi(x)</script>，分布函数为 <script type="math/tex">\Phi(x)</script>，查表时要注意 <script type="math/tex">\Phi(x)-\frac{1}{2}=\frac{1}{2}-\Phi(-x)</script>，即概率分布关于 <script type="math/tex">\frac{1}{2}</script> 对称。</p><p>正态分布标准化：对于 <script type="math/tex">X\sim{N(\mu, \sigma^2)}</script>，有 <script type="math/tex">\frac{x-\mu}{\sigma}\sim{N(0,1)}</script>。</p><h3 id="4-一维离散型随机变量函数的分布"><a href="#4-一维离散型随机变量函数的分布" class="headerlink" title="4.一维离散型随机变量函数的分布"></a>4.一维离散型随机变量函数的分布</h3><p>X 经某函数映射到 Y，那么求 Y 取某个值的概率时需要合并使 Y 取这个值的所有 X 的概率。</p><h3 id="5-一维连续型随机变量函数的分布"><a href="#5-一维连续型随机变量函数的分布" class="headerlink" title="5.一维连续型随机变量函数的分布"></a>5.一维连续型随机变量函数的分布</h3><p>需要利用分布函数和 Y 与 X 的关系，将 Y 小于等于某值的概率解不等式转为 X 取某区间的概率，之后如果需要求密度函数，直接对所得的分布函数求导即可，需要注意若 <script type="math/tex">F_Y(y)=\int_{h_2(y)}^{h_1(y)}g(x)dx</script>，那么 <script type="math/tex">F_Y'(y)=g(h_1(y))h_1'(y)-g(h_2(y))h_2'(y)</script>，<script type="math/tex">\pm\infty</script> 导数看做 0。</p><h2 id="三、二维随机向量及其分布"><a href="#三、二维随机向量及其分布" class="headerlink" title="三、二维随机向量及其分布"></a>三、二维随机向量及其分布</h2><p>我们只讨论二维随机向量。</p><h3 id="1-随机向量联合分布函数与联合密度函数（连续型）"><a href="#1-随机向量联合分布函数与联合密度函数（连续型）" class="headerlink" title="1.随机向量联合分布函数与联合密度函数（连续型）"></a>1.随机向量联合分布函数与联合密度函数（连续型）</h3><p>随机向量联合分布函数 <script type="math/tex">F_{X_1,X_2}(x_1, x_2)=P(X_1\leq{x_1},X_2\leq{x_2})</script>，有 <script type="math/tex">F(-\infty, y)=F(x,-\infty)=F(-\infty, -\infty)=0</script>。</p><p>若 <script type="math/tex">(X,Y)</script> 所有取值只有有限个或可列个，其为离散型随机变量；若存在 <script type="math/tex">f(x,y)</script> 使得对任意 x, y，有 <script type="math/tex">F_{X,Y}(x,y)=\int_{-\infty}^{y}\int_{-\infty}^{x}f(u,v)dudv</script>，那么 <script type="math/tex">(X,Y)</script> 为连续型随机变量，称 <script type="math/tex">f(x,y)</script> 为它的联合概率密度函数（或者直接称为分布密度函数）。</p><h3 id="2-随机向量边缘分布函数与边缘密度函数（连续型）"><a href="#2-随机向量边缘分布函数与边缘密度函数（连续型）" class="headerlink" title="2.随机向量边缘分布函数与边缘密度函数（连续型）"></a>2.随机向量边缘分布函数与边缘密度函数（连续型）</h3><p>二维随机向量边缘分布为其中某个随机变量取某个值的概率（相当于在表格“边缘”的那一栏），对于离散型二维随机向量，有<script type="math/tex">P(Y=y_j)=\sum\limits_ip_{ij}</script>；对于连续型二维随机变量，其边缘分布函数为 <script type="math/tex">F_X(x)=F(x, +\infty)=\lim\limits_{y\rightarrow+\infty}F(x,y)</script>，其边缘密度函数为 <script type="math/tex">f_X(x)=\int_{-\infty}^{+\infty}f_{X,Y}(x,y)dy</script> 。（由联合分布确定其边缘分布，但反之不一定，要考虑其独立性）</p><h3 id="3-随机变量的相互独立性"><a href="#3-随机变量的相互独立性" class="headerlink" title="3.随机变量的相互独立性"></a>3.随机变量的相互独立性</h3><p>若可判断 X、Y 取值互不影响，或对任意 x, y ，有 <script type="math/tex">F(x,y)=F(x)F(y)</script>，或离散型有 <script type="math/tex">p_{ij}=p_{i\cdot}p_{\cdot{j}}</script>，或连续型有 <script type="math/tex">f(x,y)=f_X(x)f_Y(y)</script>，那么 X、Y 相互独立。此时边缘分布可确定联合分布。</p><h3 id="4-二维均匀分布"><a href="#4-二维均匀分布" class="headerlink" title="4.二维均匀分布"></a>4.二维均匀分布</h3><p>有界区域 D 的面积为 <script type="math/tex">S_D</script>，<script type="math/tex">f(x,y)=\left\{\begin{matrix}\frac{1}{S_D},(x,y)\in{D}\\0,(x,y)\notin{D}\end{matrix}\right.</script>。可以用画图辅助。</p><h3 id="5-二维正态分布"><a href="#5-二维正态分布" class="headerlink" title="5.二维正态分布"></a>5.二维正态分布</h3><p>$(X,Y)\sim{N(\mu_1,\mu_2,\sigma^2_1,\sigma^2_2,\rho)}$，其边缘分布是一维正态分布，<script type="math/tex">\rho</script> 为两变量的相关系数。（“物以类聚”，$\mu$ 在一起，$\sigma$ 在一起）</p><h3 id="6-二维随机向量函数的概率分布函数（离散型）与概率密度函数（连续型）"><a href="#6-二维随机向量函数的概率分布函数（离散型）与概率密度函数（连续型）" class="headerlink" title="6.二维随机向量函数的概率分布函数（离散型）与概率密度函数（连续型）"></a>6.二维随机向量函数的概率分布函数（离散型）与概率密度函数（连续型）</h3><p>$Z=g(x,y)$ 为一个二元函数，研究其分布：</p><p>离散型与一维类似，其概率分布函数直接将每个可能的 <script type="math/tex">(X,Y)</script> 概率累加。</p><p>对于连续型，有 <script type="math/tex">F_Z(z)=P(g(X,Y)\leq{Z})=\iint\limits_{g(x,y)\leq{z}}f(x,y)dxdy</script>，但我们在这里只讨论随机向量函数为两随机变量之和的情况：令 <script type="math/tex">y=u-x</script>，则上式可写成 <script type="math/tex">\iint\limits_{x+y\leq{z}}f(x,y)dxdy=\int_{-\infty}^{+\infty}\int_{-\infty}^{z-x}f(x,y)dydx=\int_{-\infty}^{+\infty}\int_{-\infty}^{z}f(x,u-x)dudx=\int_{-\infty}^{z}\int_{-\infty}^{+\infty}f(x,u-x)dxdu</script>，求导得 <script type="math/tex">f_Z(z)=\int_{-\infty}^{+\infty}f(x, z-x)dx</script>。同理，<script type="math/tex">f_Z(z)=\int_{-\infty}^{+\infty}f(z-y, y)dy</script>。</p><p>特别地，当 x、y相互独立时，上式变为卷积公式 <script type="math/tex">f_Z(z)=\int_{-\infty}^{+\infty}f_X(x)f_Y(z-x)dx=f_Z(z)=\int_{-\infty}^{+\infty}f_X(z-y)f_Y(y)dy</script></p><p>事实上，X、Y 相互独立时， <script type="math/tex">X\sim P(\lambda_1)</script>，<script type="math/tex">Y\sim P(\lambda_2)</script>，则 <script type="math/tex">X+Y\sim P(\lambda_1+\lambda_2)</script>；<script type="math/tex">X\sim B(m,p)</script>，<script type="math/tex">Y\sim B(n,p)</script>，则 <script type="math/tex">X+Y\sim B(m+n,p)</script>；<script type="math/tex">X\sim{N}(\mu_1, \sigma^2_1)</script>，<script type="math/tex">Y\sim{N}(\mu_2, \sigma^2_2)</script>，则 <script type="math/tex">X+Y\sim{N}(\mu_1+\mu_2, \sigma^2_1+\sigma^2_2)</script>。更进一步地，有限个独立的正态分布的随机变量线性组合仍然是正态分布。</p><h2 id="四、随机变量的数字特征"><a href="#四、随机变量的数字特征" class="headerlink" title="四、随机变量的数字特征"></a>四、随机变量的数字特征</h2><h3 id="1-数学期望"><a href="#1-数学期望" class="headerlink" title="1.数学期望"></a>1.数学期望</h3><p>a.一维随机变量数学期望的计算</p><p>对于离散型，当级数 <script type="math/tex">\sum\limits_{i=1}^{\infty}|x_i|p_i</script> 收敛，则 X 期望存在，<script type="math/tex">E(X)=\sum\limits_{i=1}^{\infty}x_ip_i</script>。</p><p>对于连续型，当 <script type="math/tex">\int_{-\infty}^{+\infty}|x|f(x)dx</script> 收敛时，有期望 <script type="math/tex">E(X)=\int_{-\infty}^{+\infty}xf(x)dx</script> 。发散则不存在，如柯西分布、圣彼得堡悖论。</p><p>二项分布：<script type="math/tex">E(X)=np</script>；泊松分布：<script type="math/tex">E(X)=\lambda</script>；几何分布 <script type="math/tex">E(X)=\frac{1}{p}</script>；均匀分布为中点；正态分布 <script type="math/tex">E(X)=\mu</script> ；指数分布 <script type="math/tex">E(X)=\frac{1}{\lambda}</script> 。</p><p>b.一维随机变量函数的数学期望</p><p>离散型，<script type="math/tex">E(g(X))=\sum\limits_{k}g(x_k)P(X=x_k)</script> （要求 <script type="math/tex">\sum\limits_{k}|g(x_k)|P(X=x_k)<+\infty</script>）</p><p>连续型：<script type="math/tex">\int_{-\infty}^{+\infty}|g(x)|f(x)dx</script> 收敛时，有期望 <script type="math/tex">E(g(x))=\int_{-\infty}^{+\infty}g(x)f(x)dx</script> 。</p><p>c.二维随机变量函数的数学期望</p><p>离散型：与一维类似，将取值与对应的概率乘积求和</p><p>连续型：若<script type="math/tex">\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}g(x,y)f(x,y)dydx</script> 绝对收敛，则期望存在。</p><p>特别地，<script type="math/tex">E(X)=\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}xf(x,y)dydx=\int_{-\infty}^{+\infty}x[\int_{-\infty}^{+\infty}f(x,y)dy]dx=\int_{-\infty}^{+\infty}xf_X(x)dx</script></p><p>d.数学期望的部分性质</p><p>如果 <script type="math/tex">\xi</script> 与 <script type="math/tex">\eta</script> 相互独立，<script type="math/tex">E(\xi\eta)=E(\xi)E(\eta)</script>；但反之不一定。</p><h3 id="2-随机变量的矩"><a href="#2-随机变量的矩" class="headerlink" title="2.随机变量的矩"></a>2.随机变量的矩</h3><p>a.相关定义</p><p>记 <script type="math/tex">E[(X-c)^k]</script> 为 X 关于 c 的 k 阶矩，当 c = 0 时为 k 阶原点矩 <script type="math/tex">a_k</script>，<script type="math/tex">c=E(X)</script> 时为 k 阶中心矩 <script type="math/tex">\mu_k</script>。（$\mu$ 有些像以中心为轴左右对称）</p><p>记 <script type="math/tex">\mu_2</script> 为方差。（X 必须有有限的期望）</p><p>$\frac{\mu_3}{\mu^{\frac{3}{2}}_2}$ 为偏度系数，正态分布偏度系数为 0，绝对值越大，离正态分布偏差越大，大于 0 说明右偏。</p><p>$\frac{\mu_4}{\mu^{2}_2}$ 为峰度系数，正态分布为 3。（“偏锋”，从 3 到 4）</p><p>b.随机变量的方差的计算</p><p>$Var(X)=E(X^2)-[E(X)]^2$ （“由内而外”）</p><script type="math/tex; mode=display">Var(cX)=c^2Var(X)</script><p>对于二项分布，其方差有 <script type="math/tex">Var(X)=np(1-p)=npq</script>；泊松分布方差 <script type="math/tex">Var(X)=\lambda</script>；几何分布方差 <script type="math/tex">Var(X)=\frac{q}{p^2}</script>；均匀分布方差 <script type="math/tex">Var(X)=\frac{(b-a)^2}{12}</script>；正态分布方差 <script type="math/tex">Var(X)=\sigma^2</script>；指数分布方差 <script type="math/tex">Var(X)=\frac{1}{\lambda^2}</script> 。</p><h3 id="3-二维随机向量的协方差"><a href="#3-二维随机向量的协方差" class="headerlink" title="3.二维随机向量的协方差"></a>3.二维随机向量的协方差</h3><p>定义 <script type="math/tex">Cov(X,Y)=E\{[X-E(X)][Y-E(Y)]\}</script>，则有 <script type="math/tex">Var(X)=Cov(X,X)</script>，<script type="math/tex">Cov(aX+bY,Z)=aCov(X,Z)+bCov(Y,Z)</script>；若 X、Y 独立，那么其协方差为 0，但反之不一定。</p><script type="math/tex; mode=display">Var(X+Y)=Var(X)+Var(Y)+2Cov(X,Y)</script><p>注意 $Cov(X,-Y)=-Cov(X,Y)$，有 $Var(X-Y)=Var(X)+Var(Y)-2Cov(X,Y)$。</p><h3 id="4-相关系数"><a href="#4-相关系数" class="headerlink" title="4.相关系数"></a>4.相关系数</h3><p>当 <script type="math/tex">Var(X)>0</script>，<script type="math/tex">Var(Y)>0</script> 时，定义相关系数 <script type="math/tex">r(X,Y)=\frac{Cov(X,Y)}{\sqrt{Var(X)Var(Y)}}</script> （也可用 <script type="math/tex">\rho</script>），其绝对值总是小于等于 1。当 <script type="math/tex">\rho=0</script> 时，两变量无线性关系；当 <script type="math/tex">\rho=1</script> 时严格正相关，当 <script type="math/tex">\rho=-1</script> 时严格负相关。</p><p>由协方差的性质，当 X、Y 独立时，其相关系数等于 0，但反之不一定成立。也就是说，X、Y 独立，则两者一定不相关，但反之不一定。不过，<script type="math/tex">(X,Y)</script> 服从二维正态分布时，反之也成立。</p><h6 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h6><p><a href="https://zhuanlan.zhihu.com/p/261961315">https://zhuanlan.zhihu.com/p/261961315</a></p><p><a href="https://www.jianshu.com/p/6ee90ba47b4a">https://www.jianshu.com/p/6ee90ba47b4a</a></p><p><a href="https://www.zhihu.com/question/26441147/answer/429569625">https://www.zhihu.com/question/26441147/answer/429569625</a></p><p><a href="https://zhuanlan.zhihu.com/p/36555178">https://zhuanlan.zhihu.com/p/36555178</a></p>]]></content>
    
    
    <categories>
      
      <category>概率论与数理统计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ 类的成员函数访问该类的私有数据成员</title>
    <link href="/2021/05/21/cpp-private/"/>
    <url>/2021/05/21/cpp-private/</url>
    
    <content type="html"><![CDATA[<h1 id="C-类的成员函数访问该类的私有数据成员"><a href="#C-类的成员函数访问该类的私有数据成员" class="headerlink" title="C++ 类的成员函数访问该类的私有数据成员"></a>C++ 类的成员函数访问该类的私有数据成员</h1><p>知乎有<a href="https://www.zhihu.com/question/51218892">同款问题</a>。</p><p>类的成员函数访问该类的私有数据成员时，不因为该私有数据成员不是 this 指针指向的对象持有的而禁止访问。这种控制是基于类的，而不是对象层面的。</p><p>这样的代码将是可以编译的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Object</span> &#123;</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Object</span>(<span class="hljs-keyword">int</span> arg):<span class="hljs-built_in">num</span>(arg) &#123;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_priv</span><span class="hljs-params">(Object)</span></span>;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-keyword">int</span> num;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Object::get_priv</span><span class="hljs-params">(Object arg)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> arg.num;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多元函数积分学</title>
    <link href="/2021/05/01/multivarintegral/"/>
    <url>/2021/05/01/multivarintegral/</url>
    
    <content type="html"><![CDATA[<h1 id="多元函数积分学"><a href="#多元函数积分学" class="headerlink" title="多元函数积分学"></a>多元函数积分学</h1><h2 id="零、定积分"><a href="#零、定积分" class="headerlink" title="零、定积分"></a>零、定积分</h2><p>个人的总结先从定积分开始：定积分形如 <script type="math/tex">\int_{a}^{b}f(x)dx</script> ，积分域是一条线段，被积函数 <script type="math/tex">f(x)</script> 是要沿着这条线段（积分域中微小的量）积累的量的函数。如：所谓“曲边梯形的面积”问题中，可以把竖直方向上的长度看成是要被积累的量，沿着线段（x 轴）积累所得。</p><p>计算方法：牛顿-莱布尼茨公式。</p><h2 id="一、二重积分"><a href="#一、二重积分" class="headerlink" title="一、二重积分"></a>一、二重积分</h2><p>对于被积函数是二元函数的情况，使用二重积分来将微小量（小区域）上的被积函数值积累起来。二重积分形如<script type="math/tex">\iint\limits_{D}f(x, y)d\sigma</script>，一般在 <script type="math/tex">xOy</script> 平面内，由于是二重积分，书写成两个积分号。这里所有积分得出的都是一个数值，不是向量值。</p><p>计算方法：看成 <script type="math/tex">x-</script> 型区域或 <script type="math/tex">y-</script> 型区域；换元积分；利用极坐标。需要注意的是，由于 <script type="math/tex">d\sigma = dxdy = dx(u, v)dy(u, v)</script> ，换元时要借助雅可比行列式。积分时最好画出被积区域的图像，把“固定”的一个变量书写在左侧的积分号处，把实质上先积分的变量放在右侧，从右往左积分时上下限的字母（积分的“维度”）越来越少，这是因为随着积分从右往左的进行，右侧的积分已经在上下限中包含了左侧上下限不写的字母的边界形状信息。</p><p>如果积分域字母，以 <script type="math/tex">x</script> 为例，具有对称性，当 <script type="math/tex">f(-x, y)=f(x, y)</script> 时，可以把积分域缩减到右侧，将所得的值乘以 2 ；当 <script type="math/tex">f(-x, y)=-f(x, y)</script> 时，关于 <script type="math/tex">y</script> 轴对称的两侧积分域的积分值相抵消。</p><h2 id="二、三重积分"><a href="#二、三重积分" class="headerlink" title="二、三重积分"></a>二、三重积分</h2><p>形如 <script type="math/tex">\iiint\limits_{\Omega}f(x, y, z)dV</script> ，被积函数是三元函数，需要遍历（三维）区域的每个微小的体积量.</p><p>计算方法：直角坐标系：先单后重法（假设高度是用一根顶天花板立地板的竿子测量，把这竿子的高度用位置坐标 x、y 表示出来，再拿着竿子跑遍房间就行）；先重后单法（先积分出房间在高度 z 处的面积，即一层瓷砖覆盖房间的这个高度，再用瓷砖把房间填满）；换元，主要是球面坐标、柱坐标。</p><h2 id="三、第一类曲线积分"><a href="#三、第一类曲线积分" class="headerlink" title="三、第一类曲线积分"></a>三、第一类曲线积分</h2><p>形如 <script type="math/tex">\int_{C}f(x, y, z)ds</script> ，相比定积分，被积函数是个三元函数，也就是空间的一个场，描述了要积累的属性在空间某点的值（定积分也可以看成是三元函数，但由于沿着坐标轴积分，把剩下两个维度忽略了），函数值还是数，但积分域从定积分的线段改成了曲线。</p><p>计算方法：通过换元，把曲线变换成直的，再调用定积分。要注意换元时弧长微分 <script type="math/tex">ds=\sqrt{x'^2(t)+y'^2(t)+z'^2(t)} dt</script> ，无法把 s 分解，也不用再求导。</p><h2 id="四、第二类曲线积分"><a href="#四、第二类曲线积分" class="headerlink" title="四、第二类曲线积分"></a>四、第二类曲线积分</h2><p>第二类曲线积分与第一类曲线积分有较大的差别。第二类曲线积分中被积分的函数是个向量值函数（有方向的场），积分所沿着的曲线也是有向的，沿曲线方向依次取得各点的向量值函数在累加时采用的不是矢量求和，而是与曲线方向的数量积的和，记作 <script type="math/tex">\int_{L}\pmb{f}\cdot{d\pmb{s}}</script> 。</p><p>计算方法：由于被积函数、曲线通常在 <script type="math/tex">xOy</script> 坐标系中表示，可以将被积函数、曲线用 <script type="math/tex">\vec{i}</script>、<script type="math/tex">\vec{j}</script>、<script type="math/tex">\vec{k}</script> 三个分方向表示出来，由于 <script type="math/tex">{d\pmb{s}} = \pmb{e_T}ds = \frac{1}{\sqrt{x'(t)^2+y'(t)^2+z'(t)^2}}\{x'(t), y'(t)\}\cdot{\sqrt{x'(t)^2+y'(t)^2+z'(t)^2}dt} = \{x'(t), y'(t)\}</script> ，可得出对坐标的曲线积分 <script type="math/tex">\int_{L}P(x, y)dx+Q(x, y)dy</script> ，再进行换元即可。</p><h2 id="五、第一类曲面积分"><a href="#五、第一类曲面积分" class="headerlink" title="五、第一类曲面积分"></a>五、第一类曲面积分</h2><p>二重积分是在 <script type="math/tex">xOy</script> 上进行积分的，而第一类曲面积分将积分域提升到了空间中的曲面。第一类曲面积分形如 <script type="math/tex">\iint\limits_{S}f(x, y, z)dS</script> ，被积函数是三元非向量值函数。</p><p>计算方法：把曲面投影（“拍扁”）到一个平面上，如取 <script type="math/tex">xOy</script> 平面承接投影，则需要把 z 用 x 和 y 表示出来以正确表达原平面，即要有 <script type="math/tex">z=f(x, y)</script> ，移项可得 <script type="math/tex">f(x, y) - z = 0</script> ，求导得法向量 <script type="math/tex">\{f_x, f_y, -1\}</script> ，法向量与 z 轴夹角的余弦值 <script type="math/tex">\cos{\gamma}=\frac{1}{\sqrt{f_x^2+f_y^2+1}}</script> ，可得 <script type="math/tex">dS={\sqrt{f_x^2+f_y^2+1}}dxdy</script>，可化为投影到 <script type="math/tex">xOy</script> 平面的二重积分。</p><h2 id="六、第二类曲面积分"><a href="#六、第二类曲面积分" class="headerlink" title="六、第二类曲面积分"></a>六、第二类曲面积分</h2><p>第二类曲面积分与第二类曲线积分有着某种联系，同样是向量值三元函数形成的场，但积分域是有向的空间曲面，其形如 <script type="math/tex">\iint\limits_{S}\vec{f}(x, y, z)d\vec{S}=\iint\limits_{S}(P\cos{\alpha}+Q\cos{\beta}+R\cos{\gamma})dS=\iint\limits_{S}Pdxdy+Qdydz+Rdzdx</script> ，流量可看成流量微元在指定方向曲面上的第二类曲面积分。</p><p>计算方法：虽然与第一类曲面积分同属于曲面积分，但由于被积函数（场）是向量值的，不能仅仅投影到 <script type="math/tex">xOy</script> 等一个平面了事，那样另外两个方向上的分量 <script type="math/tex">Q\vec{j}</script>、<script type="math/tex">R\vec{k}</script> 无法计算。为了正确地处理，需要向 <script type="math/tex">xOy</script>、 <script type="math/tex">yOz</script>、<script type="math/tex">zOx</script>​ 三个平面分别投影，与第一类曲面积分一样，再把另一个变量用投影平面两个变量表达出来，代入被积函数，最后站在平面的上方，（如：<script type="math/tex">zOx</script> 平面站在 y 轴正半轴往下看）如果曲面方向指向被观察者，即为正号，否则是负号，即“一投二代三定向”。</p><h2 id="七、格林公式"><a href="#七、格林公式" class="headerlink" title="七、格林公式"></a>七、格林公式</h2><p><script type="math/tex">\iint\limits_{D}(\frac{\partial{Q}}{\partial{x}}-\frac{\partial{P}}{\partial{y}})dxdy=\oint_{L}{Pdx+Qdy}</script> ，D 是以分段光滑的 L （L取正向）为边界的平面闭区域，且 <script type="math/tex">P(x, y)</script>、<script type="math/tex">Q(x, y)</script> 在 D 上有一阶连续偏导数。</p><p>如果闭区域中间有一点使得 P 或 Q 函数无定义，要挖去。</p><p>取 <script type="math/tex">P=-y</script>，<script type="math/tex">Q=x</script>，可以求出面积。</p><p>格林公式相当于牛顿-莱布尼茨公式，将二重积分与第二类曲线积分联系起来。（在平面上）</p><h2 id="八、保守场与势函数"><a href="#八、保守场与势函数" class="headerlink" title="八、保守场与势函数"></a>八、保守场与势函数</h2><h2 id="九、散度与高斯公式"><a href="#九、散度与高斯公式" class="headerlink" title="九、散度与高斯公式"></a>九、散度与高斯公式</h2><h2 id="十、旋度与斯托克斯公式"><a href="#十、旋度与斯托克斯公式" class="headerlink" title="十、旋度与斯托克斯公式"></a>十、旋度与斯托克斯公式</h2><p>未完待续</p>]]></content>
    
    
    <categories>
      
      <category>工科数学分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ 重载赋值运算符</title>
    <link href="/2021/03/31/assignmentoverride/"/>
    <url>/2021/03/31/assignmentoverride/</url>
    
    <content type="html"><![CDATA[<h1 id="C-重载赋值运算符"><a href="#C-重载赋值运算符" class="headerlink" title="C++ 重载赋值运算符"></a>C++ 重载赋值运算符</h1><p>如果在含有指针数据成员的类中没有重载赋值运算符，赋值时进行浅复制，导致被赋值对象与赋值对象指向同一地址，析构、操作数据成员时会出现不符合期望的结果，因此需要进行深复制。但仅进行深复制仍然是不够完善的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Demo &amp; Demo::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Demo &amp; obj) &#123;<br><span class="hljs-keyword">delete</span> ptr;<br>ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(*obj.ptr);<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码首先释放 Demo 类中的 ptr 指针，但在遇到 <code>assigned = assigned;</code> 这种自赋值情况时，将会错误地释放掉指针所指向的内存，造成崩溃。在开始前进行判断可避免这一情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">Demo &amp; Demo::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Demo &amp; obj) &#123;<br><span class="hljs-keyword">if</span> (&amp;obj != <span class="hljs-keyword">this</span>) &#123;<br><span class="hljs-keyword">delete</span> ptr;<br>ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(*obj.ptr);<br>&#125;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FlexiCharger 减少笔记本电脑电池损耗</title>
    <link href="/2021/02/02/flexicharger/"/>
    <url>/2021/02/02/flexicharger/</url>
    
    <content type="html"><![CDATA[<h1 id="FlexiCharger-减少笔记本电脑电池损耗"><a href="#FlexiCharger-减少笔记本电脑电池损耗" class="headerlink" title="FlexiCharger 减少笔记本电脑电池损耗"></a>FlexiCharger 减少笔记本电脑电池损耗</h1><h2 id="Part-1-背景"><a href="#Part-1-背景" class="headerlink" title="Part 1 背景"></a>Part 1 背景</h2><p>平时常常插电使用笔记本电脑。在我的认知里，插电时会先用电源适配器满足电脑功耗，再给电池充电。但是，<a href="https://www.zhihu.com/question/25416371/answer/629008593">偶然了解到最好不要让电池长期处在电量充满的情况下后</a>，我希望寻找一种方法来阻止电池充满。经过一番搜索，我<a href="https://easyelectriclife.groupe.renault.com/en/glossary/flexi-charger/">找到</a>了我所使用的蓝天 NK 系列模具开启这种机制的方法—— FlexiCharger。</p><h2 id="Part-2-操作步骤"><a href="#Part-2-操作步骤" class="headerlink" title="Part 2 操作步骤"></a>Part 2 操作步骤</h2><p>1.开机按 F2 进入 BIOS，选择 Setup Utility。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20210202001.jpg" alt="BIOS"></p><p>2.找到 Advanced 中的 Advanced Chipset Control，将 FlexiCharger 调整到 Enabled，下面的 Start Charge 和 Stop Charge 分别是插电后开始充电和停止充电的阈值，合理设置即可。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20210202002.jpg" alt="Advanced Chipset Control"></p>]]></content>
    
    
    <categories>
      
      <category>娱乐</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>神船 TX6 安装 ArchLinux</title>
    <link href="/2020/12/25/arch-install/"/>
    <url>/2020/12/25/arch-install/</url>
    
    <content type="html"><![CDATA[<h1 id="神船-TX6-安装-ArchLinux"><a href="#神船-TX6-安装-ArchLinux" class="headerlink" title="神船 TX6 安装 ArchLinux"></a>神船 TX6 安装 ArchLinux</h1><p>警告！本文可能有大量图片，流量消耗大。</p><p>本文为安装完毕一个多月后撰写，部分回忆可能与事实有所出入，仅供参考。</p><h2 id="Part-1-准备工作"><a href="#Part-1-准备工作" class="headerlink" title="Part 1 准备工作"></a>Part 1 准备工作</h2><p>由于原装 SSD 使用的是被认为较差的群联 PS3111 主控且运行在 SATA 速率下，我选择加装一条 NVMe 的 SSD。蓝天的 NK60SB 模具拥有第二个 M.2 2280 硬盘位，且为 PCIe 3.0 × 4 速率。（在这里补充一下，固件里面可能写的模具是 NKx0Sx，其中 NK50、NK60、NK70 分别对应 15.6 吋、16.1 吋、17.3 吋的屏幕，NK50SZ 无独显，NK50S5 搭载 NVIDIA GeForce MX350 独显，NK50/60/70 后缀 SB 对应 GTX1650，SE 对应 GTX1650Ti，但可能识别是 NKx0Sx，参考神舟的<a href="http://kfgl.hasee.com/lookup/book/bblist.asp">网站</a>）为了管理方便，NVMe 固态“象征性地”在 Windows 下分出 5GiB，其余容量全部不分配。</p><p>虽然安装 ArchLinux 和 WinPE 没啥关系，但为了防止哪天 Win 出问题，我打算顺便创建一个 WinPE 的启动盘。</p><p>在这里，我选择使用 U 盘安装。参考 <a href="https://zhuanlan.zhihu.com/p/31361497">macOS、Windows 10、GParted Live、WinPE 多种操作系统，用一个 U 盘搞定 - 知乎</a>，选择使用 DiskGenius 为 U 盘创建两个 FAT32 的文件分区，第一个分区 3.1GiB，第二个 4.1GiB，用来实现 ArchLinux Live Install 和启动 WinPE。为了方便，可以设置不同的卷标。为了省事，我没有格式化，而是把原有的文件扔进了 PE 的分区。分区后，从 ArchLinux 网站（<a href="https://archlinux.org/download">https://archlinux.org/download</a> ）下载 x86_64 的安装 ISO，用资源管理器装载后把文件复制进第一个分区。下载安装 AOMEI PE Builder，安装，生成 ISO 文件后用同样的方法复制进第二个分区。</p><p>需要注意的是，如果 AOMEI PE Builder 下载缓慢的话，可以用我分享的版本：链接: <a href="https://pan.baidu.com/s/1C3O-OAkBika2yj4UGAU1xw">https://pan.baidu.com/s/1C3O-OAkBika2yj4UGAU1xw</a> 提取码: mfi5，将里面的目录复制到你的下载目录，这个目录在 PE Builder 安装位置的 DownloadPath.ini 文件中有指定。</p><p><img src="https://zhaozihanzzh.github.io/images/aomei_prog.jpg" alt="aomei_prog"></p><p>之后插入 U 盘，在 BIOS 里面 Boot Manager 可以选择 EFI Boot Devices 了，可以进入 AOMEI PE Builder，发现一切正常，也可以进入 ArchISO 看一看。</p><p><img src="https://zhaozihanzzh.github.io/images/sel_boot.jpg" alt="sel_boot"></p><p><img src="https://zhaozihanzzh.github.io/images/aomei_desktop.jpg" alt="aomei_desktop"></p><p><img src="https://zhaozihanzzh.github.io/images/archiso_menu.jpg" alt="archiso_menu"></p><p>然后，尴尬的事情发生了。一直出现</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Waiting <span class="hljs-number">30</span> <span class="hljs-built_in">seconds</span> <span class="hljs-keyword">for</span> device /dev/disk/<span class="hljs-keyword">by</span>-label/ARCH_202011 ...<br><br>ERROR: <span class="hljs-string">&#x27;/dev/disk/by-label/ARCH_202011&#x27;</span> device did <span class="hljs-keyword">not</span> show up <span class="hljs-keyword">after</span> <span class="hljs-number">30</span> <span class="hljs-built_in">seconds</span>...<br><br>​Falling back <span class="hljs-built_in">to</span> interactive prompt<br><br>​You can <span class="hljs-keyword">try</span> <span class="hljs-built_in">to</span> fix <span class="hljs-keyword">the</span> problem manually, <span class="hljs-built_in">log</span> out when you are finished<br><br>sh: can<span class="hljs-string">&#x27;t access tty: job control turned off</span><br></code></pre></td></tr></table></figure><p><img src="https://zhaozihanzzh.github.io/images/starterr.jpg" alt="starterr"></p><p>不得已，我只好格式化 U 盘，这次用 DiskGenius 来往分区里写文件，一番操作后，终于成功启动 LiveCD 了。</p><p><img src="https://zhaozihanzzh.github.io/images/copyiso.png" alt="copyiso"></p><p>为了避免需要在浏览器中登录 WiFi，我使用手机连接 WiFi 后开启 WLAN 信号桥，中继出一个不需要浏览器认证的网络。</p><p><img src="https://zhaozihanzzh.github.io/images/WLANBridge.jpg" alt="WLANBridge"></p><h2 id="Part-2-安装"><a href="#Part-2-安装" class="headerlink" title="Part 2 安装"></a>Part 2 安装</h2><p>整个安装过程，参考以下文章，请以官方 Wiki 为准：<a href="https://wiki.archlinux.org/index.php/Installation_guide_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">Installation guide (简体中文) - ArchWiki</a></p><p><a href="https://zhuanlan.zhihu.com/p/99448314">ArchLinux安装(UEFI) - 知乎</a></p><p><a href="https://www.zhihu.com/question/21427410/answer/171867330">Arch Linux 怎么安装？ - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/202914804">Arch Linux 安装指南 2020.08 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/138951848">2020 Archlinux双系统安装教程（超详细） - 知乎</a></p><p>如果 CAPS-LOCK 按键无法使用，按住 Shift 的同时按下字母键来输入大写字母。</p><p>1.关闭 Win10 的“快速启动”功能（我安装时并没有关闭，漏掉了这一步），重启进入 BIOS，从 U 盘启动 ArchISO，键入以下命令以验证启动模式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls /sys/firmware/efi/efivars<br></code></pre></td></tr></table></figure><p>目录被正常显示，说明我使用的是 UEFI 模式启动。</p><p>接下来我们使用 iwctl 连接 WiFi，键入 <code>iwctl</code> 后使用 <code>device list</code> 命令列出可用的无线网卡，使用 <code>station 网卡名 scan</code> 来扫描后用 <code>station 网卡名 get-networks</code> 列出扫描到的热点，使用 <code>iwctl --passphrase 密码 station 网卡名 connect SSID</code> 连接，之后按 CtrlD 退出 iwctl。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121001.jpg" alt="image-20201121001"></p><p>2.使用 <code>ping archlinux.org</code> 检查能否连接 archlinux 网站，之后使用 <code>timedatectl set-ntp true</code> 命令确保系统时间准确（我当时好像没有检查时间，有些图片缺失）</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121002.jpg" alt="image-20201121002"></p><p>3.使用 <code>fdisk -l</code> 命令查看块设备，发现我们的目标磁盘块设备文件为 /dev/nvme0n1（Linux 中有“一切都是文件”一说），使用 gpt 磁盘分区表，接下来确定分区方案。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121003.jpg" alt="image-20201121003"></p><p>分区参考了 <a href="https://www.zhihu.com/question/25118984/answer/567568759">Linux 桌面用户是否有对 /boot 单独分区的必要？ - 知乎</a>、<a href="https://wiki.archlinux.org/index.php/Partitioning_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">Partitioning (简体中文) - ArchWiki</a>，为了简便选择不设立 swap 分区，选择使用 cfdisk 工具（应该是？）：<code>cfdisk 块设备路径</code> 后会进入一个互动式的界面，在这里我给剩余空间分出 2GiB 留作 EFI 引导和 boot 用（这块硬盘上原来是没有 EFI 分区的），分出 32GiB 作为根目录所需，另外在结尾预留 1.9 GiB 以备以后扩展或修正等后其余容量留给主目录，分区类型分别为 EFI System，Linux root (x86-64)，Linux filesystem，确认磁盘上原有的分区没有被错误地修改后即可写入新的分区，注意要记住你创建的分区的块设备文件，在本例中是屏幕最左侧的那一列。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121004.jpg" alt="image-20201121004"></p><p>4.创建分区完毕后对其进行格式化，Linux 有许多不同的文件系统，但由于本人对文件系统不甚了解，最终为根目录和主目录选择较老的 ext4 文件系统：<code>mkfs.ext4 块设备文件</code>，而根据 Wiki，UEFI 推荐使用 FAT32 文件系统：<code>mkfs.fat -F32 块设备文件</code>。之后进行挂载分区，在这里我把根目录的块设备挂载到 /mnt（<code>mount 块设备 挂载点</code>），之后执行 <code>mkdir /mnt/efi</code>、<code>mkdir /mnt/home</code> 为 EFI 和主目录创建挂载点并挂载。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121005.jpg" alt="image-20201121005"></p><p>5.使用 pacstrap 安装脚本安装 base 软件包、Linux 内核和常规硬件的固件（这里我没有使用 LTS 内核之类的），这里 <code>/mnt</code> 是根目录的挂载点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacstrap /mnt base linux linux-firmware<br></code></pre></td></tr></table></figure><p><img src="https://zhaozihanzzh.github.io/images/image-20201121006.jpg" alt="image-20201121006"></p><p>注意，这里日志中输出的几个关于 aic94xx，wd719x，xhci_pci 的 WARNING 可以参见 Wiki 说明：<a href="https://wiki.archlinux.org/index.php/Mkinitcpio#Possibly_missing_firmware_for_module_XXXX">mkinitcpio - ArchWiki</a>。</p><p>接下来创建分区表（/mnt 仍然是根目录挂载点）： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab<br></code></pre></td></tr></table></figure><p>接着检查一下创建的分区表 /mnt/etc/fstab：<img src="https://zhaozihanzzh.github.io/images/image-20201121007.jpg" alt="image-20201121007"></p><p>6.chroot 进安装的系统环境：<code>arch-chroot /mnt</code>（/mnt 为根目录挂载点），之后执行 <code>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code> 设置为上海（东八区）时间，执行 <code>hwclock --systohc</code> 命令，到此时间设置完毕。 </p><p>7.编辑 /etc/locale.gen 这个文本文件，在此我通过取消对应行前面的注释（即删除 # 号）来将 locale 设置为 en_US.UTF-8，不设置为中文的理由可以见官方 Wiki，据说会使 tty 乱码。之后，在终端执行 locale-gen 命令，然后，同样地创建 /etc/locale.conf，写入：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">LANG</span>=en_US.UTF-<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>8.为你的机器想一个 hostname 来替换这一步的所有 myhostname：</p><p>创建 /etc/hostname，写入以下内容：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">myhostname</span><br></code></pre></td></tr></table></figure><p>在 /etc/hosts 添加对应的信息：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span>localhost<br>::<span class="hljs-number">1</span>    localhost<br><span class="hljs-number">127.0.1.1</span>myhostname.localdomainmyhostname<br></code></pre></td></tr></table></figure><p> 使用 passwd 命令，为 root 用户设置密码。就算你用 sudo，这步也十分重要。</p><p>9.最后安装启动引导，对于我使用的 GPT 分区表 + UEFI 系统，需要安装 grub 和 efibootmgr 软件包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -S grub efibootmgr<br></code></pre></td></tr></table></figure><p>如果你想让 GRUB 自动检测到 Windows 的存在并自动配置好 Windows 的启动条目的话，还需要安装 os-prober 和 ntfs-3g。</p><p>之后执行  <code>grub-install --target=x86_64-efi --efi-directory=/efi --bootloader-id=GRUB</code>。这里的 /efi 是我为 EFI 系统选择的挂载点，最后的 grub 是启动引导器标识，详见 wik，这一步将把 GRUB EFI 安装到 挂载点/EFI/启动引导器标识 路径。之后，执行 <code>grub-mkconfig -o /boot/grub/grub.cfg</code> 来生成配置文件。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121008.jpg" alt="image-20201121008"></p><p>10.到这里可能就可以重启了，可能最好在此之前安装联网相关的软件包，但我已经不记得当时进行了什么操作。按 Ctrl + C 退出 chroot，之后 <code>umount -R 挂载点</code> 以卸载分区，使用 reboot 以重启。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121009.jpg" alt="image-20201121009"></p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121011.jpg" alt="image-20201121011"></p><h2 id="Part-3-锦上添花"><a href="#Part-3-锦上添花" class="headerlink" title="Part 3 锦上添花"></a>Part 3 锦上添花</h2><p>1.电脑时间问题</p><p><a href="https://sspai.com/post/55983">Linux Windows 双系统时间不一致 - 少数派</a></p><p>2.添加用户及 sudo</p><p>以下大部分内容可以在这里找到答案：</p><p><a href="https://wiki.archlinux.org/index.php/General_recommendations">General recommendations - ArchWiki</a></p><p>3.安装桌面环境（DE）</p><p>在这里，我选择 SDDM 作为显示管理器， KDE 作为桌面环境。但是，我安装 KDE 时选择的是 plasma-desktop 这一“最小化安装”，导致安装出来竟然在图形界面没有提供终端模拟器，最后按 Ctrl + Alt + F2 登录进另一个 tty 后手动安装了 konsole 软件包才得以解决。事后我还安装了 dolphin 和 ark。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121012.jpg" alt="image-20201121012"></p><p>4.安装字体</p><p>5.NVIDIA 独显驱动</p><p>我的 Intel Graphics UHD 630集成显卡一开始使用的是 mesa 软件包，希望使用 bumblebee 来实现双显卡切换，最终我的机器不仅无法启动图形界面，连其他的 tty 都无法开启，只好又插上了 ArchISO，卸载了 bumblebee，决定使用 PRIME 方案，结果，Arch wiki 里面nvidia-xconfig 的配置直接让我无法进入 KDE。我发现我的情况似乎与 wiki 上不一致，后来的一些研究为我提供了帮助：<a href="https://forums.developer.nvidia.com/t/archlinux-nvidia-settings-error-unable-to-load-info-from-any-available-system/111170">ArchLinux nvidia-settings ERROR: Unable to load info from any available system</a> 。以下网页说，现代系统不需要 nvidia-xconfig 了。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121010.jpg" alt="image-20201121010"></p><p>6.键盘背光</p><p>根据网络上的提示，我成功地为 NK60SB 开启了键盘背光，编译了<a href="https://github.com/zhaozihanzzh/clevo-xsm-wmi/commit/5d855522fbd18ddd6b2e3ba91632df909189c9dd">相关驱动</a>。</p><p>7.续航测试</p><p>某日，在图书馆没有能充电的位置了，顺便进行测试：屏幕亮度 20%，连接 WiFi，关闭蓝牙，开启独显（如果我没有配置错误的话）。机器电池 47 WHr，采用 Intel i5-10400 CPU，NVIDIA GeForce GTX1650 独显，16.1吋 60Hz 1080P 屏幕，进行少量网页浏览，主要是 WPS PDF 浏览和 WPS 文字编辑。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201128001.png" alt="image-20201128001"></p><p>8.开启蓝牙</p><p><a href="https://wiki.archlinux.org/index.php/Bluetooth_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">Wiki</a> 中提供了步骤，注意我的机器需要疑难解答中的步骤才能与手机配对。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>通用学术英语词表配套练习</title>
    <link href="/2020/12/18/general-academic-words/"/>
    <url>/2020/12/18/general-academic-words/</url>
    
    <content type="html"><![CDATA[<h1 id="通用学术英语词表配套练习"><a href="#通用学术英语词表配套练习" class="headerlink" title="通用学术英语词表配套练习"></a>通用学术英语词表配套练习</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>perform … analysis 进行 … 分析<br>approach the limit 接近限值<br>area 面积<br>assessment 评估<br>assume 假定，设想<br>authority 权力<br>little information is available on …<br>benefit 收益<br>concept 观念<br>be consistent with 与…一致<br>constitutional reform 宪政改革<br>in the context of 在…具体背景下<br>under the contract 依据合同<br>create flexibility 带来灵活性<br>data 资料<br>high definition 高清<br>be derived from 来源于，衍生于<br>division 分工 distribution 分布 circulation 流通<br>sth. is well established 某事物被认可接受<br>estimate the cost of … at 预估某事完成的成本是 …<br>evidence 证据，不可数名词<br>export 资料等导出<br>factor 因素 point 观点<br>formula 公式<br>fulfil … function 发挥作用<br>be identified as 被确认为 be associated with 有关联<br>per capita income 人均收入<br>indicate 表明<br>interpretation 理解<br>involve 是 … 的一部分，是 … 的结果<br>issue 议题<br>legislation 立法，法律<br>proportion of 前面不加具体数词<br>fiscal 财政的<br>in principle 理论上，原则上<br>procedure 程序<br>proceed 前进<br>qualitative research 定性研究<br>private sector 民营部门，私人部门（sector 扇形，扇区，部门）<br>indifferent 冷淡的，不关心的<br>commonplace 平凡的<br>incline to 倾向于<br>contamination 污染<br>specific provision 特定条款<br>generalization 概括</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>achieve the purpose 达到目的<br>acquisition 获得<br>headquarter 总部<br>alienation 疏远<br>supervision 监督<br>fall into … categories 分为 … 类型<br>commission 委任<br>residence 住所<br>load 传输<br>consequence analysis 结果分析<br>give/deserve/take credit for 因为 … 而受到应有的赞扬<br>demonstration 演示<br>specialty 专业，地方特产<br>final 最终的 eventual 过程和时间上的最终结果<br>suffer injury 受伤<br>journal 某学科或专业的刊物<br>provision 提供 precaution 预防<br>obtain a result 得到结果<br>be perceived to be 被认为是<br>respective 各自的<br>elemental 基础的<br>seek methodologies 寻求方法<br>competence 能力<br>transition 过渡</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>一般情况下，another之后只能接单数名词，如：another student。如果another后的名词有数词或few修饰时，则也可接复数名词，如：another few days.（另外几天）、another five chairs.（另外五把椅子）<br>（摘自 <a href="https://www.yikaow.com/yikao/57644.html）">https://www.yikaow.com/yikao/57644.html）</a><br>compensation 赔偿<br>consent 同意<br>impose constraint 施加约束<br>naming convention 命名约定<br>coordination 协同</p><p>只有一部分，见谅。</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图论</title>
    <link href="/2020/12/08/graph-theory/"/>
    <url>/2020/12/08/graph-theory/</url>
    
    <content type="html"><![CDATA[<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><p>简单辨析一些问题：</p><h2 id="一、图的基本组成"><a href="#一、图的基本组成" class="headerlink" title="一、图的基本组成"></a>一、图的基本组成</h2><p>1.图，组成，无向有向问题</p><p>2.平行边（注意有向图里情况），结点邻接，环（注意度数），孤立点，边关联于结点，边集元素重复，n 阶图？零图？平凡图？空图（及符号表示）？结点的度数，入度，出度（重复的边算吗，符号表示）？最大/小度及其符号？悬挂结点/边？图的度数序列？</p><p>3.简单图？多重图？n 阶无向完全图及符号表示？有向完全图？默认的完全图？n 阶有向/无向完全图的边数？什么是 k - 正则图？n 阶无向完全图是 (n-1) - 正则图吗 ？什么是环图？什么是轮图？轮图最低阶数？什么是 n 方体图？二分图？完全二分图及其记法？带权图的权在边上还是结点，还是都行？</p><p>4.删除边/边集/结点/结点集运算？边的收缩及其符号？加新边及其符号？子图 / 母图？生成子图？由结点集 / 边集导出子图及其符号？<em>G</em>(<em>E</em>-<em>E<sub>1</sub></em>) 与 <em>G</em>-<em>E<sub>1</sub></em> 的区别？<em>G</em> 的补图与符号表示？（注意其结点）图的同构，自互补图？</p><p>5.通路，简单通路，基本通路（又叫初级通路，路径）；回路，简单回路，基本回路（又叫初级回路、圈），奇 / 偶回路，短程线与<em>d</em>(u, v)，连通图、非连通图（无向图）？连通关系（无向图）？连通关系是等价关系吗？<em>W</em>(<em>G</em>) 指什么？简单图里 n-w&lt;=e？点割集与割点？边割集与割边（桥）？可达、相互可达（有向图）？有向图中：单向连通？强连通 / 弱连通？单向连通一定是弱连通？有向连通图？强分图？强连通图判定定理（有点像废话）？</p><p>6.邻接表（局限，有向图、无向图上的表现），有向图的邻接矩阵及某行 / 列和的意义？有向图邻接矩阵 k 次幂的元素意义？无向图的邻接矩阵及其幂？如何通过邻接矩阵判断图的连通性？邻接矩阵与同构的关系？什么是有向图的可达矩阵？怎么利用可达矩阵求强连通分支？什么是有向图的关联矩阵？什么是无向图的关联矩阵（行列代表什么？什么情况下元素为 2 ？每行元素和代表？）<br>邻接，可达，关联矩阵各有什么字母？</p><h2 id="二、特殊图"><a href="#二、特殊图" class="headerlink" title="二、特殊图"></a>二、特殊图</h2><p>1.欧拉回路，欧拉通路，欧拉图，半欧拉图？欧拉图的判定？半欧拉图呢？欧拉有向图、半欧拉有向图中的“有向”？欧拉有向图/半欧拉有向图的充要条件？（半）哈密顿回路 / 图（像欧拉图一样分有向无向吗）？判定哈密顿图的两个充分条件、一个必要条件？半哈密顿图的充分条件？彼得森图？格雷码？格雷码怎么找？</p><p>2.旅行商问题？最短路径问题及 Dijkstra 算法？中国邮路问题？</p><p>3.匹配？极大匹配？最大匹配？（VS 最大元，极大元）<em>M</em> 饱和点 / 非饱和点？完美匹配？<em>M</em> 交错路？<em>M</em> 可扩充路？最大匹配判定定理？</p><p>4.二分图？怎么判断一个图是不是二分图？互补结点集？完全二分图及其符号表示？完全二分图充要条件？【弄错了？】二分图的完备匹配 / 完美匹配？从 <em>V<sub>1</sub></em> 到 <em>V<sub>2</sub></em> 的完备匹配呢？怎么判断二分图是否存在完备匹配？ t 条件是二分图完备匹配存在的充分条件还是必要条件？</p><p>5.平面图？平面嵌入？<em>G</em> 的面？<em>f<sub>0</sub></em> 的中文名与意义？<em>f<sub>1</sub></em> ，<em>f<sub>2</sub></em> …呢？面的边界？deg(<em>f</em>)？∑deg(<em>f<sub>i</sub></em>) 与 e 的关系？连通平面图的欧拉公式与记忆技巧？非连通的平面图呢？什么叫两个图同胚？判定一个图是平面图的充要条件？</p><p>6.<em>G</em>* 是什么，怎么作？<em>G</em>* 是连通的吗？与原图的结点数，面数，边数关系？同构平面图的对偶图也一定同构吗？<em>G</em>* 的对偶图的对偶图和 <em>G</em>* 一定同构吗？什么是对简单图（结点）着色？什么是 k - 可着色的？什么是色数和 k 色图？无环图色数最大是？Brooks 定理（ <em>G</em> 不是完全图或长度为奇数的基本回路时色数最大值）？二分图的色数？色数为 2 能否说明是二分图？k - 可边着色？简单图的边色数？二分图的边色数？</p><h2 id="三、树"><a href="#三、树" class="headerlink" title="三、树"></a>三、树</h2><p>1.无向树？无向树的树叶、分支点、内点？平凡树？森林？<em>T</em> 是连通图且 e=n-1 能判定是无向树吗？<em>T</em> 无回路且 e=n-1 能判定是无向树吗？<em>T</em> 无回路且任意两结点间增加一条边，得到一条且仅一条回路，能判定 <em>T</em> 是无向树吗？证明 <em>T</em> 中结点数不小于 2 时 <em>T</em> 至少有两片树叶。生成树，弦，余树。图 <em>G</em> 有生成树的等价条件。给出求无向连通图的生成树的算法？给出求无向连通图的最小生成树的算法？</p><p>2.有向树？其边的方向是怎样的？有向根树？有向根树的树叶、分支点、树根、内点的定义？某结点的级数（层数）的定义，树的高度的定义？结点间的关系：祖先，后代，父子，兄弟？什么是根子树？什么是 m 元树，m 元正则树，完全 m 元正则树，完全 m 元树（学校的定义）？m 元正则树中结点数，分支点数，m 的关系？利用此关系与定义，能否互推出结点数、分支点数、树叶数的关系式？高为 h 的 m 元树里至多有多少树叶？</p><p>3.什么是有序根树？二元有序根树的左儿子，右儿子，左子树，右子树？介绍二元有序根树的前序遍历算法，中序遍历算法，后序遍历算法？什么是波兰、逆波兰记法？前缀码与二元树？前缀码是唯一的吗？如何生成最优二元树，最佳前缀码？</p><h2 id="四、证明定理："><a href="#四、证明定理：" class="headerlink" title="四、证明定理："></a>四、证明定理：</h2><p>握手定理+性质。（单独的度数可以用求和的方法转到度数和再借助不等式求解）结点总数超过 3 时平面简单图中每个面次数至少为 3。</p><p>某些定量性质：</p><p>图论基本定理（握手定理）？度数为奇数的结点一定有偶数个吗？有向图中所有结点入度之和与出度之和等于什么？怎么判断自然数序列是不是图的度数序列？</p><p>简单图里 n-w&lt;=e？</p><p>连通平面图的欧拉公式</p><p>m 元正则树中结点数，分支点数， m 的关系？利用此关系与定义，能否互推出结点数、分支点数、树叶数的关系式？高为 h 的 m 元树里至多有多少树叶？</p><p>旅行商问题？最短路径问题及 Dijkstra 算法？中国邮路问题？</p><p><em>G</em>* 是什么，怎么作？</p><p>介绍二元有序根树的前序遍历算法，中序遍历算法，后序遍历算法？</p><p>如何生成最优二元树，最佳前缀码？</p><h2 id="五、部分错题"><a href="#五、部分错题" class="headerlink" title="五、部分错题"></a>五、部分错题</h2><p>1.把平面分成 x 个区域，每两个区域相邻，问 x 最大为？</p><p>我的答案：5 正确答案：4</p><p>2.给设 d=(d<sub>1</sub>, d<sub>2</sub>, …, d<sub>n</sub>)，其中 d<sub>i</sub> 为正数，i = 1, 2, …, n。若存在 n 个结点的简单图，使得结点 v<sub>i</sub> 的度数为 d<sub>i</sub>，则称 d 是可图解的。下面给出的各序列中，（  ）不是可图解的。</p><p>A. (1, 1, 1, 2, 3) B. (2, 3, 3, 4, 5, 6) C. (0, 1, 1, 2, 3, 3) D. (1, 3, 3, 4, 5, 6, 6) E. (1, 2, 2, 3, 4, 5)</p><p>我的答案：B E 正确答案：B D E</p><p>3.设 G 是一棵根树，则 G 一定是（  ）</p><p>A. 强连通图 B. 单向连通图 C. 弱连通图 D. 有向连通图</p><p>我的答案：B C D 正确答案：C D</p><p>4.若有向图中无回路，则其每条边都是割边。</p><p>我的答案：对 正确答案：错</p><p>5.K<sub>m,n</sub>，当 m 不等于 n 时不是哈密顿图。</p><p>我的答案：错 正确答案：对</p>]]></content>
    
    
    <categories>
      
      <category>离散数学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>神船 TX6 加致钛 PC005 Active SSD</title>
    <link href="/2020/11/13/ztpc005/"/>
    <url>/2020/11/13/ztpc005/</url>
    
    <content type="html"><![CDATA[<h1 id="神船-TX6-加致钛-PC005-Active-SSD"><a href="#神船-TX6-加致钛-PC005-Active-SSD" class="headerlink" title="神船 TX6 加致钛 PC005 Active SSD"></a>神船 TX6 加致钛 PC005 Active SSD</h1><h2 id="Part-1-安装"><a href="#Part-1-安装" class="headerlink" title="Part 1 安装"></a>Part 1 安装</h2><p>首先，确保机器断电，移除外置电池，用螺丝刀（我的是直径 3mm 的十字螺丝刀）卸下 D 面的 6 颗螺丝。</p><p><img src="https://zhaozihanzzh.github.io/images/7bf1a1d0297cfc72.jpg" alt="7bf1a1d0297cfc72"></p><p><img src="https://zhaozihanzzh.github.io/images/19cb84b171e24f73.jpg" alt="image-20201114011201054"></p><p>然后，准备好 M.2 SSD 的固定螺丝。我从京东自营购入，对方表示不带螺丝。（这里这个螺丝与我的螺丝刀略微不匹配，应该使用略小一点的。用我这个拧神船自带那块固态的螺丝，会直接滑丝）于是只好单独购买……搞这么大盒子，其实只有六个小小的螺丝……</p><p><img src="https://zhaozihanzzh.github.io/images/3089e9848921c7b7.jpg" alt="3089e9848921c7b7"><img src="https://zhaozihanzzh.github.io/images/2484e133816dcf08.jpg" alt="2484e133816dcf08"></p><p><img src="https://zhaozihanzzh.github.io/images/-5afe891743a5908f.jpg" alt="image-20201114011308540"></p><p><img src="https://zhaozihanzzh.github.io/images/57b5dcaf1d9f990f.jpg" alt="image-20201114011323631"></p><p>开箱，取出盘的本体。</p><p><img src="https://zhaozihanzzh.github.io/images/IMG_20201114_010645.jpg" alt="image-20201114011452363"></p><p>放掉身上可能存在的静电，将硬盘一端呈 45° 插入插槽（注意缺口），之后按下并用螺丝固定好。</p><p>因为要加散热片，我就不把 D 面扣上，只是拿 D 面垫着，直接开机。</p><h2 id="Part-2-娱乐测试"><a href="#Part-2-娱乐测试" class="headerlink" title="Part 2 娱乐测试"></a>Part 2 娱乐测试</h2><p><img src="https://zhaozihanzzh.github.io/images/QQ20201121113026.jpg" alt="QQ20201121113026"></p><p>开机后进行格式化。</p><p><img src="https://zhaozihanzzh.github.io/images/IMG_20201114_013228.png" alt="IMG_20201114_013228"></p><p>按照默认设置，结束后，空盘情况下进行一番娱乐：</p><p><img src="https://zhaozihanzzh.github.io/images/04.png" alt="04"></p><p><img src="https://zhaozihanzzh.github.io/images/760d06b46c661b62.png" alt="760d06b46c661b62"></p><p>从中可以看到，在 CrystalDiskMark 中，SSD 温度多次接近 70℃ ，甚至直接撞上 75℃ （貌似温度墙？）不过待机情况下倒是没那么夸张（我拆了 D 面？）。</p><p><img src="https://zhaozihanzzh.github.io/images/IMG_20201114_013548.jpg" alt="IMG_20201114_013548"></p><p><img src="https://zhaozihanzzh.github.io/images/IMG_20201114_013447.jpg" alt="IMG_20201114_013447"></p><p>另外，长江存储官网也有一个对应的工具 YMTC Smart Tool。</p><p><img src="https://zhaozihanzzh.github.io/images/-73937f4019225a34.jpg" alt="-73937f4019225a34"></p><h2 id="Part-3-散热片"><a href="#Part-3-散热片" class="headerlink" title="Part 3 散热片"></a>Part 3 散热片</h2><p>买之前就从各评测看到极端情况下这块 SSD 主控频繁撞温度墙，于是整了这么些东西……</p><p><img src="https://zhaozihanzzh.github.io/images/-372f6c991f7ffb4a.jpg" alt="-372f6c991f7ffb4a"></p><p>那个反光的东西是铜片，拍出来颜色都变了。另外感觉少了一点什么？</p><p>把导热硅片表面的膜撕下（爱撕机膜人），压在盘的芯片面，等按压凹陷平整后把铜片盖上。硅片黏性大，进行操作时最好保持清洁。另外我这块略微有点不太矩形？</p><p><img src="https://zhaozihanzzh.github.io/images/QQ20201121114408.jpg" alt="QQ20201121114408"></p><p>感觉不算厚，起码顶后盖的情况在我这里是没有的。</p><p><img src="https://zhaozihanzzh.github.io/images/QQ20201121114412.jpg" alt="QQ20201121114412"></p><p>压铜片时注意位置，我第一次太靠螺丝孔一侧，导致螺丝拧不上去，只得拆了重新装。由于硅片很黏，我掰开的时候一直担心会不会把芯片给揭掉……不过没有。另外，我没用那个橡皮筋，有一点点担心盘会被弄弯曲。我想这铜片可能不太容易掉下来的吧？</p><p><img src="https://zhaozihanzzh.github.io/images/QQ20201121114334.jpg" alt="QQ20201121114334"></p><p>然后，我并没有进行进一步的测试。（挨打中）</p>]]></content>
    
    
    <categories>
      
      <category>娱乐</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关系和函数</title>
    <link href="/2020/11/02/relations-functions/"/>
    <url>/2020/11/02/relations-functions/</url>
    
    <content type="html"><![CDATA[<h1 id="关系和函数"><a href="#关系和函数" class="headerlink" title="关系和函数"></a>关系和函数</h1><p>简单辨析一些问题：</p><p>有序对，有序 n 元组</p><p>笛卡尔积（直积）</p><p>关系（二元关系）及符号表示，从 A 到 B 的二元关系， A 上的二元关系，E<sub>A</sub>，I<sub>A</sub>，二元关系是一个有序对吗？</p><p>二元关系与有序对构成的集合是否等价？</p><p>二元关系的定义域（前域）、值域（后域）、域及其符号表示？</p><p>关系的表示：集合，关系图（注意 A 到 B 上的与 A 上的），邻接矩阵</p><p>关系的逆</p><p>对关系的并，交，补，差，包含等的结果求逆与对关系求逆后再进行运算相同吗？</p><p>关系的复合运算本质？集合描述时注意换元？满足交换律吗？结合律呢？</p><p>判断复合运算对并运算、交运算的分配情况：</p><script type="math/tex; mode=display">(S\cup P)\circ R\ 与 \ (S\circ R)\cup (P\circ R)</script><script type="math/tex; mode=display">R\circ (S\cup P)\ 与\ (R\circ S)\cup (R\circ P)</script><script type="math/tex; mode=display">(S\cap P)\circ R\ 与\ (S\circ R)\cap (P\circ R)</script><script type="math/tex; mode=display">R\circ (S\cap P)\ 与\ (R\circ S)\cap (R\circ P)</script><p>对关系的复合运算求逆的规则是怎样的？</p><p>关系 R 的 n 次幂是如何定义的？周期性是怎么回事？</p><p>关系矩阵？复合关系的关系矩阵与原来的两个矩阵之间的关系？在这里如何求关系矩阵的乘积？</p><p>关系的性质：什么是自反关系，反自反关系，对称关系，反对称关系，传递关系？</p><p>关系闭包的概念？r(R)，s(R)，t(R) 分别是？怎么求关系的自反闭包、对称闭包、传递闭包？</p><p>当非空集合上两个关系存在包含关系时，其闭包是否也存在包含关系？</p><p>思考以下闭包的并集与并集的闭包的关系？（如果有思考难度，可以考虑举例，特别注意传递闭包）（仍然是非空集合上的）</p><script type="math/tex; mode=display">r(R_1)\cup r(R_2)\ 与\ r(R_1\cup R_2)</script><script type="math/tex; mode=display">s(R_1)\cup s(R_2)\ 与\ s(R_1\cup R_2)</script><script type="math/tex; mode=display">t(R_1)\cup t(R_2)\ 与\ t(R_1\cup R_2)</script><p>若 R 是传递的，s(R) 一定是传递的吗？r(R) 呢？</p><p>能用关系矩阵的运算来求关系的关系闭包吗？</p><p>什么是 Warshall 算法？</p><p>什么是等价关系？等价关系中的一对有序对中的两个元素可以被称为“等价”吗？</p><p>[x]<sub>R</sub> 是什么？等价类是一个集合吗？A/R 是什么？</p><p>什么是一个集合的覆盖和划分？覆盖中的元素能是空集吗？什么是划分中的类/块？划分与商集的关系？划分的元素是？</p><p>什么是偏序关系？什么是偏序集？符号表示？</p><p>什么是可比？什么是不可比？什么是覆盖？哈斯图怎么画？</p><p>可比与全序关系、全序集？</p><p>极小元、最小元、极大元、最大元？</p><p>（集合）上界、下界、上确界、下确界？</p><p>良序集与良序关系？为什么说良序集一定是全序集，全序集不一定是良序集？</p><p>函数的像、原像？函数是一种集合吗？</p><p>B<sup>A</sup> 是什么集合？这种符号与其元素个数有什么关系？</p><p>单射函数、满射函数、双射函数？恒等函数、特征函数？自然映射？</p><p>复合函数的反函数与反函数的复合存在怎样的关系？</p><p>什么是等势？什么是有限集合的基数？可数集、可列集、阿列夫零、0 级无穷大？实数集的基数、1 级无穷大、阿列夫？</p><p>有最大的基数和最大的集合吗？</p><p>补充：注意各种运算的规律与性质，如 $f\circ g$ 是双射时满足“外满内单”。</p><p>错题：若 R 和 S 是集合 A 上的任意两个传递关系，则 R ○ S 也是传递的。</p><p>我的答案：对 正确答案：错</p>]]></content>
    
    
    <categories>
      
      <category>离散数学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>博客相关问题</title>
    <link href="/2020/11/01/gfm-error/"/>
    <url>/2020/11/01/gfm-error/</url>
    
    <content type="html"><![CDATA[<h1 id="博客相关问题"><a href="#博客相关问题" class="headerlink" title="博客相关问题"></a>博客相关问题</h1><p>1.使用 GFM 时发现，加粗、斜体格式用 *** 表示时在某些场景下会出现无法正确解析的问题。<img src="https://zhaozihanzzh.github.io/images/image-20201102210643027.png" alt="image-20201102210643027"></p><p>更换为 **_ 与 _** 后问题消失。</p><p>参考：<a href="https://www.reinforce.cn/t/545.html">https://www.reinforce.cn/t/545.html</a></p><p>2.开启 Typora 的行内公式支持：<a href="https://blog.csdn.net/weixin_30892763/article/details/98202815">https://blog.csdn.net/weixin_30892763/article/details/98202815</a></p><p>3.在 Typora 里面直接粘贴图片会导致图片变成 png 格式，好像会重新编码，压缩过的 jpg 会变成特别大的 png，不清楚是 Windows “照片”还是剪贴板，亦或是 typora 的锅。如果直接从菜单里面“插入本地图片”就会原封不动地插进来。</p><p>4.URL 中的括号等特殊字符需要用转义字符表达以防止解析错误：左括号用 %28，右括号用 %29。</p><p>5.关于 raw.githubusercontent 无法加载图片：将 raw.githubusercontent.com/用户名/用户名.github.io/master/ 替换为 用户名.github.io/</p><p>6.行内公式下划线解析错误时，改用两个 dollar 符号括起来。</p>]]></content>
    
    
    <categories>
      
      <category>计算机杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>初探矩阵</title>
    <link href="/2020/10/25/matrix/"/>
    <url>/2020/10/25/matrix/</url>
    
    <content type="html"><![CDATA[<h1 id="初探矩阵"><a href="#初探矩阵" class="headerlink" title="初探矩阵"></a>初探矩阵</h1><h2 id="一、矩阵定义"><a href="#一、矩阵定义" class="headerlink" title="一、矩阵定义"></a>一、矩阵定义</h2><h3 id="1-数域"><a href="#1-数域" class="headerlink" title="1. 数域"></a>1. 数域</h3><p>对于一个至少含有 0,1 的复数集合的子集 F ，如果其中任意两个数的四则运算所得结果仍在 F 中，那么 F 称为一个数域。显然，有理数域是最小的数域。</p><h3 id="2-矩阵"><a href="#2-矩阵" class="headerlink" title="2. 矩阵"></a>2. 矩阵</h3><p>矩阵是指某一数域中的 m × n 个数排成 m 行 n 列的表。可记为 <strong><em>A</em></strong> = (a<sub>ij</sub>)<sub>mn</sub>，或 <strong><em>A</em></strong><sub>mn</sub>，或 <strong><em>A</em></strong><sub>m×n</sub>。如果没有特殊说明，我们讨论的是复矩阵。</p><p>两矩阵行列分别相等，称为同型矩阵。</p><p>当 m = 1 时，矩阵可以看成一个行向量；当 n = 1 时，矩阵可以看成一个列向量。当 m = n 时，称为 n 阶方阵，其主对角线（只有方阵才有）元素之和为方阵的迹，记作 tr(<strong><em>A</em></strong>)。</p><p>当 n 阶方阵不在主对角线上的元素都为 0 时，称为 n 阶对角矩阵，书写时只需保留主对角线，可记作 <strong><em>A</em></strong> = diag(a<sub>11</sub>, a<sub>22</sub>, …, a<sub>nn</sub>)。当 n 阶方阵不在次对角线上的元素都为 0 时，称为 n 阶反对角矩阵。</p><p>进一步地，如果对角矩阵主对角线所有数全为 1 ，称为单位矩阵，记作 <strong><em>E</em></strong><sub>n</sub> 或 <strong><em>E</em></strong> 。</p><p>当矩阵所有元素为 0 时，称为零矩阵，仍记为 <strong><em>0</em></strong> 。</p><p>仿照行列式，可以定义上三角、下三角矩阵。</p><p>某个矩阵的负矩阵中每个元素都与原矩阵中的对应元素互为相反数。</p><h2 id="二、矩阵运算"><a href="#二、矩阵运算" class="headerlink" title="二、矩阵运算"></a>二、矩阵运算</h2><h3 id="1-矩阵的加法"><a href="#1-矩阵的加法" class="headerlink" title="1.矩阵的加法"></a>1.矩阵的加法</h3><p>两个同型矩阵相加，所得矩阵上元素等于原来两矩阵对应位置元素之和。只有同型矩阵才能相加。某个矩阵减去另一个矩阵相当于加上它的负矩阵。</p><h3 id="2-矩阵的数乘"><a href="#2-矩阵的数乘" class="headerlink" title="2.矩阵的数乘"></a>2.矩阵的数乘</h3><p>某个矩阵与数域中某个数相乘，等于用这个数去乘这一矩阵上的每一个元素。这一点与行列式不同。</p><p>特别地，称 k<strong><em>E</em></strong> 为数量矩阵。</p><h3 id="3-矩阵的乘法"><a href="#3-矩阵的乘法" class="headerlink" title="3.矩阵的乘法"></a>3.矩阵的乘法</h3><p>设矩阵 <strong><em>A</em></strong> = (a<sub>ij</sub>)<sub>sn</sub>，<strong><em>B</em></strong> = (b<sub>kl</sub>)<sub>nm</sub>，则 <strong><em>AB</em></strong> = (c<sub>ij</sub>)<sub>sm</sub>，其中 c<sub>ij</sub> = a<sub>i1</sub>b<sub>1j</sub>+a<sub>i2</sub>b<sub>2j</sub>+a<sub>i3</sub>b<sub>3j</sub>+…+a<sub>n1</sub>b<sub>nj</sub> ，即：</p><script type="math/tex; mode=display">\sum^{n}_{k=1}a_{ik}b_{kj}</script><p>显然，矩阵乘法不满足交换律，当乘号前矩阵的列数与乘号后矩阵的行数不相等时，无法对这两个矩阵求积。另外，两矩阵之积为零矩阵，则这两个矩阵可能都不为零矩阵。</p><p>当 <strong><em>AB</em></strong> = <strong><em>BA</em></strong> 时，称 <strong><em>A</em></strong> 与 <strong><em>B</em></strong> 可交换，易知此时 <strong><em>A</em></strong> 与 <strong><em>B</em></strong> 为同阶方阵。</p><p>当 <strong><em>A</em></strong> 为对角矩阵时，通过设出 <strong><em>B</em></strong> 中的代表项可知，若要 <strong><em>A</em></strong> 与 <strong><em>B</em></strong> 可交换，此时 <strong><em>B</em></strong> 一定亦是对角矩阵。</p><p>矩阵乘法满足结合律、分配律。（矩阵乘法中混入的与数相乘也满足结合律）</p><p>同阶的上三角矩阵的积仍然是上三角矩阵。</p><h3 id="4-方阵的方幂与多项式"><a href="#4-方阵的方幂与多项式" class="headerlink" title="4.方阵的方幂与多项式"></a>4.方阵的方幂与多项式</h3><p>方阵 <strong><em>A</em></strong> 的 k 次方幂 <strong><em>A</em></strong><sup>k</sup> 表示 k 个 <strong><em>A</em></strong> 相乘。特别地， <strong><em>A</em></strong><sup>0</sup> = <strong><em>E</em></strong><sub>n</sub>。显然，在这里满足 <strong><em>A</em></strong><sup>k</sup><strong><em>A</em></strong><sup>l</sup> = <strong><em>A</em></strong><sup>k+l</sup>，（<strong><em>A</em></strong><sup>k</sup>)<sup>l</sup> = <strong><em>A</em></strong><sup>kl</sup>。</p><p>称 f(<strong><em>A</em></strong>) = a<sub>m</sub><strong><em>A</em></strong><sup>m</sup>+a<sub>m-1</sub><strong><em>A</em></strong><sup>m-1</sup>+…+a<sub>1</sub><strong><em>A</em></strong><sup>1</sup>+a<sub>0</sub><strong><em>E</em></strong> 为方阵 <strong><em>A</em></strong> 的 m 次多项式。</p><p>可以证明，方阵 <strong><em>A</em></strong> 的多项式 f(<strong><em>A</em></strong>) 与 g(<strong><em>A</em></strong>) 满足 f(<strong><em>A</em></strong>)g(<strong><em>A</em></strong>)=g(<strong><em>A</em></strong>)f(<strong><em>A</em></strong>)。</p><h3 id="5-矩阵的转置"><a href="#5-矩阵的转置" class="headerlink" title="5.矩阵的转置"></a>5.矩阵的转置</h3><p>将 <strong><em>A</em></strong> 行列互换得到的矩阵称为 <strong><em>A</em></strong> 的转置矩阵，记作 <strong><em>A</em></strong><sup>T</sup> 或 <strong><em>A’</em></strong>。</p><p>矩阵转置时，(<strong><em>A</em></strong>+<strong><em>B</em></strong>)<sup>T</sup>=<strong><em>A</em></strong><sup>T</sup>+<strong><em>B</em></strong><sup>T</sup>，(k<strong><em>A</em></strong>)<sup>T</sup>=k<strong><em>A</em></strong><sup>T</sup>，(<strong><em>AB</em></strong>)<sup>T</sup>=<strong><em>B</em></strong><sup>T</sup><strong><em>A</em></strong><sup>T</sup>，可推广为：(<strong><em>A</em></strong><sub>1</sub><strong><em>A</em></strong><sub>2</sub>…<strong><em>A</em></strong><sub>m</sub>)<sup>T</sup> = <strong><em>A</em></strong><sub>m</sub><sup>T</sup><strong><em>A</em></strong><sub>m-1</sub><sup>T</sup>…<strong><em>A</em></strong><sub>1</sub><sup>T</sup>。</p><p>当某矩阵与其转置矩阵相等时，称其为对称矩阵；当某矩阵与其转置矩阵的负矩阵相等时，称其为反对称矩阵。易知，反对称矩阵主对角线元素均为 0。</p><h3 id="6-矩阵的共轭"><a href="#6-矩阵的共轭" class="headerlink" title="6.矩阵的共轭"></a>6.矩阵的共轭</h3><p>称 <span style="text-decoration: overline"><strong><em>A</em></strong></span> = (<span style="text-decoration: overline">a<sub>ij</sub></span>)<sub>mn</sub> 是 <strong><em>A</em></strong> 的共轭矩阵。则有：<span style="text-decoration: overline"><strong><em>A</em></strong> + <strong><em>B</em></strong> </span> = <span style="text-decoration: overline"><strong><em>A</em></strong></span> + <span style="text-decoration: overline"><strong><em>B</em></strong></span>；<span style="text-decoration: overline">k<strong><em>A</em></strong></span> = <span style="text-decoration: overline">k</span> <span style="text-decoration: overline"><strong><em>A</em></strong></span>；<span style="text-decoration: overline"><strong><em>AB</em></strong></span> = <span style="text-decoration: overline"><strong><em>A</em></strong></span> <span style="text-decoration: overline"><strong><em>B</em></strong></span>；<span style="text-decoration: overline"><strong><em>A</em></strong><sup>T</sup></span> = (<span style="text-decoration: overline"><strong><em>A</em></strong></span>)<sup>T</sup>。</p><h2 id="三、矩阵的分块"><a href="#三、矩阵的分块" class="headerlink" title="三、矩阵的分块"></a>三、矩阵的分块</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>将矩阵用水平、垂直线划分成若干小矩阵所得的小矩阵称为矩阵的子块，以子块为元素的形式上的矩阵称为分块矩阵。</p><p>如果分块矩阵具有类似对角矩阵的形式，称为准对角矩阵。</p><p>分块矩阵进行运算时，要额外注意子块之间的运算是否有意义。</p><h3 id="2-转置"><a href="#2-转置" class="headerlink" title="2.转置"></a>2.转置</h3><p>未分块的矩阵的转置相当于把分块矩阵转置后再转置所有子块。</p><h2 id="四、方阵的行列式"><a href="#四、方阵的行列式" class="headerlink" title="四、方阵的行列式"></a>四、方阵的行列式</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h3><p>方阵 <strong><em>A</em></strong> 上的元素按其位置形成的行列式称为该方阵的行列式，记作 det(<strong><em>A</em></strong>) 或 |<strong><em>A</em></strong>|。有：|k<strong><em>A</em></strong>| = k<sup>n</sup>|<strong><em>A</em></strong>|，|<span style="text-decoration: overline"><strong><em>A</em></strong></span>| = <span style="text-decoration: overline">|<strong><em>A</em></strong>|</span>，</p><h3 id="2-乘积"><a href="#2-乘积" class="headerlink" title="2.乘积"></a>2.乘积</h3><p>|<strong><em>A</em></strong>||<strong><em>B</em></strong>| = |<strong><em>AB</em></strong>|。</p><h3 id="3-矩阵的子式"><a href="#3-矩阵的子式" class="headerlink" title="3.矩阵的子式"></a>3.矩阵的子式</h3><p>在 m × n 矩阵中任意取 k 行 k 列，位于这些选定的行列交叉点上的元素按原顺序排成的 k 阶行列式称为原矩阵的一个子式。</p><h2 id="五、矩阵初等变换"><a href="#五、矩阵初等变换" class="headerlink" title="五、矩阵初等变换"></a>五、矩阵初等变换</h2><h3 id="1-矩阵的初等变换"><a href="#1-矩阵的初等变换" class="headerlink" title="1.矩阵的初等变换"></a>1.矩阵的初等变换</h3><p>矩阵的一次初等行变换，是指对矩阵进行以下三种变换之一：a. 交换矩阵中的两行 b. 用数域中一个非零的数 k 去乘矩阵某行的各元素 c. 把矩阵某行各元素的 k 倍加到另一行中，其中 k 在数域内。这三种分别称为第 Ⅰ、Ⅱ、Ⅲ 种初等行变换。类似地，可以定义矩阵的初等列变换。矩阵的初等行、列变换合称矩阵的初等变换。符号表示与行列式类似。</p><p>如果一个矩阵经过一系列初等变换变成另一个矩阵，那么这两个矩阵等价。</p><h3 id="2-阶梯形矩阵"><a href="#2-阶梯形矩阵" class="headerlink" title="2.阶梯形矩阵"></a>2.阶梯形矩阵</h3><p>当 <strong><em>A</em></strong> = (a<sub>ij</sub>)<sub>mn</sub> 满足：a. 若某行元素全为 0 ，则该行以下均全为 0 元素；b. 当前 r 行均存在非零元素时，若设第 i 行左起第一个非零元素为  $a_{ij_{i}}$，则有 j<sub>1</sub> &lt; j<sub>2</sub> &lt; … &lt; j<sub>r</sub> 恒成立。</p><p>任意一个矩阵可以通过一系列初等行变换化为阶梯形矩阵。</p><h3 id="3-简化阶梯形矩阵"><a href="#3-简化阶梯形矩阵" class="headerlink" title="3.简化阶梯形矩阵"></a>3.简化阶梯形矩阵</h3><p>当阶梯形矩阵满足：a. 所有先导元素（每行第一个非零元素）为 1；b. 先导元素所在列除了先导元素外全为 0 ，称其为简化阶梯形矩阵。</p><h3 id="4-等价标准形矩阵"><a href="#4-等价标准形矩阵" class="headerlink" title="4.等价标准形矩阵"></a>4.等价标准形矩阵</h3><p>等价标准形矩阵的形式：</p><script type="math/tex; mode=display">\left( \begin{matrix} 1 &0 &\cdots &0 &0 &\cdots &0\\0 &1 &\cdots &0 &0 &\cdots &0 \\\vdots &\vdots &&\vdots &\vdots & &\vdots \\ 0 &0 &\cdots &1 &0 &\cdots &0 \\ 0 &0 &\cdots &0 &0 &\cdots &0 \\ \vdots &\vdots & &\vdots\ &\vdots & &\vdots \\0 &0 &\cdots &0 &0 &\cdots &0 \end{matrix} \right)=\left( \begin{matrix} E_r &0  \\ 0 &0 \end{matrix} \right)</script><p>向等价标准形转化时，可能需要用到列变换。</p><h3 id="5-初等矩阵"><a href="#5-初等矩阵" class="headerlink" title="5.初等矩阵"></a>5.初等矩阵</h3><p>第 Ⅰ 种类型初等矩阵：n 阶单位矩阵第 i 行、第 j 行互换所得，记作 <strong><em>P</em></strong>(i, j)。</p><p>第 Ⅱ 种类型初等矩阵：n 阶单位矩阵第 i 行乘非零的 k 所得，记作 <strong><em>P</em></strong>(i(k))。</p><p>第 Ⅲ 种类型初等矩阵：n 阶单位阵第 j 行的 k 倍加到第 i 行所得，记作 <strong><em>P</em></strong>(i, j(k))。</p><p>由于对任意矩阵作第 Ⅰ 种初等行变换相当于该矩阵左乘对应的第 Ⅰ 种初等矩阵，作第 Ⅰ 种初等列变换相当于该矩阵右乘对应的第 Ⅰ 种初等矩阵；对任意矩阵作第 Ⅱ 种初等行变换相当于该矩阵左乘对应的第 Ⅱ 种初等矩阵，作第 Ⅱ 种初等列变换相当于该矩阵右乘对应的第 Ⅱ 种初等矩阵；对任意矩阵作第 Ⅲ 种初等行变换相当于该矩阵左乘对应的第 Ⅲ 种初等矩阵，矩阵 <strong><em>A</em></strong> = (a<sub>ij</sub>)<sub>mn</sub> 右乘 n 阶 <strong><em>P</em></strong>(i, j(k)) 相当于 <strong><em>A</em></strong> 的第 i 列的 k 倍加到第 j 列，则可以将任一矩阵通过左乘或右乘初等矩阵化成等价标准形。</p><h2 id="六、矩阵的秩"><a href="#六、矩阵的秩" class="headerlink" title="六、矩阵的秩"></a>六、矩阵的秩</h2><h3 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h3><p>当非零的 m × n 矩阵 <strong><em>A</em></strong> 有非零的 r 阶子式而没有非零的 (r + 1) 阶子式时，该矩阵的秩为 r ，记作 r(<strong><em>A</em></strong>) 。零矩阵的秩规定为 0。</p><h3 id="2-满秩"><a href="#2-满秩" class="headerlink" title="2.满秩"></a>2.满秩</h3><p>如果 n 阶方阵 <strong><em>A</em></strong> 满足 r(<strong><em>A</em></strong>) = n，则称矩阵 <strong><em>A</em></strong> 为满秩的，或非奇异的，或非退化的。反之，则称 <strong><em>A</em></strong> 为降秩的，或奇异的，或退化的。</p><p>可以证明，方阵满秩与方阵的行列式非零等价。</p><h3 id="3-求解矩阵的秩"><a href="#3-求解矩阵的秩" class="headerlink" title="3.求解矩阵的秩"></a>3.求解矩阵的秩</h3><p>可以证明，初等变换不改变矩阵的秩，两个同型矩阵等价的充要条件为它们有相同的秩。矩阵转置后，秩不变。</p><p>阶梯型矩阵的秩等于其非零行的数目。</p><h2 id="七、矩阵的逆"><a href="#七、矩阵的逆" class="headerlink" title="七、矩阵的逆"></a>七、矩阵的逆</h2><h3 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1.定义"></a>1.定义</h3><p>设 <strong><em>A</em></strong> 为 n 阶方阵，若存在 <strong><em>B</em></strong> 使得 <strong><em>AB</em></strong> = <strong><em>BA</em></strong> = <strong><em>E</em></strong>，则 <strong><em>A</em></strong> 的逆矩阵 <strong><em>A</em></strong><sup>-1</sup> = <strong><em>B</em></strong>。</p><h3 id="2-性质"><a href="#2-性质" class="headerlink" title="2.性质"></a>2.性质</h3><p>a. <strong><em>A</em></strong>、<strong><em>B</em></strong> 可逆时，<strong><em>AB</em></strong> 也可逆，且 (<strong><em>AB</em></strong>)<sup>-1</sup> = <strong><em>B</em></strong><sup>-1</sup><strong><em>A</em></strong><sup>-1</sup>。（逆、转置的顺序要调换，共轭不需要）</p><p>b. <strong><em>A</em></strong> 可逆时，<strong><em>A</em></strong><sup>T</sup> 也可逆，且 (<strong><em>A</em></strong><sup>T</sup>)<sup>-1</sup>= （<strong><em>A</em></strong><sup>-1</sup>)<sup>T</sup>。</p><p>c. <strong><em>A</em></strong> 可逆时，<span style="text-decoration: overline"><strong><em>A</em></strong></span> 也可逆，且 <span style="text-decoration: overline"><strong><em>A</em></strong><sup>-1</sup></span> = (<span style="text-decoration: overline"><strong><em>A</em></strong></span>)<sup>-1</sup>。（逆的共轭等于共轭的逆）</p><p>d. (k<strong><em>A</em></strong>)<sup>-1</sup> = k<sup>-1</sup><strong><em>A</em></strong><sup>-1</sup>。</p><p>e. (<strong><em>A</em></strong><sub>1</sub><strong><em>A</em></strong><sub>2</sub>…<strong><em>A</em></strong><sub>S</sub>)<sup>-1</sup> = <strong><em>A</em></strong><sub>S</sub><sup>-1</sup><strong><em>A</em></strong><sub>S-1</sub><sup>-1</sup>…<strong><em>A</em></strong><sub>1</sub><sup>-1</sup></p><p>f. 上三角矩阵的逆仍然是上三角矩阵。</p><p>但是，(<strong><em>A</em></strong>+<strong><em>B</em></strong>)<sup>-1</sup> 不等于 <strong><em>A</em></strong><sup>-1</sup> + <strong><em>B</em></strong><sup>-1</sup>。</p><h3 id="3-充要条件"><a href="#3-充要条件" class="headerlink" title="3.充要条件"></a>3.充要条件</h3><p>当且仅当方阵 <strong><em>A</em></strong> 的行列式不为零时，<strong><em>A</em></strong> 可逆。</p><h3 id="4-利用伴随矩阵求逆"><a href="#4-利用伴随矩阵求逆" class="headerlink" title="4.利用伴随矩阵求逆"></a>4.利用伴随矩阵求逆</h3><p>定义 <strong><em>A</em></strong><sub>ij</sub> 为 方阵的行列式中元素 a<sub>ij</sub> 的代数余子式，称矩阵</p><script type="math/tex; mode=display">A^*=\left( \begin{matrix} A_{11} &A_{21} &\cdots  &A_{n1}\\A_{12} &A_{22} &\cdots  &A_{n2}\\\vdots &\vdots &&\vdots\\ A_{1n} &A_{2n} &\cdots  &A_{nn} \end{matrix} \right)</script><p>为 <strong><em>A</em></strong> 的伴随矩阵。（特别注意此矩阵经过了转置）</p><p>则有:</p><script type="math/tex; mode=display">A^{-1} = \frac{1}{|A|}A^*</script><p>但此方法较为繁琐。</p><h3 id="5-矩阵初等变换求逆"><a href="#5-矩阵初等变换求逆" class="headerlink" title="5.矩阵初等变换求逆"></a>5.矩阵初等变换求逆</h3><p>对于初等矩阵的逆，有：a. <strong><em>P</em></strong>(i, j)<sup>-1</sup> = <strong><em>P</em></strong>(i, j) b. <strong><em>P</em></strong>(i(k))<sup>-1</sup> = <strong><em>P</em></strong>(i(k<sup>-1</sup>)) c. <strong><em>P</em></strong>(i, j(k))<sup>-1</sup> = <strong><em>P</em></strong>(i, j(-k))，即初等矩阵的逆仍然是初等矩阵。</p><p>可逆矩阵只通过初等行变换即可变为单位矩阵。因此，可逆矩阵可表示为初等矩阵的积。</p><p>求 <strong><em>A</em></strong> 的逆时，可将与其同阶的单位阵加到其右边构成新矩阵，再通过初等行变换将矩阵左半边化成单位矩阵，此时右半边即为要求的逆；或者将与其同阶的单位阵加到其下边构成新矩阵，再通过初等列变换将矩阵上半边化成单位矩阵，此时下半边即为要求的逆。</p><p>这里，给出已知 <strong><em>A</em></strong>，<strong><em>B</em></strong> ，求 <strong><em>A</em></strong><sup>-1</sup><strong><em>B</em></strong> 的较快方法：(<strong><em>A</em></strong>, <strong><em>B</em></strong>) 通过初等行变换化为 (<strong><em>E</em></strong>, <strong><em>A</em></strong><sup>-1</sup><strong><em>B</em></strong>)。</p>]]></content>
    
    
    <categories>
      
      <category>线性代数与解析几何</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ 返回局部变量的引用与地址</title>
    <link href="/2020/10/24/local-variable-pr/"/>
    <url>/2020/10/24/local-variable-pr/</url>
    
    <content type="html"><![CDATA[<h1 id="C-返回局部变量的引用与地址"><a href="#C-返回局部变量的引用与地址" class="headerlink" title="C++ 返回局部变量的引用与地址"></a>C++ 返回局部变量的引用与地址</h1><p>听说 2020 - 1024 = 996？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span>&amp; <span class="hljs-title">refer</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; arg)</span> </span>&#123;<br><span class="hljs-keyword">int</span> inter_var = <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">return</span> inter_var;<br><span class="hljs-comment">// 返回局部变量的引用</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">pointer</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; arg)</span> </span>&#123;<br><span class="hljs-keyword">int</span> var = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> &amp;var;<br><span class="hljs-comment">// 返回指向局部变量的指针</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> number = <span class="hljs-number">996</span>;<br><span class="hljs-comment">// cout &lt;&lt; refer(2020); 错误，不是常引用的引用作形参，实参只能是变量（或常量）。</span><br>cout &lt;&lt; &amp;<span class="hljs-built_in">refer</span>(number) &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-built_in">refer</span>(number)&lt;&lt; endl; <span class="hljs-comment">// 局部变量被销毁</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a_const_int = <span class="hljs-number">2020</span>;<br><span class="hljs-comment">// cout &lt;&lt; refer(a_const_int); 错误，形参访问限制不能弱于实参。</span><br>cout &lt;&lt; <span class="hljs-built_in">pointer</span>(<span class="hljs-number">2020</span> - number) &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *<span class="hljs-built_in">pointer</span>(number) &lt;&lt; endl; <span class="hljs-comment">// 形参为常引用，实参可以为常量，变量，表达式，数值。</span><br><span class="hljs-keyword">void</span>* v = (<span class="hljs-keyword">void</span>*)<span class="hljs-built_in">pointer</span>(number);<br>cout &lt;&lt; *(<span class="hljs-keyword">int</span>*)v &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zhaozihanzzh.github.io/images/image-20201025001237263.png" alt="image-20201025001237263"></p><p>在 Visual Studio 中用 debug 编译，从外部试图访问局部变量时出现了 -858993460。让我们看一下：-858993460 的二进制表示在补码方案下其实是 -858993460 -(-2^31) + 2^31 = 3435973836 的二进制表示，转成 16 进制正是大名鼎鼎的 0xCCCCCCCC 。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201025003653131.png" alt="image-20201025003653131"></p><p>以上代码在 TDM-GCC 4.9.2 上编译，发现正常读取。不论哪种编译器，使用 void 指针间接访问均可行，这反映系统并不会在局部变量生命周期结束后便急着将它写入新的值，短时间内内存上的值还是不变的。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201025005648503.png" alt="image-20201025005648503"></p><p>不过在 Ubuntu 下用 gcc 9.3.0 编译就不一样了……经 Issues 指点，这可能是 gcc 的一个<a href="https://stackoverflow.com/questions/62203933/c-return-address-of-stack-variable-null">特性</a>。</p><p>总之，这种操作应当避免……</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>进制转换</title>
    <link href="/2020/10/16/base-conversion/"/>
    <url>/2020/10/16/base-conversion/</url>
    
    <content type="html"><![CDATA[<h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><p>（无数的人已经写过这篇了）</p><p>首先介绍一下相关英文：</p><p>进制 Base</p><p>二进制 Binary</p><p>八进制 Octal</p><p>十进制 Decimal</p><p>十六进制 Hexadecimal</p><p>接下来探讨一下其转换。</p><h2 id="Part-1-整数部分"><a href="#Part-1-整数部分" class="headerlink" title="Part 1 整数部分"></a>Part 1 整数部分</h2><p>进制虽然不同，但其表示思想类似，即每一数位上的数字均代表进位的 n 次幂的倍数。因此，我们把其余数制转为十进制是直观容易的：</p><p>FEC (base 16) → 15×16²+14×16+12 (base 10)</p><p>如何将十进制转为其他进制呢？只需逆向以上过程：</p><p>1492 (base 10) → 512×2+64×7+8×2+1×4 (base 10) →2724 (base 8)</p><p>这样，以十进制为桥梁，可以实现进制转换。</p><p>针对十进制转二进制，可以使用长除法，应用“先余为低，后余为高”：（最先得出的余数可以认为代表低数位）</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201016234356469.png" alt="image-20201016234356469"></p><p>将 13 转为二进制，结果为 1101。</p><p>此外，由于除了十进制外的十六进制、八进制的进制数都是 2 的幂，我们也可以从二进制直接转至十六进制或八进制。举个例子，对于 111110110 (base 2) = 766 (base 8)，由于 2³=8 ，从右向左三位三位地分节，将每一节所对应的三位二进制数转为一位八进制后按原节次序排列即可。十六进制同理。</p><p>同样地，也可以用此方法将十六进制、八进制转为二进制，记得补 0 以占位。</p><h2 id="Part-2-小数部分"><a href="#Part-2-小数部分" class="headerlink" title="Part 2 小数部分"></a>Part 2 小数部分</h2><p>一个数的小数部分实质上是当 n 的指数为负数时对整数部分的扩展，对于其他进制转为十进制，这不难理解。但十进制往外转时，除以 n 的负数次幂再取余这一过程可以转成不断对小数部分乘以进制数且按照“先整为高，后整为低”原则取出商数：对于 0.375 (base 10) 转成二进制：</p><p>0.375×2=0.75 -&gt; 0</p><p>0.75×2=1.5     -&gt; 1</p><p>0.5×2=1          -&gt; 1</p><p>化为 0.011 (base 2)。</p>]]></content>
    
    
    <categories>
      
      <category>计算机杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android Studio 模拟器体验 Android Q</title>
    <link href="/2020/10/11/android11/"/>
    <url>/2020/10/11/android11/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-Studio-模拟器体验-Android-Q"><a href="#Android-Studio-模拟器体验-Android-Q" class="headerlink" title="Android Studio 模拟器体验 Android Q"></a>Android Studio 模拟器体验 Android Q</h1><p><img src="https://zhaozihanzzh.github.io/images/image-20201011004247000.png" alt="20201011001"></p><p>​        2020 年 9 月 9 日，Android 11 正式发布了。在这里，使用 Android Studio 自带模拟器对其进行一番轻度把玩。</p><h2 id="Part-1-初步体验"><a href="#Part-1-初步体验" class="headerlink" title="Part 1 初步体验"></a>Part 1 初步体验</h2><p>​        本次更新增强了聊天气泡（然而这里并没有体验），提升了权限方面的保护，在通知面板集成了音乐播放控制，在开发者选项加入对不同屏幕形态的模拟，还增强了电源菜单，修改了启动器部分细节、最近任务后台等等。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011004247007.png" alt="image-20201011004247007"></p><p>正常的通知面板↑</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011004515860.png" alt="image-20201011004515860"></p><p>播放音乐时↑（可能需要 APP 适配？）</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005013961.png" alt="image-20201011005013961"></p><p>设置里可以开启通知历史记录了。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011004646477.png" alt="image-20201011004646477"></p><p>开发者选项，可怕。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011004751292.png" alt="image-20201011004751292"></p><p>电源菜单。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011004842462.png" alt="image-20201011004842462"></p><p>新的最近任务后台。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011004907812.png" alt="image-20201011004907812"></p><p>锁屏（为什么不显示全星期？）</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005121466.png" alt="image-20201011005121466"></p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005136070.png" alt="image-20201011005136070"></p><p>更新的手势（据说那个灵敏度调节有借鉴的成分？）</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005247493.png" alt="image-20201011005247493"></p><p>分享列表可以置顶选中应用了，合理利用应该比较方便，不过据说 Android 9 就有了，10 意外地砍掉了。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005404310.png" alt="image-20201011005404310"></p><p>原生终于有录屏了。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005503015.png" alt="image-20201011005503015"></p><p>“几个月”的权限。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005630444.png" alt="image-20201011005630444"></p><p>时钟好评。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005731378.png" alt="image-20201011005731378"></p><p>应用管理。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005757725.png" alt="image-20201011005757725"></p><p>拨号盘。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005826033.png" alt="image-20201011005826033"></p><p>音量。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005931564.png" alt="image-20201011005931564"></p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005940489.png" alt="image-20201011005940489"></p><p>Pixel 启动器。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011010004781.png" alt="image-20201011010004781"></p><p>模拟器找不到那个“设备控制器”？</p><h2 id="Part-2-娱乐跑分"><a href="#Part-2-娱乐跑分" class="headerlink" title="Part 2 娱乐跑分"></a>Part 2 娱乐跑分</h2><p><img src="https://zhaozihanzzh.github.io/images/image-20201011010147837.png" alt="image-20201011010147837"></p><p>自带输入法怎么有酷安？是我孤陋寡闻么？</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011010254365.png" alt="image-20201011010254365"></p><p>从某安安装安兔兔，无论模拟器设置中图形渲染使用硬件还是软件，GPU 测试均无法运行。那就这样吧。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011010501264.png" alt="image-20201011010501264"></p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011010517240.png" alt="image-20201011010517240"></p><p>Are you okay?</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011010545207.png" alt="image-20201011010545207"></p><p>娱乐大师无法运行……</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011010625076.png" alt="image-20201011010625076"></p><p>感觉 GeekBench 负载好像不太够，每个项目总是 CPU 没跑满就换下一个项目了。不过娱乐兔三十万分的机器怎么就超越了骁龙 865？</p><p>娱乐到此结束……</p>]]></content>
    
    
    <categories>
      
      <category>娱乐</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/09/30/hello-world/"/>
    <url>/2020/09/30/hello-world/</url>
    
    <content type="html"><![CDATA[<p>There is only one heroism in the world: to see the world as it is and to love it.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
