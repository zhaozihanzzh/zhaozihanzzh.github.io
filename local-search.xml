<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>神船 TX6 BIOS 开关独显</title>
    <link href="/2021/08/10/bios-gpu-switch/"/>
    <url>/2021/08/10/bios-gpu-switch/</url>
    
    <content type="html"><![CDATA[<h1 id="神船-TX6-BIOS-开关独显"><a href="#神船-TX6-BIOS-开关独显" class="headerlink" title="神船 TX6 BIOS 开关独显"></a>神船 TX6 BIOS 开关独显</h1><h2 id="Part-1-背景"><a href="#Part-1-背景" class="headerlink" title="Part 1 背景"></a>Part 1 背景</h2><p>神船 TX6-CU5DA/S （蓝天 NK60SB 模具那一代）采用了桌面端 Intel Core i5-10400 CPU（主板采用 H470 芯片组），搭载 NVIDIA GeForce GTX1650 独立显卡，采用双风扇四铜管三出风口散热，且有两个 M.2 2280 的 SSD 接口、1 个 2.5 吋 7mm 硬盘位 ，内存可插拔，使用 16.1 吋 72% NTSC 屏幕，47Whr 的外置电池，150W 适配器。购买之初，笔者没认清自己对于续航的需求，或者对游戏本的续航表现抱有幻想，后来遇到无法充电的场景时屡屡尴尬（续航大约3h？）。</p><p>经过大量实践，调节蓝天 Control Center，改变电源模式，<a href="https://www.bilibili.com/read/cv10682637/">设备管理器禁用独显</a> 均无法彻底扭转这续航。联系逛笔吧的经验，笔者不禁想问，能不能在 BIOS 里禁用独显呢？这样做的效果又怎样呢？如果你也有同样的疑问，不妨往下看。</p><h2 id="Part-2-步骤"><a href="#Part-2-步骤" class="headerlink" title="Part 2 步骤"></a>Part 2 步骤</h2><p>参考<a href="https://bbs.letitfly.me/d/1151">神船 NK60SB (NKx0Sx) Insyde BIOS 折腾记</a> ，将 <code>IGD or MSHybird or DISCRETE Switch</code> 改为 <code>IGD</code> 即可。（改回来的时候别错改成 <code>DISCRETE</code>，可以参考原作者的帖子，这机器好像只能混合输出，没法独显直连）</p><p>如果链接失效，可以看<a href="https://zhaozihanzzh.github.io/images/website_biosgpu_20210810.jpeg">截图</a>。</p><h2 id="Part-3-总结"><a href="#Part-3-总结" class="headerlink" title="Part 3 总结"></a>Part 3 总结</h2><p>屏蔽独显后，续航改善明显。在某次 30 分钟使用后，电量从 80% 下降至 69%。看看这颗 TDP 65W （单烤也能到这个值）的桌面级 CPU，16.1 吋的屏幕，以及 47Whr 的电池，笔者感觉这样的续航还是可以接受的。</p><p>在过去的 2020 年，想要找一台 Intel CPU 性能释放足够强，屏幕大，价格低的机器，低价位选择并不多。这台机器能否成为披着游戏本外衣的程序员本呢？</p><p>也许，每个人都有自己的答案。</p><p>在笔者看来，这台机器有以下一些特点：</p><ul><li>性能释放强，单烤（Stress FPU）CPU 70+W。</li><li>扩展性较好，三硬盘位。</li><li>16.1吋，屏幕大。</li><li>全高方向键。</li><li>Linux 支持不算烂。</li><li>神船原装群联主控 OEM 固态是减分项，<a href="https://tieba.baidu.com/p/7442648091?pn=3">据传</a>（76楼） 2020 年年底到 2021 年年初有一批固态掉盘较为严重。</li><li>不支持 PD 充电。</li><li>Intel(R) Wireless-AC 9462 无线网卡，不支持 WiFi-6。</li></ul><p>关于电池，同样三硬盘位的机器，宏碁暗影骑士·擎（15.6吋）电池为 57Whr，神舟 TX8-CU5DA（16.1吋）为62Whr，神舟 TX9-CA5DP （16.1吋）电池为 55Whr，TX8-笔者感觉 TX6 这个电池还能再大一点，获得更好续航表现。</p><p>曾经，在蓝天模具的加持下，“神船大法保平安”广为流传，但最近的笔记本市场风云激荡，笔者愚见，神船更应该继续加油才能乘风破浪，驶向深蓝。</p>]]></content>
    
    
    <categories>
      
      <category>娱乐</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>概率论</title>
    <link href="/2021/06/07/probability-theory/"/>
    <url>/2021/06/07/probability-theory/</url>
    
    <content type="html"><![CDATA[<h2 id="一、随机事件与概率"><a href="#一、随机事件与概率" class="headerlink" title="一、随机事件与概率"></a>一、随机事件与概率</h2><h3 id="1-随机现象与随机试验"><a href="#1-随机现象与随机试验" class="headerlink" title="1.随机现象与随机试验"></a>1.随机现象与随机试验</h3><p>基本事件：每一个可能出现的实验结果，用 <script type="math/tex">w_i</script> 表示。必然事件常用 <script type="math/tex">\Omega</script> 表示，不可能事件常用 <script type="math/tex">\emptyset</script> 表示。</p><p>事件的运算：和 <script type="math/tex">A\bigcup{B}</script> ，差 <script type="math/tex">A-B</script> 或 A\B ，交（积） <script type="math/tex">A\bigcap{B}</script> 或 <script type="math/tex">AB</script> 。</p><p>互不相同事件：不同时发生；对立事件：“事件A不发生”这一事件。</p><h3 id="2-概率的定义"><a href="#2-概率的定义" class="headerlink" title="2.概率的定义"></a>2.概率的定义</h3><p>古典概型（<script type="math/tex">\Omega</script> 是有限集）：<script type="math/tex">P(A)=\frac{n_A}{n}</script>，几何概型：<script type="math/tex">P(A)=\frac{G 的几何度量}{\Omega 的几何度量}</script>。</p><p>概率的公理化定义：基本事件空间 <script type="math/tex">\Omega</script> 是所有基本事件构成的集合，事件域为 <script type="math/tex">F</script> （已有的事件怎么操作都跑不出去），概率测度 <script type="math/tex">P</script> ，则 <script type="math/tex">(\Omega, F, P)</script> 为概率空间。</p><p>如果 <script type="math/tex">P(A) = 0</script> ，A 未必是不可能事件。</p><p>概率加法公式：<script type="math/tex">P(\bigcup\limits_{i=1}^{n}A_i)=\sum\limits_{i=1}^{n}P(A_i)-\sum\limits_{1\leq{i}<j\leq{n}}^{n}P(A_{i}A_{j})+\sum\limits_{1\leq{i}<j<k\leq{n}}^{n}P(A_{i}A_{j}A_{k})-\cdots+(-1)^{n-1}P(A_{1}A_{2}\cdots A_{n})</script></p><h3 id="3-条件概率"><a href="#3-条件概率" class="headerlink" title="3.条件概率"></a>3.条件概率</h3><p>条件概率：已知某事件发生，另一事件发生（可用来构造概率空间）</p><p>乘法公式：<script type="math/tex">P(B|A)=\frac{P(AB)}{P(A)}</script>，推广：<script type="math/tex">P(A_1A_2\cdots A_n)=P(A_1)P(A_2|A_1)P(A_3|(A_1A_2))\cdots P(A_n|(A_1A_2\cdots A_n))</script></p><p>全概率公式：先化整为零，再聚零为整：<script type="math/tex">B_i</script> 为 <script type="math/tex">B</script> 的一个划分，则当 <script type="math/tex">A\subset B</script> ，<script type="math/tex">B_i</script> 是 <script type="math/tex">B</script> 的一个划分，此时有 <script type="math/tex">P(A) = \sum\limits_{i=1}^{n}P(B_i)P(A|B_i)</script> 。(6 个黑球，4 个白球，第二次摸到的是白球的概率？)</p><p>贝叶斯公式：若 <script type="math/tex">P(B_i)>0</script> ，<script type="math/tex">B_iB_j = \emptyset</script>，<script type="math/tex">A\subset{\bigcup\limits_{i=1}^{\infty}B_i}</script> ，<script type="math/tex">P(A)>0</script> ，则 <script type="math/tex">P(B_j|A) = \frac{P(B_j)P(A|B_j)}{\sum\limits_{i=1}^{\infty}P(B_i)P(A|B_i)}</script>。（甲乙丙三车间产量占比已知，次品率已知，现在查出一个次品，是甲车间生产的概率？）</p><h3 id="4-事件独立性"><a href="#4-事件独立性" class="headerlink" title="4.事件独立性"></a>4.事件独立性</h3><p>若 <script type="math/tex">P(AB) = P(A)P(B)</script>，则 A、B 相互独立。</p><p>三个事件相互独立（<script type="math/tex">P(AB) = P(A)P(B)</script>，<script type="math/tex">P(BC) = P(B)P(C)</script>，<script type="math/tex">P(AC) = P(A)P(C)</script>，<script type="math/tex">P(ABC) = P(A)P(B)P(C)</script>）强于两两独立。</p><h3 id="5-独立实验"><a href="#5-独立实验" class="headerlink" title="5.独立实验"></a>5.独立实验</h3><p>n 重伯努利试验：试验只有两种可能结果，重复 n 次。</p><p>伯努利定理：成功概率 p 时成功 k 次概率 <script type="math/tex">b(k;n,p)=C^{k}_{n}p^{k}(1-p)^{n-k}</script> ，称为伯努利数。</p><h2 id="二、一维随机变量及其分布"><a href="#二、一维随机变量及其分布" class="headerlink" title="二、一维随机变量及其分布"></a>二、一维随机变量及其分布</h2><h3 id="1-随机变量"><a href="#1-随机变量" class="headerlink" title="1.随机变量"></a>1.随机变量</h3><p>对实数集上的任意 x ，有 <script type="math/tex">\{\omega|X(\omega)\leq{x}\}\in{F}</script> ，称 <script type="math/tex">X(\omega)</script> 为随机变量。（这个事件必须在事件域 F 中）</p><p>随机变量 X 的分布函数 <script type="math/tex">F_x(x)=P(X\leq{x})</script> ，则 <script type="math/tex">P(X<{x})=F_x(x-0)</script> （左极限），分布函数右连续，但不一定左连续，<script type="math/tex">P(X={x})=F_x(x)-F_x(x-0)</script> ，<script type="math/tex">F_x(x)</script> 为单调递增函数，且在负无穷、正无穷取值分别为 0、1。</p><h3 id="2-一维离散型随机变量"><a href="#2-一维离散型随机变量" class="headerlink" title="2.一维离散型随机变量"></a>2.一维离散型随机变量</h3><p>离散型随机变量的取值为有限个或可列多个。为了直观，可以使用表格列出分布列。接下来介绍几种概率分布：</p><p>a.两点分布（0-1分布）：</p><div class="table-container"><table><thead><tr><th>X</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>P</td><td>1-p</td><td>p</td></tr></tbody></table></div><p>b.二项分布 <script type="math/tex">X\sim{B(n, p)}</script></p><p>n 重伯努利试验，成功概率 p，随机变量 X 为成功次数</p><p>记 <script type="math/tex">k_0=Int[(n+1)p]</script>，当 <script type="math/tex">k=k_0</script> 时 <script type="math/tex">b(k;n,p)</script> 最大；若 (n+1)p 为整数，则 <script type="math/tex">b(k_0;n,p)=b(k_0-1;n,p)</script> 。</p><p>c.泊松分布 <script type="math/tex">X\sim{P(\lambda)}</script>，参数 <script type="math/tex">\lambda>0</script></p><p>$P(X=k)=\frac{e^{-\lambda}\lambda^k}{k!}$ ，其中又有泊松定理：<script type="math/tex">X_n\sim{B(n,p_n)}</script>，其中 <script type="math/tex">p_n</script> 与 <script type="math/tex">n</script> 有关，且 <script type="math/tex">\lim\limits_{n\rightarrow\infty}np_n=\lambda>0</script> ，此时有 <script type="math/tex">\lim\limits_{n\rightarrow\infty}P(x_n=k)=\frac{e^{-\lambda}\lambda^k}{k!}</script> ，k 取自然数，表示的意义为：把一段时间分割为 <script type="math/tex">n</script> 段，每段时间内某事件发生的概率为 <script type="math/tex">p_n</script> （由于每段时间很小，认为事件不会在这样短的时间内发生两次及以上），由二项分布，乘积 <script type="math/tex">\lambda</script> 为这段时间事件发生次数的期望，当把每段时间无限地分割下去时，二项分布实际上就成了泊松分布。因此，还有泊松近似公式：</p><p>当二项分布 n 很大，p 很小（一般取 <script type="math/tex">n\geq{10}</script>，<script type="math/tex">p\leq{0.1}</script> ）时，<script type="math/tex">P(X=k)\approx{\frac{e^{-\lambda}\lambda^k}{k!}}</script>。</p><p>d.几何分布 $X\sim{Geo(p)}$</p><p>$P(X=k)=g^{k-1}p=g(k;p)$ 表示前 (k - 1) 次试验未成功，第 k 次首次成功。</p><p>几何分布有无记忆性，已知前 k 次还未成功，则从 (k + 1) 次，首次成功出现在哪一次与 k 无关，即 <script type="math/tex">P(X=k+n|X>k)=P(x=n)</script>。（彼此独立）</p><h3 id="3-一维连续型随机变量"><a href="#3-一维连续型随机变量" class="headerlink" title="3.一维连续型随机变量"></a>3.一维连续型随机变量</h3><p>若存在 <script type="math/tex">f(x)>0</script> 使得对任意 x 有 <script type="math/tex">F(x)=\int_{-\infty}^{x}f(t)dt</script>，那么 <script type="math/tex">f(x)</script> 为 x 的概率密度函数（在不至于混淆时简称密度函数）。显然，在某点上概率分布函数一定是 0，因此我们需要讨论随机变量落在某区间上的概率，为了便于描述概率分布函数与 x 轴围成图形的面积，引入密度函数。易知，<script type="math/tex">\int_{-\infty}^{+\infty}f(x)dx=1</script> 。同样地，介绍几种概率分布：</p><p>a.均匀分布 <script type="math/tex">x\sim{U[a,b]}</script></p><p>a&lt;b，<script type="math/tex">f(x)=\left\{\begin{matrix}\frac{1}{b-a},x\in[a,b]\\0,x\notin[a,b]\end{matrix}\right.</script></p><p>显然，当 <script type="math/tex">a\leq{x}\leq{b}</script> 时 <script type="math/tex">F(x)=\frac{x-a}{b-a}</script>。（“线性”）</p><p>b.指数分布 <script type="math/tex">X\sim{E(X)}</script></p><p> x 的密度函数满足 <script type="math/tex">f(x)=\left\{\begin{matrix}\lambda{e}^{-\lambda{x}},x>0\\0,x\leq0\end{matrix}\right.</script> ，分布函数 <script type="math/tex">F(x)=\left\{\begin{matrix}1-e^{-\lambda{x}}, x>0\\0, x\leq{0}\end{matrix}\right.</script></p><p>指数分布也与泊松分布关系密切，后者表示的是某事件在一定时间中的发生次数的概率分布，而前者是某事件两次发生之间时间间隔的概率分布：设某段时间长为 x，在这段时间内某事件发生次数为 <script type="math/tex">\lambda{x}</script>，那么在这段时间中一次也不发生概率为 <script type="math/tex">\frac{e^{-\lambda{x}}(\lambda{x})^0}{0!}=e^{-\lambda{x}}</script>，那么在这段时间内发生一次及以上该事件的概率为 <script type="math/tex">1-e^{-\lambda{x}}</script>，即：时间间隔小于这个 x 的概率为 <script type="math/tex">1-e^{-\lambda{x}}</script>，这就是指数分布在时间间隔大于 0 时的分布函数。</p><p>指数分布具有“无记忆性”，即 <script type="math/tex">P(X>k+n|X>k)=P(X>n)</script>。</p><p>c.正态分布 <script type="math/tex">X\sim{N}(\mu, \sigma^2)</script></p><p>$f(x)=\frac{1}{\sqrt{2\pi}\sigma}e^-\frac{(x-\mu)^2}{2\sigma^2}$，分布函数为其积分。又有标准正态分布 <script type="math/tex">\mu=0,\sigma=1</script>，记其密度函数为 <script type="math/tex">\varphi(x)</script>，分布函数为 <script type="math/tex">\Phi(x)</script>，查表时要注意 <script type="math/tex">\Phi(x)-\frac{1}{2}=\frac{1}{2}-\Phi(-x)</script>，即概率分布关于 <script type="math/tex">\frac{1}{2}</script> 对称。</p><p>正态分布标准化：对于 <script type="math/tex">X\sim{N(\mu, \sigma^2)}</script>，有 <script type="math/tex">\frac{x-\mu}{\sigma}\sim{N(0,1)}</script>。</p><h3 id="4-一维离散型随机变量函数的分布"><a href="#4-一维离散型随机变量函数的分布" class="headerlink" title="4.一维离散型随机变量函数的分布"></a>4.一维离散型随机变量函数的分布</h3><p>X 经某函数映射到 Y，那么求 Y 取某个值的概率时需要合并使 Y 取这个值的所有 X 的概率。</p><h3 id="5-一维连续型随机变量函数的分布"><a href="#5-一维连续型随机变量函数的分布" class="headerlink" title="5.一维连续型随机变量函数的分布"></a>5.一维连续型随机变量函数的分布</h3><p>需要利用分布函数和 Y 与 X 的关系，将 Y 小于等于某值的概率解不等式转为 X 取某区间的概率，之后如果需要求密度函数，直接对所得的分布函数求导即可，需要注意若 <script type="math/tex">F_Y(y)=\int_{h_2(y)}^{h_1(y)}g(x)dx</script>，那么 <script type="math/tex">F_Y'(y)=g(h_1(y))h_1'(y)-g(h_2(y))h_2'(y)</script>，<script type="math/tex">\pm\infty</script> 导数看做 0。</p><h2 id="三、二维随机向量及其分布"><a href="#三、二维随机向量及其分布" class="headerlink" title="三、二维随机向量及其分布"></a>三、二维随机向量及其分布</h2><p>我们只讨论二维随机向量。</p><h3 id="1-随机向量联合分布函数与联合密度函数（连续型）"><a href="#1-随机向量联合分布函数与联合密度函数（连续型）" class="headerlink" title="1.随机向量联合分布函数与联合密度函数（连续型）"></a>1.随机向量联合分布函数与联合密度函数（连续型）</h3><p>随机向量联合分布函数 <script type="math/tex">F_{X_1,X_2}(x_1, x_2)=P(X_1\leq{x_1},X_2\leq{x_2})</script>，有 <script type="math/tex">F(-\infty, y)=F(x,-\infty)=F(-\infty, -\infty)=0</script>。</p><p>若 <script type="math/tex">(X,Y)</script> 所有取值只有有限个或可列个，其为离散型随机变量；若存在 <script type="math/tex">f(x,y)</script> 使得对任意 x, y，有 <script type="math/tex">F_{X,Y}(x,y)=\int_{-\infty}^{y}\int_{-\infty}^{x}f(u,v)dudv</script>，那么 <script type="math/tex">(X,Y)</script> 为连续型随机变量，称 <script type="math/tex">f(x,y)</script> 为它的联合概率密度函数（或者直接称为分布密度函数）。</p><h3 id="2-随机向量边缘分布函数与边缘密度函数（连续型）"><a href="#2-随机向量边缘分布函数与边缘密度函数（连续型）" class="headerlink" title="2.随机向量边缘分布函数与边缘密度函数（连续型）"></a>2.随机向量边缘分布函数与边缘密度函数（连续型）</h3><p>二维随机向量边缘分布为其中某个随机变量取某个值的概率（相当于在表格“边缘”的那一栏），对于离散型二维随机向量，有<script type="math/tex">P(Y=y_j)=\sum\limits_ip_{ij}</script>；对于连续型二维随机变量，其边缘分布函数为 <script type="math/tex">F_X(x)=F(x, +\infty)=\lim\limits_{y\rightarrow+\infty}F(x,y)</script>，其边缘密度函数为 <script type="math/tex">f_X(x)=\int_{-\infty}^{+\infty}f_{X,Y}(x,y)dy</script> 。（由联合分布确定其边缘分布，但反之不一定，要考虑其独立性）</p><h3 id="3-随机变量的相互独立性"><a href="#3-随机变量的相互独立性" class="headerlink" title="3.随机变量的相互独立性"></a>3.随机变量的相互独立性</h3><p>若可判断 X、Y 取值互不影响，或对任意 x, y ，有 <script type="math/tex">F(x,y)=F(x)F(y)</script>，或离散型有 <script type="math/tex">p_{ij}=p_{i\cdot}p_{\cdot{j}}</script>，或连续型有 <script type="math/tex">f(x,y)=f_X(x)f_Y(y)</script>，那么 X、Y 相互独立。此时边缘分布可确定联合分布。</p><h3 id="4-二维均匀分布"><a href="#4-二维均匀分布" class="headerlink" title="4.二维均匀分布"></a>4.二维均匀分布</h3><p>有界区域 D 的面积为 <script type="math/tex">S_D</script>，<script type="math/tex">f(x,y)=\left\{\begin{matrix}\frac{1}{S_D},(x,y)\in{D}\\0,(x,y)\notin{D}\end{matrix}\right.</script>。可以用画图辅助。</p><h3 id="5-二维正态分布"><a href="#5-二维正态分布" class="headerlink" title="5.二维正态分布"></a>5.二维正态分布</h3><p>$(X,Y)\sim{N(\mu_1,\mu_2,\sigma^2_1,\sigma^2_2,\rho)}$，其边缘分布是一维正态分布，<script type="math/tex">\rho</script> 为两变量的相关系数。（“物以类聚”，$\mu$ 在一起，$\sigma$ 在一起）</p><h3 id="6-二维随机向量函数的概率分布函数（离散型）与概率密度函数（连续型）"><a href="#6-二维随机向量函数的概率分布函数（离散型）与概率密度函数（连续型）" class="headerlink" title="6.二维随机向量函数的概率分布函数（离散型）与概率密度函数（连续型）"></a>6.二维随机向量函数的概率分布函数（离散型）与概率密度函数（连续型）</h3><p>$Z=g(x,y)$ 为一个二元函数，研究其分布：</p><p>离散型与一维类似，其概率分布函数直接将每个可能的 <script type="math/tex">(X,Y)</script> 概率累加。</p><p>对于连续型，有 <script type="math/tex">F_Z(z)=P(g(X,Y)\leq{Z})=\iint\limits_{g(x,y)\leq{z}}f(x,y)dxdy</script>，但我们在这里只讨论随机向量函数为两随机变量之和的情况：令 <script type="math/tex">y=u-x</script>，则上式可写成 <script type="math/tex">\iint\limits_{x+y\leq{z}}f(x,y)dxdy=\int_{-\infty}^{+\infty}\int_{-\infty}^{z-x}f(x,y)dydx=\int_{-\infty}^{+\infty}\int_{-\infty}^{z}f(x,u-x)dudx=\int_{-\infty}^{z}\int_{-\infty}^{+\infty}f(x,u-x)dxdu</script>，求导得 <script type="math/tex">f_Z(z)=\int_{-\infty}^{+\infty}f(x, z-x)dx</script>。同理，<script type="math/tex">f_Z(z)=\int_{-\infty}^{+\infty}f(z-y, y)dy</script>。</p><p>特别地，当 x、y相互独立时，上式变为卷积公式 <script type="math/tex">f_Z(z)=\int_{-\infty}^{+\infty}f_X(x)f_Y(z-x)dx=f_Z(z)=\int_{-\infty}^{+\infty}f_X(z-y)f_Y(y)dy</script></p><p>事实上，X、Y 相互独立时， <script type="math/tex">X\sim P(\lambda_1)</script>，<script type="math/tex">Y\sim P(\lambda_2)</script>，则 <script type="math/tex">X+Y\sim P(\lambda_1+\lambda_2)</script>；<script type="math/tex">X\sim B(m,p)</script>，<script type="math/tex">Y\sim B(n,p)</script>，则 <script type="math/tex">X+Y\sim B(m+n,p)</script>；<script type="math/tex">X\sim{N}(\mu_1, \sigma^2_1)</script>，<script type="math/tex">Y\sim{N}(\mu_2, \sigma^2_2)</script>，则 <script type="math/tex">X+Y\sim{N}(\mu_1+\mu_2, \sigma^2_1+\sigma^2_2)</script>。更进一步地，有限个独立的正态分布的随机变量线性组合仍然是正态分布。</p><h2 id="四、随机变量的数字特征"><a href="#四、随机变量的数字特征" class="headerlink" title="四、随机变量的数字特征"></a>四、随机变量的数字特征</h2><h3 id="1-数学期望"><a href="#1-数学期望" class="headerlink" title="1.数学期望"></a>1.数学期望</h3><p>a.一维随机变量数学期望的计算</p><p>对于离散型，当级数 <script type="math/tex">\sum\limits_{i=1}^{\infty}|x_i|p_i</script> 收敛，则 X 期望存在，<script type="math/tex">E(X)=\sum\limits_{i=1}^{\infty}x_ip_i</script>。</p><p>对于连续型，当 <script type="math/tex">\int_{-\infty}^{+\infty}|x|f(x)dx</script> 收敛时，有期望 <script type="math/tex">E(X)=\int_{-\infty}^{+\infty}xf(x)dx</script> 。发散则不存在，如柯西分布、圣彼得堡悖论。</p><p>二项分布：<script type="math/tex">E(X)=np</script>；泊松分布：<script type="math/tex">E(X)=\lambda</script>；几何分布 <script type="math/tex">E(X)=\frac{1}{p}</script>；均匀分布为中点；正态分布 <script type="math/tex">E(X)=\mu</script> ；指数分布 <script type="math/tex">E(X)=\frac{1}{\lambda}</script> 。</p><p>b.一维随机变量函数的数学期望</p><p>离散型，<script type="math/tex">E(g(X))=\sum\limits_{k}g(x_k)P(X=x_k)</script> （要求 <script type="math/tex">\sum\limits_{k}|g(x_k)|P(X=x_k)<+\infty</script>）</p><p>连续型：<script type="math/tex">\int_{-\infty}^{+\infty}|g(x)|f(x)dx</script> 收敛时，有期望 <script type="math/tex">E(g(x))=\int_{-\infty}^{+\infty}g(x)f(x)dx</script> 。</p><p>c.二维随机变量函数的数学期望</p><p>离散型：与一维类似，将取值与对应的概率乘积求和</p><p>连续型：若<script type="math/tex">\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}g(x,y)f(x,y)dydx</script> 绝对收敛，则期望存在。</p><p>特别地，<script type="math/tex">E(X)=\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}xf(x,y)dydx=\int_{-\infty}^{+\infty}x[\int_{-\infty}^{+\infty}f(x,y)dy]dx=\int_{-\infty}^{+\infty}xf_X(x)dx</script></p><p>d.数学期望的部分性质</p><p>如果 <script type="math/tex">\xi</script> 与 <script type="math/tex">\eta</script> 相互独立，<script type="math/tex">E(\xi\eta)=E(\xi)E(\eta)</script>；但反之不一定。</p><h3 id="2-随机变量的矩"><a href="#2-随机变量的矩" class="headerlink" title="2.随机变量的矩"></a>2.随机变量的矩</h3><p>a.相关定义</p><p>记 <script type="math/tex">E[(X-c)^k]</script> 为 X 关于 c 的 k 阶矩，当 c = 0 时为 k 阶原点矩 <script type="math/tex">a_k</script>，<script type="math/tex">c=E(X)</script> 时为 k 阶中心矩 <script type="math/tex">\mu_k</script>。（$\mu$ 有些像以中心为轴左右对称）</p><p>记 <script type="math/tex">\mu_2</script> 为方差。（X 必须有有限的期望）</p><p>$\frac{\mu_3}{\mu^{\frac{3}{2}}_2}$ 为偏度系数，正态分布偏度系数为 0，绝对值越大，离正态分布偏差越大，大于 0 说明右偏。</p><p>$\frac{\mu_4}{\mu^{2}_2}$ 为峰度系数，正态分布为 3。（“偏锋”，从 3 到 4）</p><p>b.随机变量的方差的计算</p><p>$Var(X)=E(X^2)-[E(X)]^2$ （“由内而外”）</p><script type="math/tex; mode=display">Var(cX)=c^2Var(X)</script><p>对于二项分布，其方差有 <script type="math/tex">Var(X)=np(1-p)=npq</script>；泊松分布方差 <script type="math/tex">Var(X)=\lambda</script>；几何分布方差 <script type="math/tex">Var(X)=\frac{q}{p^2}</script>；均匀分布方差 <script type="math/tex">Var(X)=\frac{(b-a)^2}{12}</script>；正态分布方差 <script type="math/tex">Var(X)=\sigma^2</script>；指数分布方差 <script type="math/tex">Var(X)=\frac{1}{\lambda^2}</script> 。</p><h3 id="3-二维随机向量的协方差"><a href="#3-二维随机向量的协方差" class="headerlink" title="3.二维随机向量的协方差"></a>3.二维随机向量的协方差</h3><p>定义 <script type="math/tex">Cov(X,Y)=E\{[X-E(X)][Y-E(Y)]\}</script>，则有 <script type="math/tex">Var(X)=Cov(X,X)</script>，<script type="math/tex">Cov(aX+bY,Z)=aCov(X,Z)+bCov(Y,Z)</script>；若 X、Y 独立，那么其协方差为 0，但反之不一定。</p><script type="math/tex; mode=display">Var(X+Y)=Var(X)+Var(Y)+2Cov(X,Y)</script><p>注意 $Cov(X,-Y)=-Cov(X,Y)$，有 $Var(X-Y)=Var(X)+Var(Y)-2Cov(X,Y)$。</p><h3 id="4-相关系数"><a href="#4-相关系数" class="headerlink" title="4.相关系数"></a>4.相关系数</h3><p>当 <script type="math/tex">Var(X)>0</script>，<script type="math/tex">Var(Y)>0</script> 时，定义相关系数 <script type="math/tex">r(X,Y)=\frac{Cov(X,Y)}{\sqrt{Var(X)Var(Y)}}</script> （也可用 <script type="math/tex">\rho</script>），其绝对值总是小于等于 1。当 <script type="math/tex">\rho=0</script> 时，两变量无线性关系；当 <script type="math/tex">\rho=1</script> 时严格正相关，当 <script type="math/tex">\rho=-1</script> 时严格负相关。</p><p>由协方差的性质，当 X、Y 独立时，其相关系数等于 0，但反之不一定成立。也就是说，X、Y 独立，则两者一定不相关，但反之不一定。不过，<script type="math/tex">(X,Y)</script> 服从二维正态分布时，反之也成立。</p><h6 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h6><p><a href="https://zhuanlan.zhihu.com/p/261961315">https://zhuanlan.zhihu.com/p/261961315</a></p><p><a href="https://www.jianshu.com/p/6ee90ba47b4a">https://www.jianshu.com/p/6ee90ba47b4a</a></p><p><a href="https://www.zhihu.com/question/26441147/answer/429569625">https://www.zhihu.com/question/26441147/answer/429569625</a></p><p><a href="https://zhuanlan.zhihu.com/p/36555178">https://zhuanlan.zhihu.com/p/36555178</a></p>]]></content>
    
    
    <categories>
      
      <category>概率论与数理统计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ 类的成员函数访问该类的私有数据成员</title>
    <link href="/2021/05/21/cpp-private/"/>
    <url>/2021/05/21/cpp-private/</url>
    
    <content type="html"><![CDATA[<h1 id="C-类的成员函数访问该类的私有数据成员"><a href="#C-类的成员函数访问该类的私有数据成员" class="headerlink" title="C++ 类的成员函数访问该类的私有数据成员"></a>C++ 类的成员函数访问该类的私有数据成员</h1><p>知乎有<a href="https://www.zhihu.com/question/51218892">同款问题</a>。</p><p>类的成员函数访问该类的私有数据成员时，不因为该私有数据成员不是 this 指针指向的对象持有的而禁止访问。这种控制是基于类的，而不是对象层面的。</p><p>这样的代码将是可以编译的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Object</span> &#123;</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Object</span>(<span class="hljs-keyword">int</span> arg):<span class="hljs-built_in">num</span>(arg) &#123;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_priv</span><span class="hljs-params">(Object)</span></span>;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-keyword">int</span> num;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Object::get_priv</span><span class="hljs-params">(Object arg)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> arg.num;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多元函数积分学</title>
    <link href="/2021/05/01/multivarintegral/"/>
    <url>/2021/05/01/multivarintegral/</url>
    
    <content type="html"><![CDATA[<h1 id="多元函数积分学"><a href="#多元函数积分学" class="headerlink" title="多元函数积分学"></a>多元函数积分学</h1><h2 id="零、定积分"><a href="#零、定积分" class="headerlink" title="零、定积分"></a>零、定积分</h2><p>个人的总结先从定积分开始：定积分形如 <script type="math/tex">\int_{a}^{b}f(x)dx</script> ，积分域是一条线段，被积函数 <script type="math/tex">f(x)</script> 是要沿着这条线段（积分域中微小的量）积累的量的函数。如：所谓“曲边梯形的面积”问题中，可以把竖直方向上的长度看成是要被积累的量，沿着线段（x 轴）积累所得。</p><p>计算方法：牛顿-莱布尼茨公式。</p><h2 id="一、二重积分"><a href="#一、二重积分" class="headerlink" title="一、二重积分"></a>一、二重积分</h2><p>对于被积函数是二元函数的情况，使用二重积分来将微小量（小区域）上的被积函数值积累起来。二重积分形如<script type="math/tex">\iint\limits_{D}f(x, y)d\sigma</script>，一般在 <script type="math/tex">xOy</script> 平面内，由于是二重积分，书写成两个积分号。这里所有积分得出的都是一个数值，不是向量值。</p><p>计算方法：看成 <script type="math/tex">x-</script> 型区域或 <script type="math/tex">y-</script> 型区域；换元积分；利用极坐标。需要注意的是，由于 <script type="math/tex">d\sigma = dxdy = dx(u, v)dy(u, v)</script> ，换元时要借助雅可比行列式。积分时最好画出被积区域的图像，把“固定”的一个变量书写在左侧的积分号处，把实质上先积分的变量放在右侧，从右往左积分时上下限的字母（积分的“维度”）越来越少，这是因为随着积分从右往左的进行，右侧的积分已经在上下限中包含了左侧上下限不写的字母的边界形状信息。</p><p>如果积分域字母，以 <script type="math/tex">x</script> 为例，具有对称性，当 <script type="math/tex">f(-x, y)=f(x, y)</script> 时，可以把积分域缩减到右侧，将所得的值乘以 2 ；当 <script type="math/tex">f(-x, y)=-f(x, y)</script> 时，关于 <script type="math/tex">y</script> 轴对称的两侧积分域的积分值相抵消。</p><h2 id="二、三重积分"><a href="#二、三重积分" class="headerlink" title="二、三重积分"></a>二、三重积分</h2><p>形如 <script type="math/tex">\iiint\limits_{\Omega}f(x, y, z)dV</script> ，被积函数是三元函数，需要遍历（三维）区域的每个微小的体积量.</p><p>计算方法：直角坐标系：先单后重法（假设高度是用一根顶天花板立地板的竿子测量，把这竿子的高度用位置坐标 x、y 表示出来，再拿着竿子跑遍房间就行）；先重后单法（先积分出房间在高度 z 处的面积，即一层瓷砖覆盖房间的这个高度，再用瓷砖把房间填满）；换元，主要是球面坐标、柱坐标。</p><h2 id="三、第一类曲线积分"><a href="#三、第一类曲线积分" class="headerlink" title="三、第一类曲线积分"></a>三、第一类曲线积分</h2><p>形如 <script type="math/tex">\int_{C}f(x, y, z)ds</script> ，相比定积分，被积函数是个三元函数，也就是空间的一个场，描述了要积累的属性在空间某点的值（定积分也可以看成是三元函数，但由于沿着坐标轴积分，把剩下两个维度忽略了），函数值还是数，但积分域从定积分的线段改成了曲线。</p><p>计算方法：通过换元，把曲线变换成直的，再调用定积分。要注意换元时弧长微分 <script type="math/tex">ds=\sqrt{x'^2(t)+y'^2(t)+z'^2(t)} dt</script> ，无法把 s 分解，也不用再求导。</p><h2 id="四、第二类曲线积分"><a href="#四、第二类曲线积分" class="headerlink" title="四、第二类曲线积分"></a>四、第二类曲线积分</h2><p>第二类曲线积分与第一类曲线积分有较大的差别。第二类曲线积分中被积分的函数是个向量值函数（有方向的场），积分所沿着的曲线也是有向的，沿曲线方向依次取得各点的向量值函数在累加时采用的不是矢量求和，而是与曲线方向的数量积的和，记作 <script type="math/tex">\int_{L}\pmb{f}\cdot{d\pmb{s}}</script> 。</p><p>计算方法：由于被积函数、曲线通常在 <script type="math/tex">xOy</script> 坐标系中表示，可以将被积函数、曲线用 <script type="math/tex">\vec{i}</script>、<script type="math/tex">\vec{j}</script>、<script type="math/tex">\vec{k}</script> 三个分方向表示出来，由于 <script type="math/tex">{d\pmb{s}} = \pmb{e_T}ds = \frac{1}{\sqrt{x'(t)^2+y'(t)^2+z'(t)^2}}\{x'(t), y'(t)\}\cdot{\sqrt{x'(t)^2+y'(t)^2+z'(t)^2}dt} = \{x'(t), y'(t)\}</script> ，可得出对坐标的曲线积分 <script type="math/tex">\int_{L}P(x, y)dx+Q(x, y)dy</script> ，再进行换元即可。</p><h2 id="五、第一类曲面积分"><a href="#五、第一类曲面积分" class="headerlink" title="五、第一类曲面积分"></a>五、第一类曲面积分</h2><p>二重积分是在 <script type="math/tex">xOy</script> 上进行积分的，而第一类曲面积分将积分域提升到了空间中的曲面。第一类曲面积分形如 <script type="math/tex">\iint\limits_{S}f(x, y, z)dS</script> ，被积函数是三元非向量值函数。</p><p>计算方法：把曲面投影（“拍扁”）到一个平面上，如取 <script type="math/tex">xOy</script> 平面承接投影，则需要把 z 用 x 和 y 表示出来以正确表达原平面，即要有 <script type="math/tex">z=f(x, y)</script> ，移项可得 <script type="math/tex">f(x, y) - z = 0</script> ，求导得法向量 <script type="math/tex">\{f_x, f_y, -1\}</script> ，法向量与 z 轴夹角的余弦值 <script type="math/tex">\cos{\gamma}=\frac{1}{\sqrt{f_x^2+f_y^2+1}}</script> ，可得 <script type="math/tex">dS={\sqrt{f_x^2+f_y^2+1}}dxdy</script>，可化为投影到 <script type="math/tex">xOy</script> 平面的二重积分。</p><h2 id="六、第二类曲面积分"><a href="#六、第二类曲面积分" class="headerlink" title="六、第二类曲面积分"></a>六、第二类曲面积分</h2><p>第二类曲面积分与第二类曲线积分有着某种联系，同样是向量值三元函数形成的场，但积分域是有向的空间曲面，其形如 <script type="math/tex">\iint\limits_{S}\vec{f}(x, y, z)d\vec{S}=\iint\limits_{S}(P\cos{\alpha}+Q\cos{\beta}+R\cos{\gamma})dS=\iint\limits_{S}Pdxdy+Qdydz+Rdzdx</script> ，流量可看成流量微元在指定方向曲面上的第二类曲面积分。</p><p>计算方法：虽然与第一类曲面积分同属于曲面积分，但由于被积函数（场）是向量值的，不能仅仅投影到 <script type="math/tex">xOy</script> 等一个平面了事，那样另外两个方向上的分量 <script type="math/tex">Q\vec{j}</script>、<script type="math/tex">R\vec{k}</script> 无法计算。为了正确地处理，需要向 <script type="math/tex">xOy</script>、 <script type="math/tex">yOz</script>、<script type="math/tex">zOx</script>​ 三个平面分别投影，与第一类曲面积分一样，再把另一个变量用投影平面两个变量表达出来，代入被积函数，最后站在平面的上方，（如：<script type="math/tex">zOx</script> 平面站在 y 轴正半轴往下看）如果曲面方向指向被观察者，即为正号，否则是负号，即“一投二代三定向”。</p><h2 id="七、格林公式"><a href="#七、格林公式" class="headerlink" title="七、格林公式"></a>七、格林公式</h2><p><script type="math/tex">\iint\limits_{D}(\frac{\partial{Q}}{\partial{x}}-\frac{\partial{P}}{\partial{y}})dxdy=\oint_{L}{Pdx+Qdy}</script> ，D 是以分段光滑的 L （L取正向）为边界的平面闭区域，且 <script type="math/tex">P(x, y)</script>、<script type="math/tex">Q(x, y)</script> 在 D 上有一阶连续偏导数。</p><p>如果闭区域中间有一点使得 P 或 Q 函数无定义，要挖去。</p><p>取 <script type="math/tex">P=-y</script>，<script type="math/tex">Q=x</script>，可以求出面积。</p><p>格林公式相当于牛顿-莱布尼茨公式，将二重积分与第二类曲线积分联系起来。（在平面上）</p><h2 id="八、保守场与势函数"><a href="#八、保守场与势函数" class="headerlink" title="八、保守场与势函数"></a>八、保守场与势函数</h2><h2 id="九、散度与高斯公式"><a href="#九、散度与高斯公式" class="headerlink" title="九、散度与高斯公式"></a>九、散度与高斯公式</h2><h2 id="十、旋度与斯托克斯公式"><a href="#十、旋度与斯托克斯公式" class="headerlink" title="十、旋度与斯托克斯公式"></a>十、旋度与斯托克斯公式</h2><p>未完待续</p>]]></content>
    
    
    <categories>
      
      <category>工科数学分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ 重载赋值运算符</title>
    <link href="/2021/03/31/assignmentoverride/"/>
    <url>/2021/03/31/assignmentoverride/</url>
    
    <content type="html"><![CDATA[<h1 id="C-重载赋值运算符"><a href="#C-重载赋值运算符" class="headerlink" title="C++ 重载赋值运算符"></a>C++ 重载赋值运算符</h1><p>如果在含有指针数据成员的类中没有重载赋值运算符，赋值时进行浅复制，导致被赋值对象与赋值对象指向同一地址，析构、操作数据成员时会出现不符合期望的结果，因此需要进行深复制。但仅进行深复制仍然是不够完善的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Demo &amp; Demo::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Demo &amp; obj) &#123;<br><span class="hljs-keyword">delete</span> ptr;<br>ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(*obj.ptr);<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码首先释放 Demo 类中的 ptr 指针，但在遇到 <code>assigned = assigned;</code> 这种自赋值情况时，将会错误地释放掉指针所指向的内存，造成崩溃。在开始前进行判断可避免这一情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">Demo &amp; Demo::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Demo &amp; obj) &#123;<br><span class="hljs-keyword">if</span> (&amp;obj != <span class="hljs-keyword">this</span>) &#123;<br><span class="hljs-keyword">delete</span> ptr;<br>ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(*obj.ptr);<br>&#125;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FlexiCharger 减少笔记本电脑电池损耗</title>
    <link href="/2021/02/02/flexicharger/"/>
    <url>/2021/02/02/flexicharger/</url>
    
    <content type="html"><![CDATA[<h1 id="FlexiCharger-减少笔记本电脑电池损耗"><a href="#FlexiCharger-减少笔记本电脑电池损耗" class="headerlink" title="FlexiCharger 减少笔记本电脑电池损耗"></a>FlexiCharger 减少笔记本电脑电池损耗</h1><h2 id="Part-1-背景"><a href="#Part-1-背景" class="headerlink" title="Part 1 背景"></a>Part 1 背景</h2><p>平时常常插电使用笔记本电脑。在我的认知里，插电时会先用电源适配器满足电脑功耗，再给电池充电。但是，<a href="https://www.zhihu.com/question/25416371/answer/629008593">偶然了解到最好不要让电池长期处在电量充满的情况下后</a>，我希望寻找一种方法来阻止电池充满。经过一番搜索，我<a href="https://easyelectriclife.groupe.renault.com/en/glossary/flexi-charger/">找到</a>了我所使用的蓝天 NK 系列模具开启这种机制的方法—— FlexiCharger。</p><h2 id="Part-2-操作步骤"><a href="#Part-2-操作步骤" class="headerlink" title="Part 2 操作步骤"></a>Part 2 操作步骤</h2><p>1.开机按 F2 进入 BIOS，选择 Setup Utility。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20210202001.jpg" alt="BIOS"></p><p>2.找到 Advanced 中的 Advanced Chipset Control，将 FlexiCharger 调整到 Enabled，下面的 Start Charge 和 Stop Charge 分别是插电后开始充电和停止充电的阈值，合理设置即可。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20210202002.jpg" alt="Advanced Chipset Control"></p>]]></content>
    
    
    <categories>
      
      <category>娱乐</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>神船 TX6 安装 ArchLinux</title>
    <link href="/2020/12/25/arch-install/"/>
    <url>/2020/12/25/arch-install/</url>
    
    <content type="html"><![CDATA[<h1 id="神船-TX6-安装-ArchLinux"><a href="#神船-TX6-安装-ArchLinux" class="headerlink" title="神船 TX6 安装 ArchLinux"></a>神船 TX6 安装 ArchLinux</h1><p>警告！本文可能有大量图片，流量消耗大。</p><p>本文为安装完毕一个多月后撰写，部分回忆可能与事实有所出入，仅供参考。</p><h2 id="Part-1-准备工作"><a href="#Part-1-准备工作" class="headerlink" title="Part 1 准备工作"></a>Part 1 准备工作</h2><p>由于原装 SSD 使用的是被认为较差的群联 PS3111 主控且运行在 SATA 速率下，我选择加装一条 NVMe 的 SSD。蓝天的 NK60SB 模具拥有第二个 M.2 2280 硬盘位，且为 PCIe 3.0 × 4 速率。（在这里补充一下，固件里面可能写的模具是 NKx0Sx，其中 NK50、NK60、NK70 分别对应 15.6 吋、16.1 吋、17.3 吋的屏幕，NK50SZ 无独显，NK50S5 搭载 NVIDIA GeForce MX350 独显，NK50/60/70 后缀 SB 对应 GTX1650，SE 对应 GTX1650Ti，但可能识别是 NKx0Sx，参考神舟的<a href="http://kfgl.hasee.com/lookup/book/bblist.asp">网站</a>）为了管理方便，NVMe 固态“象征性地”在 Windows 下分出 5GiB，其余容量全部不分配。</p><p>虽然安装 ArchLinux 和 WinPE 没啥关系，但为了防止哪天 Win 出问题，我打算顺便创建一个 WinPE 的启动盘。</p><p>在这里，我选择使用 U 盘安装。参考 <a href="https://zhuanlan.zhihu.com/p/31361497">macOS、Windows 10、GParted Live、WinPE 多种操作系统，用一个 U 盘搞定 - 知乎</a>，选择使用 DiskGenius 为 U 盘创建两个 FAT32 的文件分区，第一个分区 3.1GiB，第二个 4.1GiB，用来实现 ArchLinux Live Install 和启动 WinPE。为了方便，可以设置不同的卷标。为了省事，我没有格式化，而是把原有的文件扔进了 PE 的分区。分区后，从 ArchLinux 网站（<a href="https://archlinux.org/download">https://archlinux.org/download</a> ）下载 x86_64 的安装 ISO，用资源管理器装载后把文件复制进第一个分区。下载安装 AOMEI PE Builder，安装，生成 ISO 文件后用同样的方法复制进第二个分区。</p><p>需要注意的是，如果 AOMEI PE Builder 下载缓慢的话，可以用我分享的版本：链接: <a href="https://pan.baidu.com/s/1C3O-OAkBika2yj4UGAU1xw">https://pan.baidu.com/s/1C3O-OAkBika2yj4UGAU1xw</a> 提取码: mfi5，将里面的目录复制到你的下载目录，这个目录在 PE Builder 安装位置的 DownloadPath.ini 文件中有指定。</p><p><img src="https://zhaozihanzzh.github.io/images/aomei_prog.jpg" alt="aomei_prog"></p><p>之后插入 U 盘，在 BIOS 里面 Boot Manager 可以选择 EFI Boot Devices 了，可以进入 AOMEI PE Builder，发现一切正常，也可以进入 ArchISO 看一看。</p><p><img src="https://zhaozihanzzh.github.io/images/sel_boot.jpg" alt="sel_boot"></p><p><img src="https://zhaozihanzzh.github.io/images/aomei_desktop.jpg" alt="aomei_desktop"></p><p><img src="https://zhaozihanzzh.github.io/images/archiso_menu.jpg" alt="archiso_menu"></p><p>然后，尴尬的事情发生了。一直出现</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Waiting <span class="hljs-number">30</span> <span class="hljs-built_in">seconds</span> <span class="hljs-keyword">for</span> device /dev/disk/<span class="hljs-keyword">by</span>-label/ARCH_202011 ...<br><br>ERROR: <span class="hljs-string">&#x27;/dev/disk/by-label/ARCH_202011&#x27;</span> device did <span class="hljs-keyword">not</span> show up <span class="hljs-keyword">after</span> <span class="hljs-number">30</span> <span class="hljs-built_in">seconds</span>...<br><br>​Falling back <span class="hljs-built_in">to</span> interactive prompt<br><br>​You can <span class="hljs-keyword">try</span> <span class="hljs-built_in">to</span> fix <span class="hljs-keyword">the</span> problem manually, <span class="hljs-built_in">log</span> out when you are finished<br><br>sh: can<span class="hljs-string">&#x27;t access tty: job control turned off</span><br></code></pre></td></tr></table></figure><p><img src="https://zhaozihanzzh.github.io/images/starterr.jpg" alt="starterr"></p><p>不得已，我只好格式化 U 盘，这次用 DiskGenius 来往分区里写文件，一番操作后，终于成功启动 LiveCD 了。</p><p><img src="https://zhaozihanzzh.github.io/images/copyiso.png" alt="copyiso"></p><p>为了避免需要在浏览器中登录 WiFi，我使用手机连接 WiFi 后开启 WLAN 信号桥，中继出一个不需要浏览器认证的网络。</p><p><img src="https://zhaozihanzzh.github.io/images/WLANBridge.jpg" alt="WLANBridge"></p><h2 id="Part-2-安装"><a href="#Part-2-安装" class="headerlink" title="Part 2 安装"></a>Part 2 安装</h2><p>整个安装过程，参考以下文章，请以官方 Wiki 为准：<a href="https://wiki.archlinux.org/index.php/Installation_guide_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">Installation guide (简体中文) - ArchWiki</a></p><p><a href="https://zhuanlan.zhihu.com/p/99448314">ArchLinux安装(UEFI) - 知乎</a></p><p><a href="https://www.zhihu.com/question/21427410/answer/171867330">Arch Linux 怎么安装？ - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/202914804">Arch Linux 安装指南 2020.08 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/138951848">2020 Archlinux双系统安装教程（超详细） - 知乎</a></p><p>如果 CAPS-LOCK 按键无法使用，按住 Shift 的同时按下字母键来输入大写字母。</p><p>1.关闭 Win10 的“快速启动”功能（我安装时并没有关闭，漏掉了这一步），重启进入 BIOS，从 U 盘启动 ArchISO，键入以下命令以验证启动模式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls /sys/firmware/efi/efivars<br></code></pre></td></tr></table></figure><p>目录被正常显示，说明我使用的是 UEFI 模式启动。</p><p>接下来我们使用 iwctl 连接 WiFi，键入 <code>iwctl</code> 后使用 <code>device list</code> 命令列出可用的无线网卡，使用 <code>station 网卡名 scan</code> 来扫描后用 <code>station 网卡名 get-networks</code> 列出扫描到的热点，使用 <code>iwctl --passphrase 密码 station 网卡名 connect SSID</code> 连接，之后按 CtrlD 退出 iwctl。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121001.jpg" alt="image-20201121001"></p><p>2.使用 <code>ping archlinux.org</code> 检查能否连接 archlinux 网站，之后使用 <code>timedatectl set-ntp true</code> 命令确保系统时间准确（我当时好像没有检查时间，有些图片缺失）</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121002.jpg" alt="image-20201121002"></p><p>3.使用 <code>fdisk -l</code> 命令查看块设备，发现我们的目标磁盘块设备文件为 /dev/nvme0n1（Linux 中有“一切都是文件”一说），使用 gpt 磁盘分区表，接下来确定分区方案。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121003.jpg" alt="image-20201121003"></p><p>分区参考了 <a href="https://www.zhihu.com/question/25118984/answer/567568759">Linux 桌面用户是否有对 /boot 单独分区的必要？ - 知乎</a>、<a href="https://wiki.archlinux.org/index.php/Partitioning_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">Partitioning (简体中文) - ArchWiki</a>，为了简便选择不设立 swap 分区，选择使用 cfdisk 工具（应该是？）：<code>cfdisk 块设备路径</code> 后会进入一个互动式的界面，在这里我给剩余空间分出 2GiB 留作 EFI 引导和 boot 用（这块硬盘上原来是没有 EFI 分区的），分出 32GiB 作为根目录所需，另外在结尾预留 1.9 GiB 以备以后扩展或修正等后其余容量留给主目录，分区类型分别为 EFI System，Linux root (x86-64)，Linux filesystem，确认磁盘上原有的分区没有被错误地修改后即可写入新的分区，注意要记住你创建的分区的块设备文件，在本例中是屏幕最左侧的那一列。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121004.jpg" alt="image-20201121004"></p><p>4.创建分区完毕后对其进行格式化，Linux 有许多不同的文件系统，但由于本人对文件系统不甚了解，最终为根目录和主目录选择较老的 ext4 文件系统：<code>mkfs.ext4 块设备文件</code>，而根据 Wiki，UEFI 推荐使用 FAT32 文件系统：<code>mkfs.fat -F32 块设备文件</code>。之后进行挂载分区，在这里我把根目录的块设备挂载到 /mnt（<code>mount 块设备 挂载点</code>），之后执行 <code>mkdir /mnt/efi</code>、<code>mkdir /mnt/home</code> 为 EFI 和主目录创建挂载点并挂载。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121005.jpg" alt="image-20201121005"></p><p>5.使用 pacstrap 安装脚本安装 base 软件包、Linux 内核和常规硬件的固件（这里我没有使用 LTS 内核之类的），这里 <code>/mnt</code> 是根目录的挂载点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacstrap /mnt base linux linux-firmware<br></code></pre></td></tr></table></figure><p><img src="https://zhaozihanzzh.github.io/images/image-20201121006.jpg" alt="image-20201121006"></p><p>注意，这里日志中输出的几个关于 aic94xx，wd719x，xhci_pci 的 WARNING 可以参见 Wiki 说明：<a href="https://wiki.archlinux.org/index.php/Mkinitcpio#Possibly_missing_firmware_for_module_XXXX">mkinitcpio - ArchWiki</a>。</p><p>接下来创建分区表（/mnt 仍然是根目录挂载点）： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab<br></code></pre></td></tr></table></figure><p>接着检查一下创建的分区表 /mnt/etc/fstab：<img src="https://zhaozihanzzh.github.io/images/image-20201121007.jpg" alt="image-20201121007"></p><p>6.chroot 进安装的系统环境：<code>arch-chroot /mnt</code>（/mnt 为根目录挂载点），之后执行 <code>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code> 设置为上海（东八区）时间，执行 <code>hwclock --systohc</code> 命令，到此时间设置完毕。 </p><p>7.编辑 /etc/locale.gen 这个文本文件，在此我通过取消对应行前面的注释（即删除 # 号）来将 locale 设置为 en_US.UTF-8，不设置为中文的理由可以见官方 Wiki，据说会使 tty 乱码。之后，在终端执行 locale-gen 命令，然后，同样地创建 /etc/locale.conf，写入：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">LANG</span>=en_US.UTF-<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>8.为你的机器想一个 hostname 来替换这一步的所有 myhostname：</p><p>创建 /etc/hostname，写入以下内容：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">myhostname</span><br></code></pre></td></tr></table></figure><p>在 /etc/hosts 添加对应的信息：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span>localhost<br>::<span class="hljs-number">1</span>    localhost<br><span class="hljs-number">127.0.1.1</span>myhostname.localdomainmyhostname<br></code></pre></td></tr></table></figure><p> 使用 passwd 命令，为 root 用户设置密码。就算你用 sudo，这步也十分重要。</p><p>9.最后安装启动引导，对于我使用的 GPT 分区表 + UEFI 系统，需要安装 grub 和 efibootmgr 软件包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -S grub efibootmgr<br></code></pre></td></tr></table></figure><p>如果你想让 GRUB 自动检测到 Windows 的存在并自动配置好 Windows 的启动条目的话，还需要安装 os-prober 和 ntfs-3g。</p><p>之后执行  <code>grub-install --target=x86_64-efi --efi-directory=/efi --bootloader-id=GRUB</code>。这里的 /efi 是我为 EFI 系统选择的挂载点，最后的 grub 是启动引导器标识，详见 wik，这一步将把 GRUB EFI 安装到 挂载点/EFI/启动引导器标识 路径。之后，执行 <code>grub-mkconfig -o /boot/grub/grub.cfg</code> 来生成配置文件。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121008.jpg" alt="image-20201121008"></p><p>10.到这里可能就可以重启了，可能最好在此之前安装联网相关的软件包，但我已经不记得当时进行了什么操作。按 Ctrl + C 退出 chroot，之后 <code>umount -R 挂载点</code> 以卸载分区，使用 reboot 以重启。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121009.jpg" alt="image-20201121009"></p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121011.jpg" alt="image-20201121011"></p><h2 id="Part-3-锦上添花"><a href="#Part-3-锦上添花" class="headerlink" title="Part 3 锦上添花"></a>Part 3 锦上添花</h2><p>1.电脑时间问题</p><p><a href="https://sspai.com/post/55983">Linux Windows 双系统时间不一致 - 少数派</a></p><p>2.添加用户及 sudo</p><p>以下大部分内容可以在这里找到答案：</p><p><a href="https://wiki.archlinux.org/index.php/General_recommendations">General recommendations - ArchWiki</a></p><p>3.安装桌面环境（DE）</p><p>在这里，我选择 SDDM 作为显示管理器， KDE 作为桌面环境。但是，我安装 KDE 时选择的是 plasma-desktop 这一“最小化安装”，导致安装出来竟然在图形界面没有提供终端模拟器，最后按 Ctrl + Alt + F2 登录进另一个 tty 后手动安装了 konsole 软件包才得以解决。事后我还安装了 dolphin 和 ark。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121012.jpg" alt="image-20201121012"></p><p>4.安装字体</p><p>5.NVIDIA 独显驱动</p><p>我的 Intel Graphics UHD 630集成显卡一开始使用的是 mesa 软件包，希望使用 bumblebee 来实现双显卡切换，最终我的机器不仅无法启动图形界面，连其他的 tty 都无法开启，只好又插上了 ArchISO，卸载了 bumblebee，决定使用 PRIME 方案，结果，Arch wiki 里面nvidia-xconfig 的配置直接让我无法进入 KDE。我发现我的情况似乎与 wiki 上不一致，后来的一些研究为我提供了帮助：<a href="https://forums.developer.nvidia.com/t/archlinux-nvidia-settings-error-unable-to-load-info-from-any-available-system/111170">ArchLinux nvidia-settings ERROR: Unable to load info from any available system</a> 。以下网页说，现代系统不需要 nvidia-xconfig 了。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201121010.jpg" alt="image-20201121010"></p><p>6.键盘背光</p><p>根据网络上的提示，我成功地为 NK60SB 开启了键盘背光，编译了<a href="https://github.com/zhaozihanzzh/clevo-xsm-wmi/commit/5d855522fbd18ddd6b2e3ba91632df909189c9dd">相关驱动</a>。</p><p>7.续航测试</p><p>某日，在图书馆没有能充电的位置了，顺便进行测试：屏幕亮度 20%，连接 WiFi，关闭蓝牙，开启独显（如果我没有配置错误的话）。机器电池 47 WHr，采用 Intel i5-10400 CPU，NVIDIA GeForce GTX1650 独显，16.1吋 60Hz 1080P 屏幕，进行少量网页浏览，主要是 WPS PDF 浏览和 WPS 文字编辑。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201128001.png" alt="image-20201128001"></p><p>8.开启蓝牙</p><p><a href="https://wiki.archlinux.org/index.php/Bluetooth_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">Wiki</a> 中提供了步骤，注意我的机器需要疑难解答中的步骤才能与手机配对。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>通用学术英语词表配套练习</title>
    <link href="/2020/12/18/general-academic-words/"/>
    <url>/2020/12/18/general-academic-words/</url>
    
    <content type="html"><![CDATA[<h1 id="通用学术英语词表配套练习"><a href="#通用学术英语词表配套练习" class="headerlink" title="通用学术英语词表配套练习"></a>通用学术英语词表配套练习</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>perform … analysis 进行 … 分析<br>approach the limit 接近限值<br>area 面积<br>assessment 评估<br>assume 假定，设想<br>authority 权力<br>little information is available on …<br>benefit 收益<br>concept 观念<br>be consistent with 与…一致<br>constitutional reform 宪政改革<br>in the context of 在…具体背景下<br>under the contract 依据合同<br>create flexibility 带来灵活性<br>data 资料<br>high definition 高清<br>be derived from 来源于，衍生于<br>division 分工 distribution 分布 circulation 流通<br>sth. is well established 某事物被认可接受<br>estimate the cost of … at 预估某事完成的成本是 …<br>evidence 证据，不可数名词<br>export 资料等导出<br>factor 因素 point 观点<br>formula 公式<br>fulfil … function 发挥作用<br>be identified as 被确认为 be associated with 有关联<br>per capita income 人均收入<br>indicate 表明<br>interpretation 理解<br>involve 是 … 的一部分，是 … 的结果<br>issue 议题<br>legislation 立法，法律<br>proportion of 前面不加具体数词<br>fiscal 财政的<br>in principle 理论上，原则上<br>procedure 程序<br>proceed 前进<br>qualitative research 定性研究<br>private sector 民营部门，私人部门（sector 扇形，扇区，部门）<br>indifferent 冷淡的，不关心的<br>commonplace 平凡的<br>incline to 倾向于<br>contamination 污染<br>specific provision 特定条款<br>generalization 概括</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>achieve the purpose 达到目的<br>acquisition 获得<br>headquarter 总部<br>alienation 疏远<br>supervision 监督<br>fall into … categories 分为 … 类型<br>commission 委任<br>residence 住所<br>load 传输<br>consequence analysis 结果分析<br>give/deserve/take credit for 因为 … 而受到应有的赞扬<br>demonstration 演示<br>specialty 专业，地方特产<br>final 最终的 eventual 过程和时间上的最终结果<br>suffer injury 受伤<br>journal 某学科或专业的刊物<br>provision 提供 precaution 预防<br>obtain a result 得到结果<br>be perceived to be 被认为是<br>respective 各自的<br>elemental 基础的<br>seek methodologies 寻求方法<br>competence 能力<br>transition 过渡</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>一般情况下，another之后只能接单数名词，如：another student。如果another后的名词有数词或few修饰时，则也可接复数名词，如：another few days.（另外几天）、another five chairs.（另外五把椅子）<br>（摘自 <a href="https://www.yikaow.com/yikao/57644.html）">https://www.yikaow.com/yikao/57644.html）</a><br>compensation 赔偿<br>consent 同意<br>impose constraint 施加约束<br>naming convention 命名约定<br>coordination 协同</p><p>只有一部分，见谅。</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图论</title>
    <link href="/2020/12/08/graph-theory/"/>
    <url>/2020/12/08/graph-theory/</url>
    
    <content type="html"><![CDATA[<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><p>简单辨析一些问题：</p><h2 id="一、图的基本组成"><a href="#一、图的基本组成" class="headerlink" title="一、图的基本组成"></a>一、图的基本组成</h2><p>1.图，组成，无向有向问题</p><p>2.平行边（注意有向图里情况），结点邻接，环（注意度数），孤立点，边关联于结点，边集元素重复，n 阶图？零图？平凡图？空图（及符号表示）？结点的度数，入度，出度（重复的边算吗，符号表示）？最大/小度及其符号？悬挂结点/边？图的度数序列？</p><p>3.简单图？多重图？n 阶无向完全图及符号表示？有向完全图？默认的完全图？n 阶有向/无向完全图的边数？什么是 k - 正则图？n 阶无向完全图是 (n-1) - 正则图吗 ？什么是环图？什么是轮图？轮图最低阶数？什么是 n 方体图？二分图？完全二分图及其记法？带权图的权在边上还是结点，还是都行？</p><p>4.删除边/边集/结点/结点集运算？边的收缩及其符号？加新边及其符号？子图 / 母图？生成子图？由结点集 / 边集导出子图及其符号？<em>G</em>(<em>E</em>-<em>E<sub>1</sub></em>) 与 <em>G</em>-<em>E<sub>1</sub></em> 的区别？<em>G</em> 的补图与符号表示？（注意其结点）图的同构，自互补图？</p><p>5.通路，简单通路，基本通路（又叫初级通路，路径）；回路，简单回路，基本回路（又叫初级回路、圈），奇 / 偶回路，短程线与<em>d</em>(u, v)，连通图、非连通图（无向图）？连通关系（无向图）？连通关系是等价关系吗？<em>W</em>(<em>G</em>) 指什么？简单图里 n-w&lt;=e？点割集与割点？边割集与割边（桥）？可达、相互可达（有向图）？有向图中：单向连通？强连通 / 弱连通？单向连通一定是弱连通？有向连通图？强分图？强连通图判定定理（有点像废话）？</p><p>6.邻接表（局限，有向图、无向图上的表现），有向图的邻接矩阵及某行 / 列和的意义？有向图邻接矩阵 k 次幂的元素意义？无向图的邻接矩阵及其幂？如何通过邻接矩阵判断图的连通性？邻接矩阵与同构的关系？什么是有向图的可达矩阵？怎么利用可达矩阵求强连通分支？什么是有向图的关联矩阵？什么是无向图的关联矩阵（行列代表什么？什么情况下元素为 2 ？每行元素和代表？）<br>邻接，可达，关联矩阵各有什么字母？</p><h2 id="二、特殊图"><a href="#二、特殊图" class="headerlink" title="二、特殊图"></a>二、特殊图</h2><p>1.欧拉回路，欧拉通路，欧拉图，半欧拉图？欧拉图的判定？半欧拉图呢？欧拉有向图、半欧拉有向图中的“有向”？欧拉有向图/半欧拉有向图的充要条件？（半）哈密顿回路 / 图（像欧拉图一样分有向无向吗）？判定哈密顿图的两个充分条件、一个必要条件？半哈密顿图的充分条件？彼得森图？格雷码？格雷码怎么找？</p><p>2.旅行商问题？最短路径问题及 Dijkstra 算法？中国邮路问题？</p><p>3.匹配？极大匹配？最大匹配？（VS 最大元，极大元）<em>M</em> 饱和点 / 非饱和点？完美匹配？<em>M</em> 交错路？<em>M</em> 可扩充路？最大匹配判定定理？</p><p>4.二分图？怎么判断一个图是不是二分图？互补结点集？完全二分图及其符号表示？完全二分图充要条件？【弄错了？】二分图的完备匹配 / 完美匹配？从 <em>V<sub>1</sub></em> 到 <em>V<sub>2</sub></em> 的完备匹配呢？怎么判断二分图是否存在完备匹配？ t 条件是二分图完备匹配存在的充分条件还是必要条件？</p><p>5.平面图？平面嵌入？<em>G</em> 的面？<em>f<sub>0</sub></em> 的中文名与意义？<em>f<sub>1</sub></em> ，<em>f<sub>2</sub></em> …呢？面的边界？deg(<em>f</em>)？∑deg(<em>f<sub>i</sub></em>) 与 e 的关系？连通平面图的欧拉公式与记忆技巧？非连通的平面图呢？什么叫两个图同胚？判定一个图是平面图的充要条件？</p><p>6.<em>G</em>* 是什么，怎么作？<em>G</em>* 是连通的吗？与原图的结点数，面数，边数关系？同构平面图的对偶图也一定同构吗？<em>G</em>* 的对偶图的对偶图和 <em>G</em>* 一定同构吗？什么是对简单图（结点）着色？什么是 k - 可着色的？什么是色数和 k 色图？无环图色数最大是？Brooks 定理（ <em>G</em> 不是完全图或长度为奇数的基本回路时色数最大值）？二分图的色数？色数为 2 能否说明是二分图？k - 可边着色？简单图的边色数？二分图的边色数？</p><h2 id="三、树"><a href="#三、树" class="headerlink" title="三、树"></a>三、树</h2><p>1.无向树？无向树的树叶、分支点、内点？平凡树？森林？<em>T</em> 是连通图且 e=n-1 能判定是无向树吗？<em>T</em> 无回路且 e=n-1 能判定是无向树吗？<em>T</em> 无回路且任意两结点间增加一条边，得到一条且仅一条回路，能判定 <em>T</em> 是无向树吗？证明 <em>T</em> 中结点数不小于 2 时 <em>T</em> 至少有两片树叶。生成树，弦，余树。图 <em>G</em> 有生成树的等价条件。给出求无向连通图的生成树的算法？给出求无向连通图的最小生成树的算法？</p><p>2.有向树？其边的方向是怎样的？有向根树？有向根树的树叶、分支点、树根、内点的定义？某结点的级数（层数）的定义，树的高度的定义？结点间的关系：祖先，后代，父子，兄弟？什么是根子树？什么是 m 元树，m 元正则树，完全 m 元正则树，完全 m 元树（学校的定义）？m 元正则树中结点数，分支点数，m 的关系？利用此关系与定义，能否互推出结点数、分支点数、树叶数的关系式？高为 h 的 m 元树里至多有多少树叶？</p><p>3.什么是有序根树？二元有序根树的左儿子，右儿子，左子树，右子树？介绍二元有序根树的前序遍历算法，中序遍历算法，后序遍历算法？什么是波兰、逆波兰记法？前缀码与二元树？前缀码是唯一的吗？如何生成最优二元树，最佳前缀码？</p><h2 id="四、证明定理："><a href="#四、证明定理：" class="headerlink" title="四、证明定理："></a>四、证明定理：</h2><p>握手定理+性质。（单独的度数可以用求和的方法转到度数和再借助不等式求解）结点总数超过 3 时平面简单图中每个面次数至少为 3。</p><p>某些定量性质：</p><p>图论基本定理（握手定理）？度数为奇数的结点一定有偶数个吗？有向图中所有结点入度之和与出度之和等于什么？怎么判断自然数序列是不是图的度数序列？</p><p>简单图里 n-w&lt;=e？</p><p>连通平面图的欧拉公式</p><p>m 元正则树中结点数，分支点数， m 的关系？利用此关系与定义，能否互推出结点数、分支点数、树叶数的关系式？高为 h 的 m 元树里至多有多少树叶？</p><p>旅行商问题？最短路径问题及 Dijkstra 算法？中国邮路问题？</p><p><em>G</em>* 是什么，怎么作？</p><p>介绍二元有序根树的前序遍历算法，中序遍历算法，后序遍历算法？</p><p>如何生成最优二元树，最佳前缀码？</p><h2 id="五、部分错题"><a href="#五、部分错题" class="headerlink" title="五、部分错题"></a>五、部分错题</h2><p>1.把平面分成 x 个区域，每两个区域相邻，问 x 最大为？</p><p>我的答案：5 正确答案：4</p><p>2.给设 d=(d<sub>1</sub>, d<sub>2</sub>, …, d<sub>n</sub>)，其中 d<sub>i</sub> 为正数，i = 1, 2, …, n。若存在 n 个结点的简单图，使得结点 v<sub>i</sub> 的度数为 d<sub>i</sub>，则称 d 是可图解的。下面给出的各序列中，（  ）不是可图解的。</p><p>A. (1, 1, 1, 2, 3) B. (2, 3, 3, 4, 5, 6) C. (0, 1, 1, 2, 3, 3) D. (1, 3, 3, 4, 5, 6, 6) E. (1, 2, 2, 3, 4, 5)</p><p>我的答案：B E 正确答案：B D E</p><p>3.设 G 是一棵根树，则 G 一定是（  ）</p><p>A. 强连通图 B. 单向连通图 C. 弱连通图 D. 有向连通图</p><p>我的答案：B C D 正确答案：C D</p><p>4.若有向图中无回路，则其每条边都是割边。</p><p>我的答案：对 正确答案：错</p><p>5.K<sub>m,n</sub>，当 m 不等于 n 时不是哈密顿图。</p><p>我的答案：错 正确答案：对</p>]]></content>
    
    
    <categories>
      
      <category>离散数学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>神船 TX6 加致钛 PC005 Active SSD</title>
    <link href="/2020/11/13/ztpc005/"/>
    <url>/2020/11/13/ztpc005/</url>
    
    <content type="html"><![CDATA[<h1 id="神船-TX6-加致钛-PC005-Active-SSD"><a href="#神船-TX6-加致钛-PC005-Active-SSD" class="headerlink" title="神船 TX6 加致钛 PC005 Active SSD"></a>神船 TX6 加致钛 PC005 Active SSD</h1><h2 id="Part-1-安装"><a href="#Part-1-安装" class="headerlink" title="Part 1 安装"></a>Part 1 安装</h2><p>首先，确保机器断电，移除外置电池，用螺丝刀（我的是直径 3mm 的十字螺丝刀）卸下 D 面的 6 颗螺丝。</p><p><img src="https://zhaozihanzzh.github.io/images/7bf1a1d0297cfc72.jpg" alt="7bf1a1d0297cfc72"></p><p><img src="https://zhaozihanzzh.github.io/images/19cb84b171e24f73.jpg" alt="image-20201114011201054"></p><p>然后，准备好 M.2 SSD 的固定螺丝。我从京东自营购入，对方表示不带螺丝。（这里这个螺丝与我的螺丝刀略微不匹配，应该使用略小一点的。用我这个拧神船自带那块固态的螺丝，会直接滑丝）于是只好单独购买……搞这么大盒子，其实只有六个小小的螺丝……</p><p><img src="https://zhaozihanzzh.github.io/images/3089e9848921c7b7.jpg" alt="3089e9848921c7b7"><img src="https://zhaozihanzzh.github.io/images/2484e133816dcf08.jpg" alt="2484e133816dcf08"></p><p><img src="https://zhaozihanzzh.github.io/images/-5afe891743a5908f.jpg" alt="image-20201114011308540"></p><p><img src="https://zhaozihanzzh.github.io/images/57b5dcaf1d9f990f.jpg" alt="image-20201114011323631"></p><p>开箱，取出盘的本体。</p><p><img src="https://zhaozihanzzh.github.io/images/IMG_20201114_010645.jpg" alt="image-20201114011452363"></p><p>放掉身上可能存在的静电，将硬盘一端呈 45° 插入插槽（注意缺口），之后按下并用螺丝固定好。</p><p>因为要加散热片，我就不把 D 面扣上，只是拿 D 面垫着，直接开机。</p><h2 id="Part-2-娱乐测试"><a href="#Part-2-娱乐测试" class="headerlink" title="Part 2 娱乐测试"></a>Part 2 娱乐测试</h2><p><img src="https://zhaozihanzzh.github.io/images/QQ20201121113026.jpg" alt="QQ20201121113026"></p><p>开机后进行格式化。</p><p><img src="https://zhaozihanzzh.github.io/images/IMG_20201114_013228.png" alt="IMG_20201114_013228"></p><p>按照默认设置，结束后，空盘情况下进行一番娱乐：</p><p><img src="https://zhaozihanzzh.github.io/images/04.png" alt="04"></p><p><img src="https://zhaozihanzzh.github.io/images/760d06b46c661b62.png" alt="760d06b46c661b62"></p><p>从中可以看到，在 CrystalDiskMark 中，SSD 温度多次接近 70℃ ，甚至直接撞上 75℃ （貌似温度墙？）不过待机情况下倒是没那么夸张（我拆了 D 面？）。</p><p><img src="https://zhaozihanzzh.github.io/images/IMG_20201114_013548.jpg" alt="IMG_20201114_013548"></p><p><img src="https://zhaozihanzzh.github.io/images/IMG_20201114_013447.jpg" alt="IMG_20201114_013447"></p><p>另外，长江存储官网也有一个对应的工具 YMTC Smart Tool。</p><p><img src="https://zhaozihanzzh.github.io/images/-73937f4019225a34.jpg" alt="-73937f4019225a34"></p><h2 id="Part-3-散热片"><a href="#Part-3-散热片" class="headerlink" title="Part 3 散热片"></a>Part 3 散热片</h2><p>买之前就从各评测看到极端情况下这块 SSD 主控频繁撞温度墙，于是整了这么些东西……</p><p><img src="https://zhaozihanzzh.github.io/images/-372f6c991f7ffb4a.jpg" alt="-372f6c991f7ffb4a"></p><p>那个反光的东西是铜片，拍出来颜色都变了。另外感觉少了一点什么？</p><p>把导热硅片表面的膜撕下（爱撕机膜人），压在盘的芯片面，等按压凹陷平整后把铜片盖上。硅片黏性大，进行操作时最好保持清洁。另外我这块略微有点不太矩形？</p><p><img src="https://zhaozihanzzh.github.io/images/QQ20201121114408.jpg" alt="QQ20201121114408"></p><p>感觉不算厚，起码顶后盖的情况在我这里是没有的。</p><p><img src="https://zhaozihanzzh.github.io/images/QQ20201121114412.jpg" alt="QQ20201121114412"></p><p>压铜片时注意位置，我第一次太靠螺丝孔一侧，导致螺丝拧不上去，只得拆了重新装。由于硅片很黏，我掰开的时候一直担心会不会把芯片给揭掉……不过没有。另外，我没用那个橡皮筋，有一点点担心盘会被弄弯曲。我想这铜片可能不太容易掉下来的吧？</p><p><img src="https://zhaozihanzzh.github.io/images/QQ20201121114334.jpg" alt="QQ20201121114334"></p><p>然后，我并没有进行进一步的测试。（挨打中）</p>]]></content>
    
    
    <categories>
      
      <category>娱乐</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关系和函数</title>
    <link href="/2020/11/02/relations-functions/"/>
    <url>/2020/11/02/relations-functions/</url>
    
    <content type="html"><![CDATA[<h1 id="关系和函数"><a href="#关系和函数" class="headerlink" title="关系和函数"></a>关系和函数</h1><p>简单辨析一些问题：</p><p>有序对，有序 n 元组</p><p>笛卡尔积（直积）</p><p>关系（二元关系）及符号表示，从 A 到 B 的二元关系， A 上的二元关系，E<sub>A</sub>，I<sub>A</sub>，二元关系是一个有序对吗？</p><p>二元关系与有序对构成的集合是否等价？</p><p>二元关系的定义域（前域）、值域（后域）、域及其符号表示？</p><p>关系的表示：集合，关系图（注意 A 到 B 上的与 A 上的），邻接矩阵</p><p>关系的逆</p><p>对关系的并，交，补，差，包含等的结果求逆与对关系求逆后再进行运算相同吗？</p><p>关系的复合运算本质？集合描述时注意换元？满足交换律吗？结合律呢？</p><p>判断复合运算对并运算、交运算的分配情况：</p><script type="math/tex; mode=display">(S\cup P)\circ R\ 与 \ (S\circ R)\cup (P\circ R)</script><script type="math/tex; mode=display">R\circ (S\cup P)\ 与\ (R\circ S)\cup (R\circ P)</script><script type="math/tex; mode=display">(S\cap P)\circ R\ 与\ (S\circ R)\cap (P\circ R)</script><script type="math/tex; mode=display">R\circ (S\cap P)\ 与\ (R\circ S)\cap (R\circ P)</script><p>对关系的复合运算求逆的规则是怎样的？</p><p>关系 R 的 n 次幂是如何定义的？周期性是怎么回事？</p><p>关系矩阵？复合关系的关系矩阵与原来的两个矩阵之间的关系？在这里如何求关系矩阵的乘积？</p><p>关系的性质：什么是自反关系，反自反关系，对称关系，反对称关系，传递关系？</p><p>关系闭包的概念？r(R)，s(R)，t(R) 分别是？怎么求关系的自反闭包、对称闭包、传递闭包？</p><p>当非空集合上两个关系存在包含关系时，其闭包是否也存在包含关系？</p><p>思考以下闭包的并集与并集的闭包的关系？（如果有思考难度，可以考虑举例，特别注意传递闭包）（仍然是非空集合上的）</p><script type="math/tex; mode=display">r(R_1)\cup r(R_2)\ 与\ r(R_1\cup R_2)</script><script type="math/tex; mode=display">s(R_1)\cup s(R_2)\ 与\ s(R_1\cup R_2)</script><script type="math/tex; mode=display">t(R_1)\cup t(R_2)\ 与\ t(R_1\cup R_2)</script><p>若 R 是传递的，s(R) 一定是传递的吗？r(R) 呢？</p><p>能用关系矩阵的运算来求关系的关系闭包吗？</p><p>什么是 Warshall 算法？</p><p>什么是等价关系？等价关系中的一对有序对中的两个元素可以被称为“等价”吗？</p><p>[x]<sub>R</sub> 是什么？等价类是一个集合吗？A/R 是什么？</p><p>什么是一个集合的覆盖和划分？覆盖中的元素能是空集吗？什么是划分中的类/块？划分与商集的关系？划分的元素是？</p><p>什么是偏序关系？什么是偏序集？符号表示？</p><p>什么是可比？什么是不可比？什么是覆盖？哈斯图怎么画？</p><p>可比与全序关系、全序集？</p><p>极小元、最小元、极大元、最大元？</p><p>（集合）上界、下界、上确界、下确界？</p><p>良序集与良序关系？为什么说良序集一定是全序集，全序集不一定是良序集？</p><p>函数的像、原像？函数是一种集合吗？</p><p>B<sup>A</sup> 是什么集合？这种符号与其元素个数有什么关系？</p><p>单射函数、满射函数、双射函数？恒等函数、特征函数？自然映射？</p><p>复合函数的反函数与反函数的复合存在怎样的关系？</p><p>什么是等势？什么是有限集合的基数？可数集、可列集、阿列夫零、0 级无穷大？实数集的基数、1 级无穷大、阿列夫？</p><p>有最大的基数和最大的集合吗？</p><p>补充：注意各种运算的规律与性质，如 $f\circ g$ 是双射时满足“外满内单”。</p><p>错题：若 R 和 S 是集合 A 上的任意两个传递关系，则 R ○ S 也是传递的。</p><p>我的答案：对 正确答案：错</p>]]></content>
    
    
    <categories>
      
      <category>离散数学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>博客相关问题</title>
    <link href="/2020/11/01/gfm-error/"/>
    <url>/2020/11/01/gfm-error/</url>
    
    <content type="html"><![CDATA[<h1 id="博客相关问题"><a href="#博客相关问题" class="headerlink" title="博客相关问题"></a>博客相关问题</h1><p>1.使用 GFM 时发现，加粗、斜体格式用 *** 表示时在某些场景下会出现无法正确解析的问题。<img src="https://zhaozihanzzh.github.io/images/image-20201102210643027.png" alt="image-20201102210643027"></p><p>更换为 **_ 与 _** 后问题消失。</p><p>参考：<a href="https://www.reinforce.cn/t/545.html">https://www.reinforce.cn/t/545.html</a></p><p>2.开启 Typora 的行内公式支持：<a href="https://blog.csdn.net/weixin_30892763/article/details/98202815">https://blog.csdn.net/weixin_30892763/article/details/98202815</a></p><p>3.在 Typora 里面直接粘贴图片会导致图片变成 png 格式，好像会重新编码，压缩过的 jpg 会变成特别大的 png，不清楚是 Windows “照片”还是剪贴板，亦或是 typora 的锅。如果直接从菜单里面“插入本地图片”就会原封不动地插进来。</p><p>4.URL 中的括号等特殊字符需要用转义字符表达以防止解析错误：左括号用 %28，右括号用 %29。</p><p>5.关于 raw.githubusercontent 无法加载图片：将 raw.githubusercontent.com/用户名/用户名.github.io/master/ 替换为 用户名.github.io/</p><p>6.行内公式下划线解析错误时，改用两个 dollar 符号括起来。</p>]]></content>
    
    
    <categories>
      
      <category>计算机杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>初探矩阵</title>
    <link href="/2020/10/25/matrix/"/>
    <url>/2020/10/25/matrix/</url>
    
    <content type="html"><![CDATA[<h1 id="初探矩阵"><a href="#初探矩阵" class="headerlink" title="初探矩阵"></a>初探矩阵</h1><h2 id="一、矩阵定义"><a href="#一、矩阵定义" class="headerlink" title="一、矩阵定义"></a>一、矩阵定义</h2><h3 id="1-数域"><a href="#1-数域" class="headerlink" title="1. 数域"></a>1. 数域</h3><p>对于一个至少含有 0,1 的复数集合的子集 F ，如果其中任意两个数的四则运算所得结果仍在 F 中，那么 F 称为一个数域。显然，有理数域是最小的数域。</p><h3 id="2-矩阵"><a href="#2-矩阵" class="headerlink" title="2. 矩阵"></a>2. 矩阵</h3><p>矩阵是指某一数域中的 m × n 个数排成 m 行 n 列的表。可记为 <strong><em>A</em></strong> = (a<sub>ij</sub>)<sub>mn</sub>，或 <strong><em>A</em></strong><sub>mn</sub>，或 <strong><em>A</em></strong><sub>m×n</sub>。如果没有特殊说明，我们讨论的是复矩阵。</p><p>两矩阵行列分别相等，称为同型矩阵。</p><p>当 m = 1 时，矩阵可以看成一个行向量；当 n = 1 时，矩阵可以看成一个列向量。当 m = n 时，称为 n 阶方阵，其主对角线（只有方阵才有）元素之和为方阵的迹，记作 tr(<strong><em>A</em></strong>)。</p><p>当 n 阶方阵不在主对角线上的元素都为 0 时，称为 n 阶对角矩阵，书写时只需保留主对角线，可记作 <strong><em>A</em></strong> = diag(a<sub>11</sub>, a<sub>22</sub>, …, a<sub>nn</sub>)。当 n 阶方阵不在次对角线上的元素都为 0 时，称为 n 阶反对角矩阵。</p><p>进一步地，如果对角矩阵主对角线所有数全为 1 ，称为单位矩阵，记作 <strong><em>E</em></strong><sub>n</sub> 或 <strong><em>E</em></strong> 。</p><p>当矩阵所有元素为 0 时，称为零矩阵，仍记为 <strong><em>0</em></strong> 。</p><p>仿照行列式，可以定义上三角、下三角矩阵。</p><p>某个矩阵的负矩阵中每个元素都与原矩阵中的对应元素互为相反数。</p><h2 id="二、矩阵运算"><a href="#二、矩阵运算" class="headerlink" title="二、矩阵运算"></a>二、矩阵运算</h2><h3 id="1-矩阵的加法"><a href="#1-矩阵的加法" class="headerlink" title="1.矩阵的加法"></a>1.矩阵的加法</h3><p>两个同型矩阵相加，所得矩阵上元素等于原来两矩阵对应位置元素之和。只有同型矩阵才能相加。某个矩阵减去另一个矩阵相当于加上它的负矩阵。</p><h3 id="2-矩阵的数乘"><a href="#2-矩阵的数乘" class="headerlink" title="2.矩阵的数乘"></a>2.矩阵的数乘</h3><p>某个矩阵与数域中某个数相乘，等于用这个数去乘这一矩阵上的每一个元素。这一点与行列式不同。</p><p>特别地，称 k<strong><em>E</em></strong> 为数量矩阵。</p><h3 id="3-矩阵的乘法"><a href="#3-矩阵的乘法" class="headerlink" title="3.矩阵的乘法"></a>3.矩阵的乘法</h3><p>设矩阵 <strong><em>A</em></strong> = (a<sub>ij</sub>)<sub>sn</sub>，<strong><em>B</em></strong> = (b<sub>kl</sub>)<sub>nm</sub>，则 <strong><em>AB</em></strong> = (c<sub>ij</sub>)<sub>sm</sub>，其中 c<sub>ij</sub> = a<sub>i1</sub>b<sub>1j</sub>+a<sub>i2</sub>b<sub>2j</sub>+a<sub>i3</sub>b<sub>3j</sub>+…+a<sub>n1</sub>b<sub>nj</sub> ，即：</p><script type="math/tex; mode=display">\sum^{n}_{k=1}a_{ik}b_{kj}</script><p>显然，矩阵乘法不满足交换律，当乘号前矩阵的列数与乘号后矩阵的行数不相等时，无法对这两个矩阵求积。另外，两矩阵之积为零矩阵，则这两个矩阵可能都不为零矩阵。</p><p>当 <strong><em>AB</em></strong> = <strong><em>BA</em></strong> 时，称 <strong><em>A</em></strong> 与 <strong><em>B</em></strong> 可交换，易知此时 <strong><em>A</em></strong> 与 <strong><em>B</em></strong> 为同阶方阵。</p><p>当 <strong><em>A</em></strong> 为对角矩阵时，通过设出 <strong><em>B</em></strong> 中的代表项可知，若要 <strong><em>A</em></strong> 与 <strong><em>B</em></strong> 可交换，此时 <strong><em>B</em></strong> 一定亦是对角矩阵。</p><p>矩阵乘法满足结合律、分配律。（矩阵乘法中混入的与数相乘也满足结合律）</p><p>同阶的上三角矩阵的积仍然是上三角矩阵。</p><h3 id="4-方阵的方幂与多项式"><a href="#4-方阵的方幂与多项式" class="headerlink" title="4.方阵的方幂与多项式"></a>4.方阵的方幂与多项式</h3><p>方阵 <strong><em>A</em></strong> 的 k 次方幂 <strong><em>A</em></strong><sup>k</sup> 表示 k 个 <strong><em>A</em></strong> 相乘。特别地， <strong><em>A</em></strong><sup>0</sup> = <strong><em>E</em></strong><sub>n</sub>。显然，在这里满足 <strong><em>A</em></strong><sup>k</sup><strong><em>A</em></strong><sup>l</sup> = <strong><em>A</em></strong><sup>k+l</sup>，（<strong><em>A</em></strong><sup>k</sup>)<sup>l</sup> = <strong><em>A</em></strong><sup>kl</sup>。</p><p>称 f(<strong><em>A</em></strong>) = a<sub>m</sub><strong><em>A</em></strong><sup>m</sup>+a<sub>m-1</sub><strong><em>A</em></strong><sup>m-1</sup>+…+a<sub>1</sub><strong><em>A</em></strong><sup>1</sup>+a<sub>0</sub><strong><em>E</em></strong> 为方阵 <strong><em>A</em></strong> 的 m 次多项式。</p><p>可以证明，方阵 <strong><em>A</em></strong> 的多项式 f(<strong><em>A</em></strong>) 与 g(<strong><em>A</em></strong>) 满足 f(<strong><em>A</em></strong>)g(<strong><em>A</em></strong>)=g(<strong><em>A</em></strong>)f(<strong><em>A</em></strong>)。</p><h3 id="5-矩阵的转置"><a href="#5-矩阵的转置" class="headerlink" title="5.矩阵的转置"></a>5.矩阵的转置</h3><p>将 <strong><em>A</em></strong> 行列互换得到的矩阵称为 <strong><em>A</em></strong> 的转置矩阵，记作 <strong><em>A</em></strong><sup>T</sup> 或 <strong><em>A’</em></strong>。</p><p>矩阵转置时，(<strong><em>A</em></strong>+<strong><em>B</em></strong>)<sup>T</sup>=<strong><em>A</em></strong><sup>T</sup>+<strong><em>B</em></strong><sup>T</sup>，(k<strong><em>A</em></strong>)<sup>T</sup>=k<strong><em>A</em></strong><sup>T</sup>，(<strong><em>AB</em></strong>)<sup>T</sup>=<strong><em>B</em></strong><sup>T</sup><strong><em>A</em></strong><sup>T</sup>，可推广为：(<strong><em>A</em></strong><sub>1</sub><strong><em>A</em></strong><sub>2</sub>…<strong><em>A</em></strong><sub>m</sub>)<sup>T</sup> = <strong><em>A</em></strong><sub>m</sub><sup>T</sup><strong><em>A</em></strong><sub>m-1</sub><sup>T</sup>…<strong><em>A</em></strong><sub>1</sub><sup>T</sup>。</p><p>当某矩阵与其转置矩阵相等时，称其为对称矩阵；当某矩阵与其转置矩阵的负矩阵相等时，称其为反对称矩阵。易知，反对称矩阵主对角线元素均为 0。</p><h3 id="6-矩阵的共轭"><a href="#6-矩阵的共轭" class="headerlink" title="6.矩阵的共轭"></a>6.矩阵的共轭</h3><p>称 <span style="text-decoration: overline"><strong><em>A</em></strong></span> = (<span style="text-decoration: overline">a<sub>ij</sub></span>)<sub>mn</sub> 是 <strong><em>A</em></strong> 的共轭矩阵。则有：<span style="text-decoration: overline"><strong><em>A</em></strong> + <strong><em>B</em></strong> </span> = <span style="text-decoration: overline"><strong><em>A</em></strong></span> + <span style="text-decoration: overline"><strong><em>B</em></strong></span>；<span style="text-decoration: overline">k<strong><em>A</em></strong></span> = <span style="text-decoration: overline">k</span> <span style="text-decoration: overline"><strong><em>A</em></strong></span>；<span style="text-decoration: overline"><strong><em>AB</em></strong></span> = <span style="text-decoration: overline"><strong><em>A</em></strong></span> <span style="text-decoration: overline"><strong><em>B</em></strong></span>；<span style="text-decoration: overline"><strong><em>A</em></strong><sup>T</sup></span> = (<span style="text-decoration: overline"><strong><em>A</em></strong></span>)<sup>T</sup>。</p><h2 id="三、矩阵的分块"><a href="#三、矩阵的分块" class="headerlink" title="三、矩阵的分块"></a>三、矩阵的分块</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>将矩阵用水平、垂直线划分成若干小矩阵所得的小矩阵称为矩阵的子块，以子块为元素的形式上的矩阵称为分块矩阵。</p><p>如果分块矩阵具有类似对角矩阵的形式，称为准对角矩阵。</p><p>分块矩阵进行运算时，要额外注意子块之间的运算是否有意义。</p><h3 id="2-转置"><a href="#2-转置" class="headerlink" title="2.转置"></a>2.转置</h3><p>未分块的矩阵的转置相当于把分块矩阵转置后再转置所有子块。</p><h2 id="四、方阵的行列式"><a href="#四、方阵的行列式" class="headerlink" title="四、方阵的行列式"></a>四、方阵的行列式</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h3><p>方阵 <strong><em>A</em></strong> 上的元素按其位置形成的行列式称为该方阵的行列式，记作 det(<strong><em>A</em></strong>) 或 |<strong><em>A</em></strong>|。有：|k<strong><em>A</em></strong>| = k<sup>n</sup>|<strong><em>A</em></strong>|，|<span style="text-decoration: overline"><strong><em>A</em></strong></span>| = <span style="text-decoration: overline">|<strong><em>A</em></strong>|</span>，</p><h3 id="2-乘积"><a href="#2-乘积" class="headerlink" title="2.乘积"></a>2.乘积</h3><p>|<strong><em>A</em></strong>||<strong><em>B</em></strong>| = |<strong><em>AB</em></strong>|。</p><h3 id="3-矩阵的子式"><a href="#3-矩阵的子式" class="headerlink" title="3.矩阵的子式"></a>3.矩阵的子式</h3><p>在 m × n 矩阵中任意取 k 行 k 列，位于这些选定的行列交叉点上的元素按原顺序排成的 k 阶行列式称为原矩阵的一个子式。</p><h2 id="五、矩阵初等变换"><a href="#五、矩阵初等变换" class="headerlink" title="五、矩阵初等变换"></a>五、矩阵初等变换</h2><h3 id="1-矩阵的初等变换"><a href="#1-矩阵的初等变换" class="headerlink" title="1.矩阵的初等变换"></a>1.矩阵的初等变换</h3><p>矩阵的一次初等行变换，是指对矩阵进行以下三种变换之一：a. 交换矩阵中的两行 b. 用数域中一个非零的数 k 去乘矩阵某行的各元素 c. 把矩阵某行各元素的 k 倍加到另一行中，其中 k 在数域内。这三种分别称为第 Ⅰ、Ⅱ、Ⅲ 种初等行变换。类似地，可以定义矩阵的初等列变换。矩阵的初等行、列变换合称矩阵的初等变换。符号表示与行列式类似。</p><p>如果一个矩阵经过一系列初等变换变成另一个矩阵，那么这两个矩阵等价。</p><h3 id="2-阶梯形矩阵"><a href="#2-阶梯形矩阵" class="headerlink" title="2.阶梯形矩阵"></a>2.阶梯形矩阵</h3><p>当 <strong><em>A</em></strong> = (a<sub>ij</sub>)<sub>mn</sub> 满足：a. 若某行元素全为 0 ，则该行以下均全为 0 元素；b. 当前 r 行均存在非零元素时，若设第 i 行左起第一个非零元素为  $a_{ij_{i}}$，则有 j<sub>1</sub> &lt; j<sub>2</sub> &lt; … &lt; j<sub>r</sub> 恒成立。</p><p>任意一个矩阵可以通过一系列初等行变换化为阶梯形矩阵。</p><h3 id="3-简化阶梯形矩阵"><a href="#3-简化阶梯形矩阵" class="headerlink" title="3.简化阶梯形矩阵"></a>3.简化阶梯形矩阵</h3><p>当阶梯形矩阵满足：a. 所有先导元素（每行第一个非零元素）为 1；b. 先导元素所在列除了先导元素外全为 0 ，称其为简化阶梯形矩阵。</p><h3 id="4-等价标准形矩阵"><a href="#4-等价标准形矩阵" class="headerlink" title="4.等价标准形矩阵"></a>4.等价标准形矩阵</h3><p>等价标准形矩阵的形式：</p><script type="math/tex; mode=display">\left( \begin{matrix} 1 &0 &\cdots &0 &0 &\cdots &0\\0 &1 &\cdots &0 &0 &\cdots &0 \\\vdots &\vdots &&\vdots &\vdots & &\vdots \\ 0 &0 &\cdots &1 &0 &\cdots &0 \\ 0 &0 &\cdots &0 &0 &\cdots &0 \\ \vdots &\vdots & &\vdots\ &\vdots & &\vdots \\0 &0 &\cdots &0 &0 &\cdots &0 \end{matrix} \right)=\left( \begin{matrix} E_r &0  \\ 0 &0 \end{matrix} \right)</script><p>向等价标准形转化时，可能需要用到列变换。</p><h3 id="5-初等矩阵"><a href="#5-初等矩阵" class="headerlink" title="5.初等矩阵"></a>5.初等矩阵</h3><p>第 Ⅰ 种类型初等矩阵：n 阶单位矩阵第 i 行、第 j 行互换所得，记作 <strong><em>P</em></strong>(i, j)。</p><p>第 Ⅱ 种类型初等矩阵：n 阶单位矩阵第 i 行乘非零的 k 所得，记作 <strong><em>P</em></strong>(i(k))。</p><p>第 Ⅲ 种类型初等矩阵：n 阶单位阵第 j 行的 k 倍加到第 i 行所得，记作 <strong><em>P</em></strong>(i, j(k))。</p><p>由于对任意矩阵作第 Ⅰ 种初等行变换相当于该矩阵左乘对应的第 Ⅰ 种初等矩阵，作第 Ⅰ 种初等列变换相当于该矩阵右乘对应的第 Ⅰ 种初等矩阵；对任意矩阵作第 Ⅱ 种初等行变换相当于该矩阵左乘对应的第 Ⅱ 种初等矩阵，作第 Ⅱ 种初等列变换相当于该矩阵右乘对应的第 Ⅱ 种初等矩阵；对任意矩阵作第 Ⅲ 种初等行变换相当于该矩阵左乘对应的第 Ⅲ 种初等矩阵，矩阵 <strong><em>A</em></strong> = (a<sub>ij</sub>)<sub>mn</sub> 右乘 n 阶 <strong><em>P</em></strong>(i, j(k)) 相当于 <strong><em>A</em></strong> 的第 i 列的 k 倍加到第 j 列，则可以将任一矩阵通过左乘或右乘初等矩阵化成等价标准形。</p><h2 id="六、矩阵的秩"><a href="#六、矩阵的秩" class="headerlink" title="六、矩阵的秩"></a>六、矩阵的秩</h2><h3 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h3><p>当非零的 m × n 矩阵 <strong><em>A</em></strong> 有非零的 r 阶子式而没有非零的 (r + 1) 阶子式时，该矩阵的秩为 r ，记作 r(<strong><em>A</em></strong>) 。零矩阵的秩规定为 0。</p><h3 id="2-满秩"><a href="#2-满秩" class="headerlink" title="2.满秩"></a>2.满秩</h3><p>如果 n 阶方阵 <strong><em>A</em></strong> 满足 r(<strong><em>A</em></strong>) = n，则称矩阵 <strong><em>A</em></strong> 为满秩的，或非奇异的，或非退化的。反之，则称 <strong><em>A</em></strong> 为降秩的，或奇异的，或退化的。</p><p>可以证明，方阵满秩与方阵的行列式非零等价。</p><h3 id="3-求解矩阵的秩"><a href="#3-求解矩阵的秩" class="headerlink" title="3.求解矩阵的秩"></a>3.求解矩阵的秩</h3><p>可以证明，初等变换不改变矩阵的秩，两个同型矩阵等价的充要条件为它们有相同的秩。矩阵转置后，秩不变。</p><p>阶梯型矩阵的秩等于其非零行的数目。</p><h2 id="七、矩阵的逆"><a href="#七、矩阵的逆" class="headerlink" title="七、矩阵的逆"></a>七、矩阵的逆</h2><h3 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1.定义"></a>1.定义</h3><p>设 <strong><em>A</em></strong> 为 n 阶方阵，若存在 <strong><em>B</em></strong> 使得 <strong><em>AB</em></strong> = <strong><em>BA</em></strong> = <strong><em>E</em></strong>，则 <strong><em>A</em></strong> 的逆矩阵 <strong><em>A</em></strong><sup>-1</sup> = <strong><em>B</em></strong>。</p><h3 id="2-性质"><a href="#2-性质" class="headerlink" title="2.性质"></a>2.性质</h3><p>a. <strong><em>A</em></strong>、<strong><em>B</em></strong> 可逆时，<strong><em>AB</em></strong> 也可逆，且 (<strong><em>AB</em></strong>)<sup>-1</sup> = <strong><em>B</em></strong><sup>-1</sup><strong><em>A</em></strong><sup>-1</sup>。（逆、转置的顺序要调换，共轭不需要）</p><p>b. <strong><em>A</em></strong> 可逆时，<strong><em>A</em></strong><sup>T</sup> 也可逆，且 (<strong><em>A</em></strong><sup>T</sup>)<sup>-1</sup>= （<strong><em>A</em></strong><sup>-1</sup>)<sup>T</sup>。</p><p>c. <strong><em>A</em></strong> 可逆时，<span style="text-decoration: overline"><strong><em>A</em></strong></span> 也可逆，且 <span style="text-decoration: overline"><strong><em>A</em></strong><sup>-1</sup></span> = (<span style="text-decoration: overline"><strong><em>A</em></strong></span>)<sup>-1</sup>。（逆的共轭等于共轭的逆）</p><p>d. (k<strong><em>A</em></strong>)<sup>-1</sup> = k<sup>-1</sup><strong><em>A</em></strong><sup>-1</sup>。</p><p>e. (<strong><em>A</em></strong><sub>1</sub><strong><em>A</em></strong><sub>2</sub>…<strong><em>A</em></strong><sub>S</sub>)<sup>-1</sup> = <strong><em>A</em></strong><sub>S</sub><sup>-1</sup><strong><em>A</em></strong><sub>S-1</sub><sup>-1</sup>…<strong><em>A</em></strong><sub>1</sub><sup>-1</sup></p><p>f. 上三角矩阵的逆仍然是上三角矩阵。</p><p>但是，(<strong><em>A</em></strong>+<strong><em>B</em></strong>)<sup>-1</sup> 不等于 <strong><em>A</em></strong><sup>-1</sup> + <strong><em>B</em></strong><sup>-1</sup>。</p><h3 id="3-充要条件"><a href="#3-充要条件" class="headerlink" title="3.充要条件"></a>3.充要条件</h3><p>当且仅当方阵 <strong><em>A</em></strong> 的行列式不为零时，<strong><em>A</em></strong> 可逆。</p><h3 id="4-利用伴随矩阵求逆"><a href="#4-利用伴随矩阵求逆" class="headerlink" title="4.利用伴随矩阵求逆"></a>4.利用伴随矩阵求逆</h3><p>定义 <strong><em>A</em></strong><sub>ij</sub> 为 方阵的行列式中元素 a<sub>ij</sub> 的代数余子式，称矩阵</p><script type="math/tex; mode=display">A^*=\left( \begin{matrix} A_{11} &A_{21} &\cdots  &A_{n1}\\A_{12} &A_{22} &\cdots  &A_{n2}\\\vdots &\vdots &&\vdots\\ A_{1n} &A_{2n} &\cdots  &A_{nn} \end{matrix} \right)</script><p>为 <strong><em>A</em></strong> 的伴随矩阵。（特别注意此矩阵经过了转置）</p><p>则有:</p><script type="math/tex; mode=display">A^{-1} = \frac{1}{|A|}A^*</script><p>但此方法较为繁琐。</p><h3 id="5-矩阵初等变换求逆"><a href="#5-矩阵初等变换求逆" class="headerlink" title="5.矩阵初等变换求逆"></a>5.矩阵初等变换求逆</h3><p>对于初等矩阵的逆，有：a. <strong><em>P</em></strong>(i, j)<sup>-1</sup> = <strong><em>P</em></strong>(i, j) b. <strong><em>P</em></strong>(i(k))<sup>-1</sup> = <strong><em>P</em></strong>(i(k<sup>-1</sup>)) c. <strong><em>P</em></strong>(i, j(k))<sup>-1</sup> = <strong><em>P</em></strong>(i, j(-k))，即初等矩阵的逆仍然是初等矩阵。</p><p>可逆矩阵只通过初等行变换即可变为单位矩阵。因此，可逆矩阵可表示为初等矩阵的积。</p><p>求 <strong><em>A</em></strong> 的逆时，可将与其同阶的单位阵加到其右边构成新矩阵，再通过初等行变换将矩阵左半边化成单位矩阵，此时右半边即为要求的逆；或者将与其同阶的单位阵加到其下边构成新矩阵，再通过初等列变换将矩阵上半边化成单位矩阵，此时下半边即为要求的逆。</p><p>这里，给出已知 <strong><em>A</em></strong>，<strong><em>B</em></strong> ，求 <strong><em>A</em></strong><sup>-1</sup><strong><em>B</em></strong> 的较快方法：(<strong><em>A</em></strong>, <strong><em>B</em></strong>) 通过初等行变换化为 (<strong><em>E</em></strong>, <strong><em>A</em></strong><sup>-1</sup><strong><em>B</em></strong>)。</p>]]></content>
    
    
    <categories>
      
      <category>线性代数与解析几何</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ 返回局部变量的引用与地址</title>
    <link href="/2020/10/24/local-variable-pr/"/>
    <url>/2020/10/24/local-variable-pr/</url>
    
    <content type="html"><![CDATA[<h1 id="C-返回局部变量的引用与地址"><a href="#C-返回局部变量的引用与地址" class="headerlink" title="C++ 返回局部变量的引用与地址"></a>C++ 返回局部变量的引用与地址</h1><p>听说 2020 - 1024 = 996？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span>&amp; <span class="hljs-title">refer</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; arg)</span> </span>&#123;<br><span class="hljs-keyword">int</span> inter_var = <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">return</span> inter_var;<br><span class="hljs-comment">// 返回局部变量的引用</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">pointer</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; arg)</span> </span>&#123;<br><span class="hljs-keyword">int</span> var = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> &amp;var;<br><span class="hljs-comment">// 返回指向局部变量的指针</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> number = <span class="hljs-number">996</span>;<br><span class="hljs-comment">// cout &lt;&lt; refer(2020); 错误，不是常引用的引用作形参，实参只能是变量（或常量）。</span><br>cout &lt;&lt; &amp;<span class="hljs-built_in">refer</span>(number) &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-built_in">refer</span>(number)&lt;&lt; endl; <span class="hljs-comment">// 局部变量被销毁</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a_const_int = <span class="hljs-number">2020</span>;<br><span class="hljs-comment">// cout &lt;&lt; refer(a_const_int); 错误，形参访问限制不能弱于实参。</span><br>cout &lt;&lt; <span class="hljs-built_in">pointer</span>(<span class="hljs-number">2020</span> - number) &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *<span class="hljs-built_in">pointer</span>(number) &lt;&lt; endl; <span class="hljs-comment">// 形参为常引用，实参可以为常量，变量，表达式，数值。</span><br><span class="hljs-keyword">void</span>* v = (<span class="hljs-keyword">void</span>*)<span class="hljs-built_in">pointer</span>(number);<br>cout &lt;&lt; *(<span class="hljs-keyword">int</span>*)v &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zhaozihanzzh.github.io/images/image-20201025001237263.png" alt="image-20201025001237263"></p><p>在 Visual Studio 中用 debug 编译，从外部试图访问局部变量时出现了 -858993460。让我们看一下：-858993460 的二进制表示在补码方案下其实是 -858993460 -(-2^31) + 2^31 = 3435973836 的二进制表示，转成 16 进制正是大名鼎鼎的 0xCCCCCCCC 。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201025003653131.png" alt="image-20201025003653131"></p><p>以上代码在 TDM-GCC 4.9.2 上编译，发现正常读取。不论哪种编译器，使用 void 指针间接访问均可行，这反映系统并不会在局部变量生命周期结束后便急着将它写入新的值，短时间内内存上的值还是不变的。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201025005648503.png" alt="image-20201025005648503"></p><p>不过在 Ubuntu 下用 gcc 9.3.0 编译就不一样了……</p><p>总之，这种操作应当避免……</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>进制转换</title>
    <link href="/2020/10/16/base-conversion/"/>
    <url>/2020/10/16/base-conversion/</url>
    
    <content type="html"><![CDATA[<h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><p>（无数的人已经写过这篇了）</p><p>首先介绍一下相关英文：</p><p>进制 Base</p><p>二进制 Binary</p><p>八进制 Octal</p><p>十进制 Decimal</p><p>十六进制 Hexadecimal</p><p>接下来探讨一下其转换。</p><h2 id="Part-1-整数部分"><a href="#Part-1-整数部分" class="headerlink" title="Part 1 整数部分"></a>Part 1 整数部分</h2><p>进制虽然不同，但其表示思想类似，即每一数位上的数字均代表进位的 n 次幂的倍数。因此，我们把其余数制转为十进制是直观容易的：</p><p>FEC (base 16) → 15×16²+14×16+12 (base 10)</p><p>如何将十进制转为其他进制呢？只需逆向以上过程：</p><p>1492 (base 10) → 512×2+64×7+8×2+1×4 (base 10) →2724 (base 8)</p><p>这样，以十进制为桥梁，可以实现进制转换。</p><p>针对十进制转二进制，可以使用长除法，应用“先余为低，后余为高”：（最先得出的余数可以认为代表低数位）</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201016234356469.png" alt="image-20201016234356469"></p><p>将 13 转为二进制，结果为 1101。</p><p>此外，由于除了十进制外的十六进制、八进制的进制数都是 2 的幂，我们也可以从二进制直接转至十六进制或八进制。举个例子，对于 111110110 (base 2) = 766 (base 8)，由于 2³=8 ，从右向左三位三位地分节，将每一节所对应的三位二进制数转为一位八进制后按原节次序排列即可。十六进制同理。</p><p>同样地，也可以用此方法将十六进制、八进制转为二进制，记得补 0 以占位。</p><h2 id="Part-2-小数部分"><a href="#Part-2-小数部分" class="headerlink" title="Part 2 小数部分"></a>Part 2 小数部分</h2><p>一个数的小数部分实质上是当 n 的指数为负数时对整数部分的扩展，对于其他进制转为十进制，这不难理解。但十进制往外转时，除以 n 的负数次幂再取余这一过程可以转成不断对小数部分乘以进制数且按照“先整为高，后整为低”原则取出商数：对于 0.375 (base 10) 转成二进制：</p><p>0.375×2=0.75 -&gt; 0</p><p>0.75×2=1.5     -&gt; 1</p><p>0.5×2=1          -&gt; 1</p><p>化为 0.011 (base 2)。</p>]]></content>
    
    
    <categories>
      
      <category>计算机杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android Studio 模拟器体验 Android Q</title>
    <link href="/2020/10/11/android11/"/>
    <url>/2020/10/11/android11/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-Studio-模拟器体验-Android-Q"><a href="#Android-Studio-模拟器体验-Android-Q" class="headerlink" title="Android Studio 模拟器体验 Android Q"></a>Android Studio 模拟器体验 Android Q</h1><p><img src="https://zhaozihanzzh.github.io/images/image-20201011004247000.png" alt="20201011001"></p><p>​        2020 年 9 月 9 日，Android 11 正式发布了。在这里，使用 Android Studio 自带模拟器对其进行一番轻度把玩。</p><h2 id="Part-1-初步体验"><a href="#Part-1-初步体验" class="headerlink" title="Part 1 初步体验"></a>Part 1 初步体验</h2><p>​        本次更新增强了聊天气泡（然而这里并没有体验），提升了权限方面的保护，在通知面板集成了音乐播放控制，在开发者选项加入对不同屏幕形态的模拟，还增强了电源菜单，修改了启动器部分细节、最近任务后台等等。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011004247007.png" alt="image-20201011004247007"></p><p>正常的通知面板↑</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011004515860.png" alt="image-20201011004515860"></p><p>播放音乐时↑（可能需要 APP 适配？）</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005013961.png" alt="image-20201011005013961"></p><p>设置里可以开启通知历史记录了。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011004646477.png" alt="image-20201011004646477"></p><p>开发者选项，可怕。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011004751292.png" alt="image-20201011004751292"></p><p>电源菜单。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011004842462.png" alt="image-20201011004842462"></p><p>新的最近任务后台。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011004907812.png" alt="image-20201011004907812"></p><p>锁屏（为什么不显示全星期？）</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005121466.png" alt="image-20201011005121466"></p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005136070.png" alt="image-20201011005136070"></p><p>更新的手势（据说那个灵敏度调节有借鉴的成分？）</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005247493.png" alt="image-20201011005247493"></p><p>分享列表可以置顶选中应用了，合理利用应该比较方便，不过据说 Android 9 就有了，10 意外地砍掉了。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005404310.png" alt="image-20201011005404310"></p><p>原生终于有录屏了。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005503015.png" alt="image-20201011005503015"></p><p>“几个月”的权限。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005630444.png" alt="image-20201011005630444"></p><p>时钟好评。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005731378.png" alt="image-20201011005731378"></p><p>应用管理。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005757725.png" alt="image-20201011005757725"></p><p>拨号盘。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005826033.png" alt="image-20201011005826033"></p><p>音量。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005931564.png" alt="image-20201011005931564"></p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011005940489.png" alt="image-20201011005940489"></p><p>Pixel 启动器。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011010004781.png" alt="image-20201011010004781"></p><p>模拟器找不到那个“设备控制器”？</p><h2 id="Part-2-娱乐跑分"><a href="#Part-2-娱乐跑分" class="headerlink" title="Part 2 娱乐跑分"></a>Part 2 娱乐跑分</h2><p><img src="https://zhaozihanzzh.github.io/images/image-20201011010147837.png" alt="image-20201011010147837"></p><p>自带输入法怎么有酷安？是我孤陋寡闻么？</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011010254365.png" alt="image-20201011010254365"></p><p>从某安安装安兔兔，无论模拟器设置中图形渲染使用硬件还是软件，GPU 测试均无法运行。那就这样吧。</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011010501264.png" alt="image-20201011010501264"></p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011010517240.png" alt="image-20201011010517240"></p><p>Are you okay?</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011010545207.png" alt="image-20201011010545207"></p><p>娱乐大师无法运行……</p><p><img src="https://zhaozihanzzh.github.io/images/image-20201011010625076.png" alt="image-20201011010625076"></p><p>感觉 GeekBench 负载好像不太够，每个项目总是 CPU 没跑满就换下一个项目了。不过娱乐兔三十万分的机器怎么就超越了骁龙 865？</p><p>娱乐到此结束……</p>]]></content>
    
    
    <categories>
      
      <category>娱乐</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/09/30/hello-world/"/>
    <url>/2020/09/30/hello-world/</url>
    
    <content type="html"><![CDATA[<p>There is only one heroism in the world: to see the world as it is and to love it.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
